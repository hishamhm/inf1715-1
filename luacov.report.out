
==============================================================================
./lib/lulex.lua
==============================================================================
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      14	local Lulex = {}
        	
        	local rex_ok, rex
        	
      28	for _, flavor in ipairs{"gnu", "pcre", "tre", "posix", "oniguruma"} do
      28	   rex_ok, rex = pcall(require, "rex_"..flavor)
      28	   if rex_ok then
      14	      break
        	   end
        	end
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	local function Lua_match(rule, input, at)
        	   --if (_DEBUG) then print("Lul :: Lua_match") end
*******0	   local match = string.match(input, "^"..rule[1], at)
*******0	   if match then
*******0	      return at + #match
        	   end
        	end
        	
        	local function Re_match(rule, input, at)
        	   --if (_DEBUG) then print("Lul :: Re_match") end
 1858804	   if not rule.pat then
     602	      rule.pat = rex.new("^"..rule[1])
        	   end
 1858804	   local start, finish = rule.pat:find(input:sub(at))
 1858804	   if start then
   95685	      return at+(finish-start)+1
        	   end
        	end
        	
        	local function Run(self, input)
        	   --if (_DEBUG) then print("Lul :: Run") end
     941	   local at = 1
   44169	   while at <= #input do
   43228	      local lrule = nil
   43228	      local llen = 0
 1902032	      for _, rule in ipairs(self.rules) do
 1858804	         local found = self.match(rule, input, at)
 1858804	         if found then
   95685	            local len = found - at
   95685	            if len > llen then
   43670	               llen = len
   43670	               lrule = rule
        	            end
        	         end
        	      end
   43228	      if lrule then
   43228	         lrule[2](input:sub(at, at+llen-1))
   43228	         at = at + llen
        	      else
*******0	         io.write(input:sub(at, at))
*******0	         at = at + 1
        	      end
        	   end
        	end
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
      14	function Lulex.New(rules, use_lua)
        	   --if (_DEBUG) then print("Lul :: New") end
      14	   return {
      14	      match = (use_lua or not rex_ok) and Lua_match or Re_match,
      14	      rules = rules,
      14	      run = Run,
      14	   }
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      14	return Lulex

==============================================================================
./lib/node_codes.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      14	local Nodes = {}
        	
        	-- code of each node
        	--  {
        	--    ["node id"] = $number,
        	--  }
      14	local codes = {
      14	  ["ATTRIBUTION"] = 01,
      14	  ["CALL"]        = 02,
      14	  ["DECLARE"]     = 03,
      14	  ["ELSEIF"]      = 04,
      14	  ["FUNCTION"]    = 05,
      14	  ["IF"]          = 06,
      14	  ["NEGATE"]      = 07,
      14	  ["NEWVAR"]      = 08,
      14	  ["OPERATOR"]    = 09,
      14	  ["PARAMETER"]   = 10,
      14	  ["PARENTHESIS"] = 11,
      14	  ["PROGRAM"]     = 12,
      14	  ["RETURN"]      = 13,
      14	  ["UNARY"]       = 14,
      14	  ["VALUE"]       = 15,
      14	  ["VAR"]         = 16,
      14	  ["WHILE"]       = 17,
        	}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
      14	function Nodes.GetNodesList ()
      51	  return codes
        	end
        	
      14	function Nodes.GetNodeName (node_code)
*******0	  assert(type(node_code) == "number")
*******0	  for name, code in pairs(codes) do
*******0	    if (code == node_code) then
*******0	      return name
        	    end
        	  end
*******0	  return nil
        	end
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      14	return Nodes

==============================================================================
./lib/token_codes.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      14	local Tokens = {}
        	
        	-- code of each token
        	--  {
        	--    ["token id"] = $number,
        	--  }
      14	local codes = {
      14	  COMMENT_LINE  = 610,
      14	  COMMENT_BLOCK = 620,
      14	  K_IF          = 101,
      14	  K_THEN        = 102,
      14	  K_ELSE        = 103,
      14	  K_WHILE       = 104,
      14	  K_LOOP        = 105,
      14	  K_FUN         = 106,
      14	  K_RETURN      = 107,
      14	  K_NEW         = 108,
      14	  K_STRING      = 109,
      14	  K_INT         = 110,
      14	  K_CHAR        = 111,
      14	  K_BOOL        = 112,
      14	  K_TRUE        = 113,
      14	  K_FALSE       = 114,
      14	  K_AND         = 115,
      14	  K_OR          = 116,
      14	  K_NOT         = 117,
      14	  K_END         = 118,
      14	  STRING        = 200,
      14	  NUMBER        = 300,
      14	  ["OP_("]      = 401,
      14	  ["OP_)"]      = 402,
      14	  ["OP_,"]      = 403,
      14	  ["OP_:"]      = 404,
      14	  ["OP_>"]      = 405,
      14	  ["OP_<"]      = 406,
      14	  ["OP_>="]     = 407,
      14	  ["OP_<="]     = 408,
      14	  ["OP_="]      = 409,
      14	  ["OP_<>"]     = 410,
      14	  ["OP_["]      = 411,
      14	  ["OP_]"]      = 412,
      14	  ["OP_+"]      = 413,
      14	  ["OP_-"]      = 414,
      14	  ["OP_*"]      = 415,
      14	  ["OP_/"]      = 416,
      14	  LINE_END      = 500,
      14	  ID            = 800,
      14	  ERROR         = 000,
        	}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
      14	function Tokens.GetTokensList ()
      28	  return codes
        	end
        	
      14	function Tokens.GetTokenName (token_code)
     308	  assert(type(token_code) == "number")
    8120	  for name, code in pairs(codes) do
    8120	    if (code == token_code) then
     308	      return name
        	    end
        	  end
*******0	  return nil
        	end
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      14	return Tokens

==============================================================================
./lib/util.lua
==============================================================================
        	--==============================================================================
        	-- Class Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Class Implementation
        	--==============================================================================
        	
      14	util = {}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--FileExists()
        	--  parameters:
        	--    [1] $string  [file path and name including extension to be evaluated]
        	--  return:
        	--    [1] $boolean [true if file exists, false otherwise]
      28	function util.FileExists(file)
*******0	  if (file == nil or type(file) ~= "string" or file == "") then
*******0	    return false
        	  end
*******0	  local f, msg = io.open(file, "r")
*******0	  if (f == nil) then
*******0	    return false
        	  end
*******0	  f:close()
*******0	  return true
        	end
        	
        	--FileToTable()
        	--  parameters:
        	--    [1] 
        	--  return:
        	--    [1] 
      28	function util.FileToTable(file)
*******0	  if (file == nil or type(file) ~= "string" or file == "") then
*******0	    return false, "Parameter 'file' is invalid"
        	  end
*******0	  local f = io.open(file, "r")
*******0	  if (f == nil) then
*******0	    return false, "Could not open desired file"
        	  end
*******0	  local t = FileToTableAux(f, {})
*******0	  f:close()
*******0	  if (t and type(t) == "table") then
*******0	    return true, t
        	  end
*******0	  return false, {}
        	end
        	
        	--StringIsNull()
        	--  parameters:
        	--    [1] $string  [string that is going to be evaluated]
        	--  return:
        	--    [1] $boolean [true if string is null]
      28	function util.StringIsNull(str)
*******0	  return (str == nil or str == "")
        	end
        	
        	--TableCopy()
        	--  parameters:
        	--    [1] $table [table that is going to be duplicated]
        	--  return:
        	--    [1] $table [copy of incoming table]
      28	function util.TableCopy(t)
   19044	  if (not t or type(t) ~= "table") then
*******0	    return
        	  end
   19044	  local ret = {}
   19044	  local mt = getmetatable(t)
   19044	  if mt then
*******0	    setmetatable(ret, mt)
        	  end
   76294	  for k,v in pairs(t) do
   57250	    v = rawget(t, k)
   57250	    if type(v)== "table" then
   16489	      rawset(ret, k, util.TableCopy(v))
        	    else
   40761	      rawset(ret, k, v)
        	    end
        	  end
   19044	  return ret
        	end
        	
        	--TableGetChanges()
        	--  required:
        	--    [1] $table [old table]
        	--    [2] $table [new table]
        	--  return:
        	--    [1] $table [fields that have been modified from old_table to new_table]
      28	function util.TableGetChanges(old_table, new_table)
*******0	  if not old_table or not new_table then 
*******0	    return 
        	  end
*******0	  local changes = {}
*******0	  for k, v in pairs(old_table) do
*******0	    if type(v) == "table" then
*******0	      changes[k] = utils.GetTableChanges(v, new_table[k])
        	    else
*******0	      if new_table[k] ~= nil and new_table[k] ~= v then
*******0	        changes[k] = new_table[k]
        	      end
        	    end
        	  end
*******0	  if next(changes) then
*******0	    return changes
        	  end
        	end
        	
        	--TableIsEmpty()
        	--  parameters:
        	--    [1] $table   [table that is going to be valuated]
        	--  return:
        	--    [1] $boolean [true if table is empty, false otherwise]
      28	function util.TableIsEmpty (t)
*******0	  assert(type(t) == "table")
*******0	  for _, _ in pairs(t) do
*******0	    return false
        	  end
*******0	  return true
        	end
        	
        	--TablePrint()
        	--  parameters:
        	--    [1] $table [table that is going to be printed]
      28	function util.TablePrint (t)
*******0	  if (not t) then
*******0	    return
        	  end
*******0	  print(TablePrintAux("", t, ""))
        	end
        	
        	--TableToFile()
        	--  parameters:
        	--    [1] $table  [table that is going to be printed]
        	--  return:
        	--    [1] $string [string of copied table]
      28	function util.TableToFile (file, t)
*******0	  if (file == nil or type(file) ~= "string" or file == "") then
*******0	    return false, "Parameter 'file' is invalid"
        	  end
*******0	  local f = io.open(file, "w")
*******0	  if (f == nil) then
*******0	    return false, "Could not open desired file"
        	  end
*******0	  if (not t) then
*******0	    return
        	  end
*******0	  TableToFileAux(f, "", t, "")
*******0	  f:close()
*******0	  return true
        	end
        	
        	--TableToString()
        	--  parameters:
        	--    [1] $table  [table that is going to be printed]
        	--  return:
        	--    [1] $string [string of copied table]
      28	function util.TableToString (t)
*******0	  if (not t) then
*******0	    return
        	  end
*******0	  return TablePrintAux("", t, "")
        	end
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
      14	function FileToTableAux(file, t)
*******0	  local str = file:read()
*******0	  while (str) do
*******0	    if (string.find(str, '%["([^"]+)"%] = {')) then
*******0	      local _, _, field = string.find(str, '%["([^"]+)"%] = {')
*******0	      t[field] = FileToTableAux(file, {})
*******0	    elseif (string.find(str, '%[([^%]]+)%] = {')) then
*******0	      local _, _, n = string.find(str, '%[([^%]]+)%] = {')
*******0	      n = tonumber(n)
*******0	      t[n] = FileToTableAux(file, {})
*******0	    elseif (string.find(str, '%["([^"]+)"%]%s%=%s"([^"]+)"')) then
*******0	      local _, _, field, value = string.find(str, '%["([^"]+)"%]%s%=%s"([^"]+)"')
*******0	      t[field] = value
*******0	    elseif (string.find(str, '%[([^%]]+)%]%s%=%s"([^"]+)"')) then
*******0	      local _, _, n, value = string.find(str, '%[([^%]]+)%]%s%=%s"([^"]+)"')
*******0	      n = tonumber(n)
*******0	      t[n] = value
*******0	    elseif (string.find(str, "}")) then
*******0	      return t
        	    end
*******0	    str = file:read()
        	  end
        	end
        	
      14	function TablePrintAux (s, t, indent)
*******0	  s = s .. "{\n"
*******0	  local oldindent = indent
*******0	  indent = indent .. "  "
*******0	  for k, v in pairs(t) do
*******0	    if (type(k) == "string") then
*******0	      s = s .. indent .. "[" .. string.format("%q", k) .. "] = "
*******0	    elseif (type(k) == "number") then
*******0	      s = s .. indent .. "[" .. k .. "] = "
        	    end
*******0	    if (type(v) == "table") then
*******0	      s = TablePrintAux(s, v, indent)
*******0	    elseif (type(v) == "string") then
*******0	      s = s .. string.format("%q", v)
        	    else
*******0	      s = s .. tostring(v)
        	    end
*******0	    s = s .. ",\n"
        	  end
*******0	  s = s .. oldindent .. "}"
*******0	  return s
        	end
        	
      14	function TableToFileAux (file, s, t, indent)
*******0	  file:write("{\n")
*******0	  local oldindent = indent
*******0	  indent = indent .. "  "
*******0	  for k, v in pairs(t) do
*******0	    if (type(k) == "string") then
*******0	      file:write(indent .. "[" .. string.format("%q", k) .. "] = ")
*******0	    elseif (type(k) == "number") then
*******0	      file:write(indent .. "[" .. k .. "] = ")
        	    end
*******0	    if (type(v) == "table") then
*******0	      s = TableToFileAux(file, s, v, indent)
*******0	    elseif (type(v) == "string") then
*******0	      file:write(string.format("%q", v))
        	    else
*******0	      file:write(tostring(v))
        	    end
*******0	    file:write(",\n")
        	  end
*******0	  file:write(oldindent .. "}")
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	

==============================================================================
./lib/util_tree.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
       9	local NodesClass  = require "lib/node_codes"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
       9	local Print = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
       9	local nodes_codes = NodesClass.GetNodesList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
       9	function Print.Block (indent, t)
      17	  if (t) then
      42	    for _, node in ipairs(t) do
      25	      if (node.id == nodes_codes["ATTRIBUTION"]) then
      11	        Print.ComandAttribution(indent, node)
      14	      elseif (node.id == nodes_codes["IF"]) then
       1	        Print.ComandIf(indent, node)
      13	      elseif (node.id == nodes_codes["RETURN"]) then
       5	        Print.ComandReturn(indent, node)
       8	      elseif (node.id == nodes_codes["WHILE"]) then
       2	        Print.ComandWhile(indent, node)
       6	      elseif (node.id == nodes_codes["DECLARE"]) then
       2	        Print.Declare(indent, node)
       4	      elseif (node.id == nodes_codes["CALL"]) then
       4	        Print.Call(indent, node)
        	      --elseif (node.id == nodes_codes["VAR"]) then
        	        --Print.Variable(indent, node)
        	      else
*******0	        error("block node error")
        	      end
        	    end
        	  end
        	end
        	
       9	function Print.Call (indent, t)
       4	  print(indent .. "CALL [" .. t.name .. "] @" .. t.line .. "  {")
       6	  for _, node in ipairs(t.exps) do
       2	    print(indent .. "  PARAM " .. Print.Expression(node))
        	  end
       4	  local str = indent .. "}"
       4	  if (t.sem_type and t.sem_dimension) then
       3	    str = str .. string.format(" #%s:%d", t.sem_type, t.sem_dimension)
        	  end
       4	  print(str)
        	end
        	
       9	function Print.ComandAttribution (indent, t)
      23	  print(indent .. "ATRIB @" .. t.line .. " {")
      23	  local str = ""
      23	  str = str .. t.var.name
      23	  if (t.var.array) then
      30	    for _, exp in ipairs(t.var.array) do
       7	      str = str .. "[" .. Print.Expression(exp) .. "]"
        	    end
        	  end
      23	  Print.Variable(indent .. "  ", t.var)
        	
      23	  print(indent .. "  =" .. Print.Expression(t.exp))
      23	  print(indent .. "}")
        	end
        	
       9	function Print.ComandElseIf (indent, t)
       2	  print(indent .. "ELSEIF [" .. Print.Expression(t.cond) .. "] @" .. t.line)
       2	  Print.Block(indent .. "  ", t.block)
        	end
        	
       9	function Print.ComandIf (indent, t)
       6	  print(indent .. "IF [" .. Print.Expression(t.cond) .. "] @" .. t.line .. " {")
       6	  Print.Block(indent .. "  ", t.block)
       6	  if (t["elseif"]) then
       8	    for _, elseif_node in ipairs(t["elseif"]) do
       2	      Print.ComandElseIf(indent, elseif_node)
        	    end
        	  end
       6	  if (t["else"]) then
       5	    print(indent .. "ELSE ")
       5	    Print.Block(indent .. "  ", t["else"])
        	  end
       6	  print(indent .. "}")
        	end
        	
       9	function Print.ComandReturn (indent, t)
       8	  print(indent .. "RETURN @" .. t.line .. " {")
       8	  print(indent .. "  " .. Print.Expression(t.exp))
       8	  print(indent .. "}")
        	  -- print(indent .. "RETURN [" .. Print.Expression(t.exp) .. "] @" .. t.line)
        	end
        	
       9	function Print.ComandWhile (indent, t)
       4	  print(indent .. "WHILE [" .. Print.Expression(t.cond) .. "] @" .. t.line .. " {")
       4	  Print.Block(indent .. "  ", t.block)
       4	  print(indent .. "}")
        	end
        	
       9	function Print.Declare (indent, t)
      24	  print(indent .. "DECLARE @" .. t.line .. "{")
      24	  print(indent .. "  ID [" .. t.name .. "] " .. t.type .. string.rep("[]", t.dimension) .. " @" .. t.line)
      24	  print(indent .. "}")
        	  -- print(indent .. "DECLARE [" .. t.name .. "] " .. t.type .. string.rep("[]", t.dimension) .. " @" .. t.line)
        	end
        	
       9	function Print.Expression (t)
     109	  local str = "("
     109	  if (not t) then
       7	    return ""
        	  end
     102	  if (t.id == nodes_codes["PARENTHESIS"]) then
*******0	    str = str .. " (" .. Print.Expression(t.exp) .. ")"
     102	  elseif (t.id == nodes_codes["NEWVAR"]) then
       3	    str = str .. " new [" .. Print.Expression(t.exp) .. "] " .. t.type
      99	  elseif (t.id == nodes_codes["NEGATE"]) then
       1	    str = str .. " not " .. Print.Expression(t.exp)
      98	  elseif (t.id == nodes_codes["UNARY"]) then
*******0	    str = str .. " - " .. Print.Expression(t.exp)
      98	  elseif (t.id == nodes_codes["OPERATOR"]) then
      22	    str = str .. Print.Expression(t[1]) .. " " .. t.op .. " " .. Print.Expression(t[2])
      76	  elseif (t.id == nodes_codes["VALUE"]) then
      44	    str = str .. " " .. t.value
      32	  elseif (t.id == nodes_codes["CALL"]) then
       2	    str = str .. " " .. t.name .. "("
       2	    if (t.exps) then
       2	      str = str .. Print.Expression(t.exps[1])
       2	      if (t.exps[2]) then
*******0	        for i = 2, #t.exps do
*******0	          str = str .. ", " .. Print.Expression(t.exps[i])
        	        end
        	      end
        	    end
       2	    str = str .. ")"
      30	  elseif (t.id == nodes_codes["VAR"]) then
      30	    str = str .. " " .. t.name
      30	    if (t.array) then
      30	      for _, exp in ipairs(t.array) do
*******0	        str = str .. "["
*******0	        str = str .. Print.Expression(exp)
*******0	        str = str .. "]"
        	      end
        	    end
        	  else
*******0	    error("expression node error")
        	  end
     102	  if (t.sem_type and t.sem_dimension) then
     102	    str = str .. string.format(" #%s:%d", t.sem_type, t.sem_dimension)
        	  end
     102	  return str .. ")"
        	end
        	
       9	function Print.Function (indent, t)
      15	  print(indent .. "FUN [" .. t.name .. "] @" .. t.line .. " {")
      22	  for _, node in ipairs(t.params) do
       7	    print(indent .. "  FUNC_PARAMETER [" .. node.name .. "] " .. node.type .. string.rep("[]", node.dimension))
        	  end
      15	  print(indent .. "  FUNC_RETURN " .. (t.ret_type or "VOID") .. string.rep("[]", t.ret_dimension or 0))
      45	  for _, node in ipairs(t.block) do
      30	    if (node.id == nodes_codes["DECLARE"]) then
       8	      Print.Declare(indent .. "  ", node)
      22	    elseif (node.id == nodes_codes["CALL"]) then
*******0	      Print.Call(indent .. "  ", node)
      22	    elseif (node.id == nodes_codes["ATTRIBUTION"]) then
      12	      Print.ComandAttribution(indent .. "  ", node)
      10	    elseif (node.id == nodes_codes["IF"]) then
       5	      Print.ComandIf(indent .. "  ", node)
       5	    elseif (node.id == nodes_codes["RETURN"]) then
       3	      Print.ComandReturn(indent .. "  ", node)
       2	    elseif (node.id == nodes_codes["WHILE"]) then
       2	      Print.ComandWhile(indent .. "  ", node)
        	    end
        	  end
      15	  print(indent .. "}")
        	end
        	
       9	function Print.Program (indent, t)
      10	  print(indent .. "PROGRAM {")
      39	  for _, node in ipairs(t) do
      29	    if (node.id == nodes_codes["DECLARE"]) then
      14	      Print.Declare(indent .. "  ", node)
      15	    elseif (node.id == nodes_codes["FUNCTION"]) then
      15	      Print.Function(indent .. "  ", node)
        	    end
        	  end
      10	  print(indent .. "}")
        	end
        	
       9	function Print.Variable (indent, t)
      23	  local array_str = ""
      30	  for _, exp in ipairs(t.array) do
       7	    array_str = array_str .. "[" .. Print.Expression() .. "]"
        	  end
      23	  print(indent .. "ID [" .. t.name .. "] " .. array_str .. " @" .. t.line)
        	end
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Print: Print Abstract Syntax or Semantic Tree with comprehensible format
        	--  parameters:
        	--  return:
       9	function Print.Print (tree)
      10	  if (_DEBUG) then print("PRT :: Print") end
      10	  Print.Program("", tree)
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       9	return Print

==============================================================================
./src/grammar.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
      14	local printTokensMatch = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      14	local TokensClass = require "lib/token_codes"
      14	local ASTClass    = require "src/syntax_tree"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      14	local Language = {}
        	
        	-- Stores Parser Functions
        	--  {
        	--    $name = $function
        	--  }
      14	local Parser = {}
        	
        	-- Stores Grammar Functions
        	--  {
        	--    $name = $function
        	--  }
      14	local Grammar = {}
        	
        	--  list of tokens
        	--  {
        	--    [name] = $number,
        	--  }
      14	local tokens = TokensClass.GetTokensList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	--Error: Callback of errors that occurs during syntax analysis
        	--  Parameters:
        	--    [1] $number - line number of grammar syntax error
        	--  Return:
        	local function Error (line)
     209	  error(string.format("@%d syntactic error.", line), 0)
        	end
        	
        	--Match: Receives a token code number and compare with next avaiable token received from lexical
        	--  Parameters:
        	--    [1] $number - Next expected token code number
        	--  Return:
        	--    [1] $string - Token value/name
        	--    [2] $number - Token line number
        	local function Match (code)
   28560	  if (_DEBUG) then print("LAN :: Match") end
   28560	  local token = Parser.Peek()
   28560	  if (token and token.code == code) then
   28406	    if (_DEBUG or printTokensMatch) then
*******0	      print(string.format("    Match code '%10s' %s", TokensClass.GetTokenName(code), token.token))
        	    end
   28406	    Parser.Advance()
   28406	    return token.token, token.line
        	  else
     154	    if (token) then
     154	      error(string.format("@%d syntactic error: expected token '%s' got token '%s'.", token.line, TokensClass.GetTokenName(code), TokensClass.GetTokenName(token.code)), 0)
        	    else
*******0	      error(string.format("@EOF syntactic error: expected token '%s' got 'END_OF_TOKENS'.", TokensClass.GetTokenName(code)), 0)
        	    end
        	  end
        	end
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	--Block:
        	--  syntax:
        	--    bloco     → { declvar nl }
        	--                { comando nl }
        	--  parameters:
        	--  return:
        	--    [1] $table  - List of DECLARE, [...] nodes
      14	function Grammar.Block ()
    1636	  if (_DEBUG) then print("LAN :: Grammar_bloco") end
    1636	  local list = {}
*******0	  while (true) do
    2121	    local token = Parser.Peek()
    2121	    local token2 = Parser.Peek2()
    2121	    if (token and token2 and token.code == tokens.ID and token2.code == tokens["OP_:"]) then
     499	      table.insert(list, Grammar.DeclareVar())
     499	      Grammar.LineEnd()
        	    else
        	      break
        	    end
        	  end
*******0	  while (true) do
    3726	    local token = Parser.Peek()
    3726	    if (token and
    3726	        token.code == tokens.ID or
    2145	        token.code == tokens.K_IF or
    1789	        token.code == tokens.K_WHILE or
    1695	        token.code == tokens.K_RETURN) then
    2286	      table.insert(list, Grammar.Command() or {}) -- RETIRAR OPCAO {}
    2104	      Grammar.LineEnd()
        	    else
        	      break
        	    end
        	  end
    1440	  return list
        	end
        	
        	--Call:
        	--  syntax:
        	--    chamada   → ID '(' listaexp ')'
        	--  parameters:
        	--  return:
        	--    [1] $table  - CALL node
      14	function Grammar.Call ()
     280	  if (_DEBUG) then print("LAN :: Grammar_chamada") end
        	  local name, line, exps
     280	  name, line = Match(tokens.ID)
     280	  Match(tokens["OP_("])
     280	  exps = Grammar.ListExpressions()
     266	  Match(tokens["OP_)"])
     266	  return ASTClass.NewCallNode(line, name, exps)
        	end
        	
        	--CmdAttrib:
        	--  syntax:
        	--    cmdatrib  → var '=' exp
        	--  parameters:
        	--  return:
        	--    [1] $table  - ATTRIBUTION node
      14	function Grammar.CmdAttrib ()
    1343	  if (_DEBUG) then print("LAN :: Grammar_cmdatrib") end
        	  local var, expression
    1343	  var = Grammar.Var()
    1343	  Match(tokens["OP_="])
    1329	  expression = Grammar.Expression()
    1329	  return ASTClass.NewAttributionNode(var, expression)
        	end
        	
        	--CmdIf:
        	--  syntax:
        	--    cmdif     → 'if' exp nl
        	--                    bloco
        	--                { 'else' 'if' exp nl
        	--                    bloco
        	--                }
        	--                [ 'else' nl
        	--                    bloco
        	--                ]
        	--                'end'
      14	function Grammar.CmdIf ()
     356	  if (_DEBUG) then print("LAN :: Grammar_cmdif") end
        	  local line, condition, block, else_block
     356	  local elseif_nodes = {}
     356	  _, line = Match(tokens.K_IF)
     356	  condition = Grammar.Expression()
     300	  Grammar.LineEnd()
     286	  block = Grammar.Block()
*******0	  while (true) do
     380	    local token = Parser.Peek()
     380	    local token2 = Parser.Peek2()
     380	    if (token and token2 and token.code == tokens.K_ELSE and token2.code == tokens.K_IF) then
        	      local line, condition, block
     136	      _, line = Match(tokens.K_ELSE)
     136	      Match(tokens.K_IF)
     136	      condition = Grammar.Expression()
     108	      Grammar.LineEnd()
     108	      block = Grammar.Block()
     108	      table.insert(elseif_nodes, ASTClass.NewElseIfNode(line, condition, block))
        	    else
        	      break
        	    end
        	  end
     244	  local token = Parser.Peek()
     244	  if (token and token.code == tokens.K_ELSE) then
     120	    Match(tokens.K_ELSE)
     120	    Grammar.LineEnd()
     120	    else_block = Grammar.Block()
        	  end
     244	  Match(tokens.K_END)
     244	  return ASTClass.NewIfNode(line, condition, block, elseif_nodes, else_block)
        	end
        	
        	--CmdReturn:
        	--  syntax:
        	--    cmdreturn → 'return' exp | 'return'
        	--  parameters:
        	--  return:
        	--    [1] $table  - RETURN node
      14	function Grammar.CmdReturn ()
     255	  if (_DEBUG) then print("LAN :: Grammar_cmdreturn") end
        	  local line, exp
     255	  _, line = Match(tokens.K_RETURN)
     255	  local token = Parser.Peek()
     255	  if (token and token.code ~= tokens.LINE_END) then
     215	    exp = Grammar.Expression()
        	  end
     255	  return ASTClass.NewReturnNode(line, exp)
        	end
        	
        	--CmdWhile:
        	--  syntax:
        	--    cmdwhile  → 'while' exp nl
        	--                    bloco
        	--                'loop'
        	--  parameters:
        	--  return:
        	--    [1] $table  - WHILE node
      14	function Grammar.CmdWhile ()
      94	  if (_DEBUG) then print("LAN :: Grammar_cmdwhile") end
        	  local line, exp, block
      94	  _, line = Match(tokens.K_WHILE)
      94	  exp = Grammar.Expression()
      94	  Grammar.LineEnd()
      94	  block = Grammar.Block()
      80	  Match(tokens.K_LOOP)
      66	  return ASTClass.NewWhileNode(line, exp, block)
        	end
        	
        	--Command:
        	--  syntax:
        	--    comando   → cmdif | cmdwhile | cmdatrib | cmdreturn | chamada
        	--  parameters:
        	--  return:
        	--    [1] $table - List of DECLARE, CMDATRIB, CMDIF, CMDRETURN, CMDWHILE, [...] nodes
      14	function Grammar.Command ()
    2286	  if (_DEBUG) then print("LAN :: Grammar_comando") end
    2286	  local token = Parser.Peek()
    2286	  if (token and token.code == tokens.K_IF) then
     356	    return Grammar.CmdIf()
    1930	  elseif (token and token.code == tokens.K_WHILE) then
      94	    return Grammar.CmdWhile()
    1836	  elseif (token and token.code == tokens.K_RETURN) then
     255	    return Grammar.CmdReturn()
    1581	  elseif (token and token.code == tokens.ID) then
    1581	    local token2 = Parser.Peek2()
    1581	    if (token2 and token2.code == tokens["OP_("]) then
     224	      return Grammar.Call()
    1357	    elseif (token2 and 
    1357	            token2.code == tokens["OP_="] or
     133	            token2.code == tokens["OP_["]) then
    1343	      return Grammar.CmdAttrib()
        	    else
      14	      Error(token and token.line or 0)
        	    end
        	  else
*******0	    Error(token and token.line or 0)
        	  end
        	end
        	
        	--Declare:
        	--  syntax:
        	--    decl      → funcao | global
        	--  parameters:
        	--  return:
        	--    [1] $table  - DECLARE or FUNCTION node
      14	function Grammar.Declare ()
    1379	  if (_DEBUG) then print("LAN :: Grammar_decl") end
        	  local decl
    1379	  local token = Parser.Peek()
    1379	  if (token and token.code == tokens.K_FUN) then
    1098	    decl = Grammar.Function(parent_node)
     281	  elseif (token and token.code == tokens.ID) then
     281	    decl = Grammar.Global(parent_node)
        	  else
*******0	    Error(token and token.line or 0)
        	  end
    1085	  return decl
        	end
        	
        	--DeclareVar:
        	--  syntax:
        	--    declvar   → ID ':' tipo
        	--  parameters:
        	--  return:
        	--    [1] $table  - DECLARE node
      14	function Grammar.DeclareVar ()
     780	  if (_DEBUG) then print("LAN :: Grammar_declvar") end
        	  local name, line, typebase, array
     780	  name, line = Match(tokens.ID)
     780	  Match(tokens["OP_:"])
     766	  typebase, array = Grammar.Type()
     738	  return ASTClass.NewDeclVarNode(line, name, typebase, array)
        	end
        	
        	--Expression:
        	--  syntax:
        	--    exp       → LITNUMERAL
        	--              | LITSTRING
        	--              | TRUE
        	--              | FALSE
        	--              | var
        	--              | 'new' '[' exp ']' tipo
        	--              | '(' exp ')'
        	--              | chamada
        	--              | exp '+' exp
        	--              | exp '-' exp
        	--              | exp '*' exp
        	--              | exp '/' exp
        	--              | exp '>' exp
        	--              | exp '<' exp
        	--              | exp '>=' exp
        	--              | exp '<=' exp
        	--              | exp '=' exp
        	--              | exp '<>' exp
        	--              | exp 'and' exp
        	--              | exp 'or' exp
        	--              | 'not' exp
        	--              | '-' exp
      14	function Grammar.Expression ()
    2933	  if (_DEBUG) then print("LAN :: Grammar_exp") end
    2933	  local exp = Grammar.ExpressionLevel1()
    2821	  if (not exp) then
     166	    Error(0)
        	  end
    2655	  return exp
        	end
        	
      14	function Grammar.ExpressionLevel1 ()
    3017	  local left = Grammar.ExpressionLevel2()
    2905	  local token = Parser.Peek()
    2905	  if (token and token.code == tokens.K_OR) then
      84	    Match(tokens.K_OR)
      84	    return ASTClass.NewOperatorNode(token.line, left, "or", Grammar.ExpressionLevel1())
        	  end
    2821	  return left
        	end
        	
      14	function Grammar.ExpressionLevel2 ()
    3157	  local left = Grammar.ExpressionLevel3()
    3045	  local token = Parser.Peek()
    3045	  if (token and token.code == tokens.K_AND) then
     140	    Match(tokens.K_AND)
     140	    return ASTClass.NewOperatorNode(token.line, left, "and", Grammar.ExpressionLevel2())
        	  end
    2905	  return left
        	end
        	
      14	function Grammar.ExpressionLevel3 ()
    3543	  local left = Grammar.ExpressionLevel4()
    3431	  local token = Parser.Peek()
    3431	  if (token and token.code == tokens["OP_="]) then
     290	    Match(tokens["OP_="])
     290	    return ASTClass.NewOperatorNode(token.line, left, "=", Grammar.ExpressionLevel3())
    3141	  elseif (token and token.code == tokens["OP_<>"]) then
      96	    Match(tokens["OP_<>"])
      96	    return ASTClass.NewOperatorNode(token.line, left, "<>", Grammar.ExpressionLevel3())
        	  end
    3045	  return left
        	end
        	
      14	function Grammar.ExpressionLevel4 ()
    3875	  local left = Grammar.ExpressionLevel5()
    3763	  local token = Parser.Peek()
    3763	  if (token and token.code == tokens["OP_>"]) then
      94	    Match(tokens["OP_>"])
      94	    return ASTClass.NewOperatorNode(token.line, left, ">", Grammar.ExpressionLevel4())
    3669	  elseif (token and token.code == tokens["OP_<"]) then
     168	    Match(tokens["OP_<"])
     168	    return ASTClass.NewOperatorNode(token.line, left, "<", Grammar.ExpressionLevel4())
    3501	  elseif (token and token.code == tokens["OP_>="]) then
      14	    Match(tokens["OP_>="])
      14	    return ASTClass.NewOperatorNode(token.line, left, ">=", Grammar.ExpressionLevel4())
    3487	  elseif (token and token.code == tokens["OP_<="]) then
      56	    Match(tokens["OP_<="])
      56	    return ASTClass.NewOperatorNode(token.line, left, "<=", Grammar.ExpressionLevel4())
        	  end
    3431	  return left
        	end
        	
      14	function Grammar.ExpressionLevel5 ()
    4225	  local left = Grammar.ExpressionLevel6()
    4113	  local token = Parser.Peek()
    4113	  if (token and token.code == tokens["OP_+"]) then
     267	    Match(tokens["OP_+"])
     267	    return ASTClass.NewOperatorNode(token.line, left, "+", Grammar.ExpressionLevel5())
    3846	  elseif (token and token.code == tokens["OP_-"]) then
      83	    Match(tokens["OP_-"])
      83	    return ASTClass.NewOperatorNode(token.line, left, "-", Grammar.ExpressionLevel5())
        	  end
    3763	  return left
        	end
        	
      14	function Grammar.ExpressionLevel6 ()
    4401	  local left = Grammar.ExpressionLevel7()
    4289	  local token = Parser.Peek()
    4289	  if (token and token.code == tokens["OP_*"]) then
     123	    Match(tokens["OP_*"])
     123	    return ASTClass.NewOperatorNode(token.line, left, "*", Grammar.ExpressionLevel6())
    4166	  elseif (token and token.code == tokens["OP_/"]) then
      53	    Match(tokens["OP_/"])
      53	    return ASTClass.NewOperatorNode(token.line, left, "/", Grammar.ExpressionLevel6())
        	  end
    4113	  return left
        	end
        	
      14	function Grammar.ExpressionLevel7 ()
    4655	  local token = Parser.Peek()
    4655	  if (token and token.code == tokens.NUMBER) then
    1562	    return ASTClass.NewValueNode(token.line, "int", Match(tokens.NUMBER))
    3093	  elseif (token and token.code == tokens.STRING) then
      84	    return ASTClass.NewValueNode(token.line, "string", Match(tokens.STRING))
    3009	  elseif (token and token.code == tokens.K_TRUE) then
     140	    return ASTClass.NewValueNode(token.line, "bool", Match(tokens.K_TRUE))
    2869	  elseif (token and token.code == tokens.K_FALSE) then
     102	    return ASTClass.NewValueNode(token.line, "bool", Match(tokens.K_FALSE))
    2767	  elseif (token and token.code == tokens.K_NEW) then
      96	    Match(tokens.K_NEW)
      96	    Match(tokens["OP_["])
      96	    local exp = Grammar.Expression()
      96	    Match(tokens["OP_]"])
      96	    local typebase, dimension = Grammar.Type()
      96	    return ASTClass.NewNewVarNode(token.line, exp, typebase, dimension)
    2671	  elseif (token and token.code == tokens.K_NOT) then
     157	    Match(tokens.K_NOT)
     157	    local exp = Grammar.ExpressionLevel7()
     157	    return ASTClass.NewNegateNode(token.line, exp)
    2514	  elseif (token and token.code == tokens.ID) then
        	    local node
    2087	    local token2 = Parser.Peek2()
    2087	    if (token2 and token2.code == tokens["OP_("]) then
      56	      return Grammar.Call()
        	    else
    2031	      return Grammar.Var()
        	    end
     427	  elseif (token and token.code == tokens["OP_("]) then
     232	    Match(tokens["OP_("])
     232	    local exp = Grammar.Expression()
     218	    Match(tokens["OP_)"])
     218	    return exp
     195	  elseif (token and token.code == tokens["OP_-"]) then
      97	    Match(tokens["OP_-"])
      97	    return ASTClass.NewUnaryNode(token.line, Grammar.ExpressionLevel7())
        	  else
      98	    Error(token and token.line or 0)
        	  end
        	end
        	
        	--Function:
        	--  syntax:
        	--    funcao    → 'fun' ID '(' params ')' [ ':' tipo ] nl
        	--                    bloco
        	--                'end' nl
        	--  parameters:
        	--  return:
        	--    [1] $table  - FUNCTION node
      14	function Grammar.Function ()
    1098	  if (_DEBUG) then print("LAN :: Grammar_funcao") end
        	  local name, line, params, ret_type, array_size, block
    1098	  Match(tokens.K_FUN)
    1098	  name, line = Match(tokens.ID)
    1070	  Match(tokens["OP_("])
    1070	  params = Grammar.Parameters()
    1028	  Match(tokens["OP_)"])
    1028	  local token = Parser.Peek()
    1028	  if (token and token.code == tokens["OP_:"]) then
     403	    Match(tokens["OP_:"])
     403	    ret_type, array_size = Grammar.Type()
        	  end
    1028	  Grammar.LineEnd()
    1028	  block = Grammar.Block()
     860	  Match(tokens.K_END)
     860	  Grammar.LineEnd()
     860	  return ASTClass.NewFunctionNode(line, name, params, ret_type, array_size, block)
        	end
        	
        	--Global:
        	--  syntax:
        	--    global    → declvar nl
        	--  parameters:
        	--  return:
        	--    [1] $table  - DECLARE node
      14	function Grammar.Global ()
     281	  if (_DEBUG) then print("LAN :: Grammar_global") end
     281	  local node = Grammar.DeclareVar()
     239	  Grammar.LineEnd()
     225	  return node
        	end
        	
        	--ListExpressions:
        	--  syntax:
        	--    listaexp  → /*vazio*/ | exp { ',' exp }
        	--  parameters:
        	--  return:
        	--    [1] $table  - List of EXPRESSION nodes
      14	function Grammar.ListExpressions ()
     280	  if (_DEBUG) then print("LAN :: Grammar_listaexp") end
     280	  local list = {}
     280	  local token = Parser.Peek()
     280	  if (token and token.code ~= tokens["OP_)"]) then
     207	    table.insert(list, Grammar.Expression())
*******0	    while (true) do
     303	      token = Parser.Peek()
     303	      if (token and token.code == tokens["OP_,"]) then
     110	        Match(tokens["OP_,"])
     110	        table.insert(list, Grammar.Expression())
        	      else
        	        break
        	      end
        	    end
        	  end
     266	  return list
        	end
        	
        	--LineEnd:
        	--  syntax:
        	--    nl        → NL { NL }
      14	function Grammar.LineEnd()
    6127	  if (_DEBUG) then print("LAN :: Grammar_nl") end
    6127	  Match(tokens.LINE_END)
*******0	  while (true) do
    6127	    local token = Parser.Peek()
    6127	    if (token and token.code == tokens.LINE_END) then
      42	      Match(tokens.LINE_END)
        	    else
        	      break
        	    end
        	  end
        	end
        	
        	--Parameter:
        	--  syntax:
        	--    parametro → ID ':' tipo
        	--  parameters:
        	--  return:
        	--    [1] $table  - PARAMETER node
      14	function Grammar.Parameter ()
     448	  if (_DEBUG) then print("LAN :: Grammar_parametro") end
        	  local name, line, typebase, array_size
     448	  name, line = Match(tokens.ID)
     420	  Match(tokens["OP_:"])
     406	  typebase, array_size = Grammar.Type()
     406	  return ASTClass.NewParameterNode(line, name, typebase, array_size)
        	end
        	
        	--Parameters:
        	--  syntax:
        	--    params    → /*vazio*/ | parametro { ',' parametro }
        	--  parameters:
        	--  return:
        	--    [1] $table  - List of PARAMETER nodes
      14	function Grammar.Parameters ()
    1070	  if (_DEBUG) then print("LAN :: Grammar_params") end
    1070	  local list = {}
    1070	  local token = Parser.Peek()
    1070	  if (token and token.code ~= tokens["OP_)"]) then
     313	    table.insert(list, Grammar.Parameter())
*******0	    while (true) do
     406	      token = Parser.Peek()
     406	      if (token and token.code == tokens["OP_,"]) then
     135	        Match(tokens["OP_,"])
     135	        table.insert(list, Grammar.Parameter())
        	      else
        	        break
        	      end
        	    end
        	  end
    1028	  return list
        	end
        	
        	--Program:
        	--  syntax:
        	--    programa  → { NL } decl { decl }
      14	function Grammar.Program ()
     928	  if (_DEBUG) then print("LAN :: Grammar_programa") end
     928	  local node = {}
     928	  local token = Parser.Peek()
     928	  if (token and token.code == tokens.LINE_END) then
     775	    Grammar.LineEnd()
        	  end
     928	  token = Parser.Peek()
     928	  if (token and (token.code == tokens.K_FUN or token.code == tokens.ID)) then
     862	    table.insert(node, Grammar.Declare())
      14	    while (true) do
    1083	      token = Parser.Peek()
    1032	      if (token) then
     551	        table.insert(node, Grammar.Declare())
        	      else
      23	        break
        	      end
        	    end
        	  else
      65	    Error(token and token.line or 0)
        	  end
     538	  ASTClass.NewProgramNode(node)
        	end
        	
        	--Type:
        	--  syntax:
        	--    tipo      → tipobase | '[' ']' tipo
        	--  parameters:
        	--  return:
        	--    [1] $typebase
        	--    [2] $array_size
      13	function Grammar.Type (array_size)
    2014	  if (_DEBUG) then print("LAN :: Grammar_tipo") end
    2015	  array_size = array_size or 0
        	  local typebase
    2116	  local token = Parser.Peek()
    2116	  if (token and
    2116	      token.code == tokens.K_INT or
    1015	      token.code == tokens.K_BOOL or
     729	      token.code == tokens.K_CHAR or
     532	      token.code == tokens.K_STRING) then
    1579	    typebase = Grammar.Typebase()
     474	  elseif (token and token.code == tokens["OP_["]) then
     515	    Match(tokens["OP_["])
     447	    Match(tokens["OP_]"])
     445	    array_size = array_size + 1
     445	    typebase, array_size = Grammar.Type(array_size)
        	  else
      41	    Error(token and token.line or 0)
        	  end
    1990	  return typebase, array_size
        	end
        	
        	--Typebase:
        	--  syntax:
        	--    tipobase  → 'int' | 'bool' | 'char' | 'string'
        	--  parameters:
        	--  return:
        	--    [1] $typebase
      13	function Grammar.Typebase ()
    1558	  if (_DEBUG) then print("LAN :: Grammar_tipobase") end
    1559	  local token = Parser.Peek()
    1643	  if (token and token.code == tokens.K_INT) then
    1186	    Match(tokens.K_INT)
    1186	    return "int"
     525	  elseif (token and token.code == tokens.K_BOOL) then
     354	    Match(tokens.K_BOOL)
     303	    return "bool"
     184	  elseif (token and token.code == tokens.K_CHAR) then
     142	    Match(tokens.K_CHAR)
     133	    return "char"
      45	  elseif (token and token.code == tokens.K_STRING) then
      45	    Match(tokens.K_STRING)
      43	    return "string"
        	  else
       1	    Error(token and token.line or 0)
        	  end
        	end
        	
        	--Var:
        	--  syntax:
        	--    var       → ID | var '[' exp ']'
        	--  parameters:
        	--  return:
        	--    [1] $table - VAR node
      13	function Grammar.Var ()
    3158	  if (_DEBUG) then print("LAN :: Grammar_var") end
        	  local name, line
    3374	  local array = {}
    3374	  name, line = Match(tokens.ID)
     216	  while (true) do
    3524	    local token = Parser.Peek()
    3308	    if (token and token.code == tokens["OP_["]) then
     374	      Match(tokens["OP_["])
     374	      table.insert(array, Grammar.Expression())
     158	      Match(tokens["OP_]"])
        	    else
       8	      break
        	    end
        	  end
    3158	  return ASTClass.NewVarNode(line, name, array)
        	end
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
      13	function Language.Start (func_advance, func_peek, func_peek2)
     872	  if (_DEBUG) then print("LAN :: Start") end
     873	  assert(type(func_advance) == "function")
     928	  assert(type(func_peek) == "function")
     928	  assert(type(func_peek2) == "function")
     928	  Parser.Advance = func_advance
     928	  Parser.Peek = func_peek
     928	  Parser.Peek2 = func_peek2
    1800	  local ok, msg = pcall(function () Grammar.Program() end)
     928	  if (not ok) then
     450	    return false, msg
        	  end
     560	  return true
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      13	return Language
        	
        	
        	--==============================================================================
        	-- Grammar
        	--==============================================================================
        	
        	-- programa  → { NL } decl { decl }
        	--
        	-- decl      → funcao | global
        	--
        	-- nl        → NL { NL }
        	--
        	-- global    → declvar nl
        	--
        	-- funcao    → 'fun' ID '(' params ')' [ ':' tipo ] nl
        	--                bloco
        	--             'end' nl
        	--
        	-- bloco     → { declvar nl }
        	--             { comando nl }
        	--
        	-- params    → /*vazio*/ | parametro { ',' parametro }
        	--
        	-- parametro → ID ':' tipo
        	--
        	-- tipo      → tipobase | '[' ']' tipo
        	--
        	-- tipobase  → 'int' | 'bool' | 'char' | 'string'
        	--
        	-- declvar   → ID ':' tipo
        	--
        	-- comando   → cmdif | cmdwhile | cmdatrib | cmdreturn | chamada 
        	--
        	-- cmdif     → 'if' exp nl
        	--                bloco
        	--             { 'else' 'if' exp nl
        	--                bloco
        	--             }
        	--             [ 'else' nl
        	--                bloco
        	--             ]
        	--             'end'
        	--
        	-- cmdwhile  → 'while' exp nl
        	--                bloco
        	--             'loop'
        	--
        	-- cmdatrib  → var '=' exp
        	--
        	-- chamada   → ID '(' listaexp ')'
        	--
        	-- listaexp  → /*vazio*/ | exp { ',' exp }
        	--
        	-- cmdreturn → 'return' exp | 'return'
        	--
        	-- var       → ID | var '[' exp ']'
        	--
        	-- exp       → LITNUMERAL
        	--           | LITSTRING
        	--           | TRUE
        	--           | FALSE
        	--           | var
        	--           | 'new' '[' exp ']' tipo
        	--           | '(' exp ')'
        	--           | chamada
        	--           | exp '+' exp
        	--           | exp '-' exp
        	--           | exp '*' exp
        	--           | exp '/' exp
        	--           | exp '>' exp
        	--           | exp '<' exp
        	--           | exp '>=' exp
        	--           | exp '<=' exp
        	--           | exp '=' exp
        	--           | exp '<>' exp
        	--           | exp 'and' exp
        	--           | exp 'or' exp
        	--           | 'not' exp
        	--           | '-' exp

==============================================================================
./src/lexical.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
      14	local printTokensCapture  = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      14	local lulex       = require "lib/lulex"
      14	local TokensClass = require "lib/token_codes"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      14	local Lexical = {}
        	
        	-- number of current line
        	local line_number
        	
        	-- lexer instructions and callbacks
        	--  {
        	--    [#] = {
        	--      [1] = pattern,
        	--      [2] = function,
        	--    }
        	--  }
      14	local lexer = {}
        	
        	-- tags read in input
        	--  {
        	--    [#] = {
        	--      code  = $number,
        	--      line  = $number,
        	--      token = $string,
        	--    }
        	--  }
      14	local tags = {}
        	
        	--  list of tokens
        	--  {
        	--    [name] = $number,
        	--  }
      14	local tokens = TokensClass.GetTokensList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	local function StoreToken (code, token, line)
   33499	  if (_DEBUG) then print("LEX :: StoreToken") end
   33499	  assert(code and type(code) == "number")
   33499	  assert(token)
   33499	  assert(line and type(line) == "number")
   33499	  if (_DEBUG or printTokensCapture) then
*******0	    print(string.format("codigo: '%10s' linha: %4d token: %s", TokensClass.GetTokenName(code), line, tostring(token)))
        	  end
   33499	  local t = {
   33499	    code = code,
   33499	    line = line,
   33499	    token = token,
        	  }
   33499	  table.insert(tags, t)
        	end
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
      28	lexer = lulex.New{
      14	  { '[ \t]+',
        	    function (token)
        	    end
      14	  },
      14	  { '//[^\n]+',
        	    function (token)
        	      --StoreToken(tokens.COMMENT_LINE, token, line_number)
        	    end
      14	  },
      14	  { '/\\*([^\\*]|\\*[^/])*\\*/',
        	    function (token)
        	      --StoreToken(tokens.COMMENT_BLOCK, token, line_number)
      42	      local init = 0
     126	      while (string.find(token, "\n", init)) do
      84	        _, init = string.find(token, "\n", init)
      84	        init = init + 1
      84	        line_number = line_number + 1
        	      end
        	    end
      14	  },
      14	  { 'if',
        	    function (token)
     590	      StoreToken(tokens.K_IF, token, line_number)
        	    end
      14	  },
      14	  { 'then',
        	    function (token)
      14	      StoreToken(tokens.K_THEN, token, line_number)
        	    end
      14	  },
      14	  { 'else',
        	    function (token)
     382	      StoreToken(tokens.K_ELSE, token, line_number)
        	    end
      14	  },
      14	  { 'while',
        	    function (token)
      94	      StoreToken(tokens.K_WHILE, token, line_number)
        	    end
      14	  },
      14	  { 'loop',
        	    function (token)
      94	      StoreToken(tokens.K_LOOP, token, line_number)
        	    end
      14	  },
      14	  { 'fun',
        	    function (token)
    1112	      StoreToken(tokens.K_FUN, token, line_number)
        	    end
      14	  },
      14	  { 'return',
        	    function (token)
     325	      StoreToken(tokens.K_RETURN, token, line_number)
        	    end
      14	  },
      14	  { 'new',
        	    function (token)
     110	      StoreToken(tokens.K_NEW, token, line_number)
        	    end
      14	  },
      14	  { 'string',
        	    function (token)
      57	      StoreToken(tokens.K_STRING, token, line_number)
        	    end
      14	  },
      14	  { 'int',
        	    function (token)
    1211	      StoreToken(tokens.K_INT, token, line_number)
        	    end
      14	  },
      14	  { 'char',
        	    function (token)
     146	      StoreToken(tokens.K_CHAR, token, line_number)
        	    end
      14	  },
      14	  { 'bool',
        	    function (token)
     327	      StoreToken(tokens.K_BOOL, token, line_number)
        	    end
      14	  },
      14	  { 'true',
        	    function (token)
     196	      StoreToken(tokens.K_TRUE, token, line_number)
        	    end
      14	  },
      14	  { 'false',
        	    function (token)
     158	      StoreToken(tokens.K_FALSE, token, line_number)
        	    end
      14	  },
      14	  { 'and',
        	    function (token)
     154	      StoreToken(tokens.K_AND, token, line_number)
        	    end
      14	  },
      14	  { 'or',
        	    function (token)
     112	      StoreToken(tokens.K_OR, token, line_number)
        	    end
      14	  },
      14	  { 'not',
        	    function (token)
     171	      StoreToken(tokens.K_NOT, token, line_number)
        	    end
      14	  },
      14	  { 'end',
        	    function (token)
    1524	      StoreToken(tokens.K_END, token, line_number)
        	    end
      14	  },
      14	  { '\\"([^\\"\\\\]|\\\\[nt\\\\"])*\\"',
        	    function (token)
     182	      local str = token
     182	      str = string.gsub(str, '^"', '')
     182	      str = string.gsub(str, '"$', '')
     182	      str = string.gsub(str, '\\"', '"')
     182	      str = string.gsub(str, '\\n', '\n')
     182	      str = string.gsub(str, '\\t', '\t')
     182	      str = string.gsub(str, '\\\\', '\\')
     182	      StoreToken(tokens.STRING, str, line_number)
        	    end
      14	  },
      14	  { '[0-9]+',
        	    function (token)
    1996	      StoreToken(tokens.NUMBER, token, line_number)
        	    end
      14	  },
      14	  { '0x[0-9a-fA-F]+',
        	    function (token)
      28	      StoreToken(tokens.NUMBER, tonumber(token), line_number)
        	    end
      14	  },
      14	  { '\\(',
        	    function (token)
    1708	      StoreToken(tokens["OP_("], token, line_number)
        	    end
      14	  },
      14	  { '\\)',
        	    function (token)
    1708	      StoreToken(tokens["OP_)"], token, line_number)
        	    end
      14	  },
      14	  { ',',
        	    function (token)
     287	      StoreToken(tokens["OP_,"], token, line_number)
        	    end
      14	  },
      14	  { ':',
        	    function (token)
    1631	      StoreToken(tokens["OP_:"], token, line_number)
        	    end
      14	  },
      14	  { '>',
        	    function (token)
     108	      StoreToken(tokens["OP_>"], token, line_number)
        	    end
      14	  },
      14	  { '<',
        	    function (token)
     196	      StoreToken(tokens["OP_<"], token, line_number)
        	    end
      14	  },
      14	  { '>=',
        	    function (token)
      28	      StoreToken(tokens["OP_>="], token, line_number)
        	    end
      14	  },
      14	  { '<=',
        	    function (token)
      84	      StoreToken(tokens["OP_<="], token, line_number)
        	    end
      14	  },
      14	  { '=',
        	    function (token)
    2081	      StoreToken(tokens["OP_="], token, line_number)
        	    end
      14	  },
      14	  { '<>',
        	    function (token)
     124	      StoreToken(tokens["OP_<>"], token, line_number)
        	    end
      14	  },
      14	  { '\\[',
        	    function (token)
     727	      StoreToken(tokens["OP_["], token, line_number)
        	    end
      14	  },
      14	  { '\\]',
        	    function (token)
     727	      StoreToken(tokens["OP_]"], token, line_number)
        	    end
      14	  },
      14	  { '\\+',
        	    function (token)
     309	      StoreToken(tokens["OP_+"], token, line_number)
        	    end
      14	  },
      14	  { '-',
        	    function (token)
     208	      StoreToken(tokens["OP_-"], token, line_number)
        	    end
      14	  },
      14	  { '\\*',
        	    function (token)
     137	      StoreToken(tokens["OP_*"], token, line_number)
        	    end
      14	  },
      14	  { '/',
        	    function (token)
      67	      StoreToken(tokens["OP_/"], token, line_number)
        	    end
      14	  },
      14	  { '[ \n]+',
        	    function (token)
    7667	      StoreToken(tokens.LINE_END, token, line_number)
    7667	      local init = 0
   16390	      while (string.find(token, "\n", init)) do
    8723	        _, init = string.find(token, "\n", init)
    8723	        init = init + 1
    8723	        line_number = line_number + 1
        	      end
        	    end
      14	  },
      14	  { '[a-zA-Z_][a-zA-Z0-9_]*',
        	    function (token)
    6667	      StoreToken(tokens.ID, token, line_number)
        	    end
      14	  },
      14	  { '.',
        	    function (token)
      52	      StoreToken(tokens.ERROR, token, line_number)
        	    end
      14	  },
      28	}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Open:
        	--  parameters:
        	--    [1] $string  - path of file to be analysed
        	--  return:
        	--    [1] $boolean - false if found any problem, true otherwise
        	--    [2] $string  - only when [1] is false, informing which error occurs
      14	function Lexical.Open (txt)
     941	  if (_DEBUG) then print("LEX :: Open") end
     941	  assert(txt and type(txt) == "string")
     941	  tags = {}
     941	  line_number = 1
     941	  lexer:run(txt, true)
   34258	  for _, tab in ipairs(tags) do
   33330	    if (tab.code == tokens.ERROR) then
      13	      return false, string.format("@%d lexical error: could not recognize tags.", tab.line)
        	    end
        	  end
     928	  return true
        	end
        	
      14	function Lexical.GetTags()
     928	  if (_DEBUG) then print("LEX :: GetTags") end
     928	  return tags
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      14	return Lexical

==============================================================================
./src/parser.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      14	local Parser = {}
        	
        	-- store tokens list received in input
      14	local tokens_list = {}
        	
        	-- keep the number of the current token
      14	local current = 0
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Advance:
        	--  parameters:
        	--  return:
      14	function Parser.Advance ()
   28406	  if (_DEBUG) then print("PAR :: Advance") end
   28406	  current = current + 1
        	end
        	
        	--Open: Start a new parser with current table input, erasing any previous one
        	--  parameters:
        	--    [1] $table   - table with tokens read in lexical
        	--  return:
      14	function Parser.Open (t)
     928	  if (_DEBUG) then print("PAR :: Open") end
     928	  assert(type(t) == "table")
     928	  current = 0
     928	  tokens_list = t
        	end
        	
        	--Peek: peek the next token
        	--  parameters:
        	--  return:
      14	function Parser.Peek ()
   84598	  if (_DEBUG) then print("PAR :: Peek") end
   84598	  return tokens_list[current + 1]
        	end
        	
        	--Peek2: peek the second next token
        	--  parameters:
        	--  return:
      14	function Parser.Peek2 ()
    6169	  if (_DEBUG) then print("PAR :: Peek2") end
    6169	  return tokens_list[current + 2]
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      14	return Parser

==============================================================================
./src/semantic.lua
==============================================================================
        	--==============================================================================
        	-- Considerations
        	--==============================================================================
        	
        	-- Functions sets new unreach code variable '@ret' as its return VAR variable
        	-- Functions sets PARAMETER nodes to own scope
        	-- ALLOW overcharge variable in diferent scopes
        	
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
       9	local printTree = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      14	require "lib/util"
      14	local NodesClass  = require "lib/node_codes"
      12	local PrintClass  = require "lib/util_tree"
       9	local SymbolClass = require "src/symbol_table"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
       9	local Semantic = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
       9	local nodes_codes = NodesClass.GetNodesList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	--Error: Callback of errors that occurs during semantic analysis
        	--  Parameters:
        	--    [1] $string
        	--  Return:
        	local function Error (msg, line)
     322	  local str = string.format("@%d semantic error: %s", line or 0, msg or "")
     243	  error(str, 0)
        	end
        	
        	--VerifyAttribution: Verify integrity of ATTRIBUTION node
        	--  Parameters:
        	--    [1] $table  = ATTRIBUTION node
        	--  Return:
      18	function Semantic.VerifyAttribution (node)
      93	  if (_DEBUG) then print("SEM :: VerifyAttribution") end
      58	  assert(node.id == nodes_codes["ATTRIBUTION"])
      50	  Semantic.VerifyVar(node.var)
      42	  Semantic.VerifyExpression(node.exp)
      39	  Semantic.VerifyCompatibleTypes(node.line, node.var.sem_type, node.var.sem_dimension, node.exp.sem_type, node.exp.sem_dimension)
        	  -- MUST UPDATE SYMBOL TABLE VALUE
        	end
        	
        	--VerifyBlock: Verify integrity of BLOCK/COMMANDS nodes
        	--  Parameters:
        	--    [1] $table  = collection of ATTRIBUTION, CALL, DECLARE, IF, RETURN and WHILE nodes
        	--  Return:
     420	function Semantic.VerifyBlock (block)
     391	  if (_DEBUG) then print("SEM :: VerifyBlock") end
     396	  for _, node in ipairs(block) do
     145	    if (node.id == nodes_codes["ATTRIBUTION"]) then
      67	      Semantic.VerifyAttribution(node)
      89	    elseif (node.id == nodes_codes["CALL"]) then
      20	      Semantic.VerifyCall(node)
      71	    elseif (node.id == nodes_codes["DECLARE"]) then
      38	      Semantic.VerifyDeclare(node)
      41	    elseif (node.id == nodes_codes["IF"]) then
      24	      Semantic.VerifyIf(node)
      26	    elseif (node.id == nodes_codes["RETURN"]) then
      14	      Semantic.VerifyReturn(node)
       5	    elseif (node.id == nodes_codes["WHILE"]) then
       5	      Semantic.VerifyWhile(node)
        	    else
*******0	      Error("unknown block node")
        	    end
        	  end
        	end
        	
        	--VerifyCall: Verify integrity of CALL node
        	--  Parameters:
        	--    [1] $table  = CALL node
        	--  Return:
      27	function Semantic.VerifyCall (node)
      10	  if (_DEBUG) then print("SEM :: VerifyCall") end
      12	  assert(node.id == nodes_codes["CALL"])
     104	  local symbol = SymbolClass.GetSymbol(node.name)
     382	  if (not symbol) then
     935	    Error(string.format("symbol '%s' was not declared.", node.name), node.line)
        	  end
     823	  if (symbol.id ~= "function") then
     439	    Error(string.format("attempt to call %s '%s', which is a '%s', not a 'function'.", symbol.id, symbol.name, symbol.type), node.line)
        	  end
     340	  local num_func_params = symbol.params and #symbol.params or 0
     386	  local num_call_params = node.exps and #node.exps or 0
     297	  if (num_func_params ~= num_call_params) then
     350	    Error(string.format("attempt to call function '%s' with '%d' parameter(s), but it demands '%d'.", symbol.name, num_func_params, num_call_params), node.line)
        	  end
     236	  for i = 1, num_func_params do
     143	    Semantic.VerifyExpression(node.exps[i])
     150	    Semantic.VerifyCompatibleTypes(node.line, symbol.params[i].type, symbol.params[i].dimension, node.exps[i].sem_type, node.exps[i].sem_dimension)
        	  end
     148	  node.sem_type = symbol.ret_type
      51	  node.sem_dimension = symbol.ret_dimension
        	end
        	
        	--VerifyCompatibleTypes: Check if two different variables can be matched
        	--  Parameters:
        	--    [1] $number = line number
        	--    [2] $string = type of first variable
        	--    [3] $number = dimension of first variable
        	--    [4] $string = type of second variable
        	--    [5] $number = dimension of second variable
        	--  Return:
      93	function Semantic.VerifyCompatibleTypes (line, first_type, first_dimension, second_type, second_dimension)
     139	  local err = false
     115	  if (first_type ~= second_type) then
      32	    if (first_type == "int" and second_type == "char") or (first_type == "char" and second_type == "int") then
      66	      if (first_dimension ~= second_dimension) then
      57	        err = true
        	      end
      38	    elseif (first_type == "string" and second_type == "char") then
      73	      if (first_dimension + 1 ~= second_dimension) then
      59	        err = true
        	      end
      35	    elseif (first_type == "char" and second_type == "string") then
      42	      if (first_dimension ~= second_dimension + 1) then
      81	        err = true
        	      end
        	    else
      27	      err = true
        	    end
        	  else
      89	    if (first_dimension ~= second_dimension) then
      35	      err = true
        	    end
        	  end
     148	  if (err) then
      26	    Error(string.format("uncompatible types '%s' dimension '%d' and '%s' dimension '%d'.", first_type, first_dimension, second_type, second_dimension), line)
        	  end
      54	  return true
        	end
        	
        	--VerifyDeclare: Verify integrity of DECLARE node
        	--  Parameters:
        	--    [1] $table  = DECLARE node
        	--  Return:
       2	function Semantic.VerifyDeclare (node)
      78	  if (_DEBUG) then print("SEM :: VerifyDeclare") end
      79	  assert(node.id == nodes_codes["DECLARE"])
      44	  local symbol = SymbolClass.GetCurrentScopeSymbol(node.name)
      44	  if (symbol) then
      24	    Error(string.format("symbol '%s' was already declared at line %d.", symbol.name, symbol.line), node.line)
        	  else
     107	    SymbolClass.SetSymbol(node)
        	  end
        	end
        	
        	--VerifyElseIf: Verify integrity of ELSEIF node
        	--  Parameters:
        	--    [1] $table  = ELSEIF node
        	--  Return:
       7	function Semantic.VerifyElseIf (node)
       5	  if (_DEBUG) then print("SEM :: VerifyElseIf") end
      19	  assert(node.id == nodes_codes["ELSEIF"])
       5	  SymbolClass.AddScope()
      41	  Semantic.VerifyExpression(node.cond)
      16	  if (node.cond.sem_type ~= "bool" or node.cond.sem_dimension ~= 0) then
       4	    Error(string.format("'else if' expects expression of type 'bool' with dimension '0', but got type '%s' with dimension '%d'.", node.cond.sem_type, node.cond.sem_dimension), node.line)
        	  end
     180	  Semantic.VerifyBlock(node.block)
     320	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyExpression: Verify integrity of EXPRESSION node
        	--  Parameters:
        	--    [1] $table  = CALL, NEGATE, NEWVAR, OPERATOR, UNARY, VALUE or VAR node
        	--  Return:
     118	function Semantic.VerifyExpression (node)
     374	  if (_DEBUG) then print("SEM :: VerifyExpression") end
     189	  if (node.id == nodes_codes["CALL"]) then
       3	    Semantic.VerifyCall(node)
     155	  elseif (node.id == nodes_codes["NEGATE"]) then
      69	    Semantic.VerifyNegate(node)
     190	  elseif (node.id == nodes_codes["NEWVAR"]) then
      88	    Semantic.VerifyNewVar(node)
     208	  elseif (node.id == nodes_codes["OPERATOR"]) then
      60	    Semantic.VerifyOperator(node)
     144	  elseif (node.id == nodes_codes["UNARY"]) then
      61	    Semantic.VerifyUnary(node)
     134	  elseif (node.id == nodes_codes["VALUE"]) then
     101	    Semantic.VerifyValue(node)
      64	  elseif (node.id == nodes_codes["VAR"]) then
      77	    Semantic.VerifyVar(node)
        	  else
      20	    Error("unknown expression node")
        	  end
        	end
        	
        	--VerifyFunction: Verify integrity of FUNCTION node
        	--  Parameters:
        	--    [1] $table  = FUNCTION node
        	--  Return:
     346	function Semantic.VerifyFunction (node)
     798	  if (_DEBUG) then print("SEM :: VerifyFunction") end
      60	  assert(node.id == nodes_codes["FUNCTION"])
      58	  SymbolClass.AddScope()
     189	  if (node.params) then
     197	    for _, param in ipairs(node.params) do
     190	      if (SymbolClass.GetCurrentScopeSymbol(param.name)) then
     479	        Error("")
        	      end
      58	      SymbolClass.SetSymbol(param)
        	    end
        	  end
      72	  if (node.ret_type) then
     355	    local ret = {
     531	      id        = nodes_codes["DECLARE"],
     833	      name      = "@ret",
     271	      line      = node.line,
     223	      type      = node.ret_type,
     161	      dimension = node.ret_dimension,
       6	    }
     152	    SymbolClass.SetSymbol(ret)
        	  end
      78	  Semantic.VerifyBlock(node.block)
      44	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyGlobals: Add global functions and variables to scope
        	--  Parameters:
        	--    [1] $table  = PROGRAM node
        	--  Return:
      27	function Semantic.VerifyGlobals (t)
      49	  if (_DEBUG) then print("SEM :: VerifyGlobals") end
      56	  assert(t.id == nodes_codes["PROGRAM"])
     173	  for _, node in ipairs(t) do
      91	    local symbol = SymbolClass.GetSymbol(node.name)
     100	    if (symbol) then
      75	      Error(string.format("global symbol '%s' was already declared at line %d.", symbol.name, symbol.line), node.line)
        	    end
     213	    SymbolClass.SetSymbol(node)
        	  end
        	end
        	
        	--VerifyIf: Verify integrity of IF node
        	--  Parameters:
        	--    [1] $table  = IF node
        	--  Return:
      91	function Semantic.VerifyIf (node)
     120	  if (_DEBUG) then print("SEM :: VerifyIf") end
     101	  assert(node.id == nodes_codes["IF"])
      20	  SymbolClass.AddScope()
      73	  Semantic.VerifyExpression(node.cond)
     107	  if (node.cond.sem_type ~= "bool" or node.cond.sem_dimension ~= 0) then
       8	    Error(string.format("'if' expects expression of type 'bool' with dimension '0', but got type '%s' with dimension '%d'.", node.cond.sem_type, node.cond.sem_dimension), node.line)
        	  end
     153	  Semantic.VerifyBlock(node.block)
      91	  if (node["elseif"]) then
       9	    for _, n in ipairs (node["elseif"]) do
      23	      Semantic.VerifyElseIf(n)
        	    end
        	  end
      39	  if (node["else"]) then
      25	    SymbolClass.AddScope()
       8	    Semantic.VerifyBlock(node["else"])
      18	    SymbolClass.RemoveScope()
        	  end
     402	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyNewVar: Verify integrity of NEWVAR node
        	--  Parameters:
        	--    [1] $table  = NEWVAR node
        	--  Return:
     102	function Semantic.VerifyNewVar (node)
     457	  if (_DEBUG) then print("SEM :: VerifyNewVar") end
     904	  assert(node.id == nodes_codes["NEWVAR"])
      50	  Semantic.VerifyExpression(node.exp)
      51	  if (node.exp.sem_type ~= "int" and node.exp.sem_type ~= "char") then
       1	    Error(string.format("'new var' expression must have type 'int' or 'char', but got type '%s'.", node.exp.sem_type), node.line)
        	  end
      59	  node.sem_type = node.type
     191	  node.sem_dimension = node.dimension + 1
        	end
        	
        	--VerifyNegate: Verify integrity of NEGATE node
        	--  Parameters:
        	--    [1] $table  = NEGATE node
        	--  Return:
     453	function Semantic.VerifyNegate (node)
     454	  if (_DEBUG) then print("SEM :: VerifyNegate") end
     483	  assert(node.id == nodes_codes["NEGATE"])
     405	  Semantic.VerifyExpression(node.exp)
      80	  if (node.exp.sem_type ~= "bool" or node.exp.sem_dimension ~= 0) then
      54	    Error(string.format("'not' must be done over type 'bool' with dimension '0', but got type '%s' with dimension '%d'.", node.exp.sem_type, node.exp.sem_dimension))
        	  end
     135	  node.sem_type = "bool"
      67	  node.sem_dimension = 0
        	end
        	
        	--VerifyOperator: Verify integrity of OPERATOR node
        	--  Parameters:
        	--    [1] $table  = NEGATE node
        	--  Return:
     173	function Semantic.VerifyOperator (node)
     243	  if (_DEBUG) then print("SEM :: VerifyOperator") end
      90	  assert(node.id == nodes_codes["OPERATOR"])
     159	  Semantic.VerifyExpression(node[1])
     136	  Semantic.VerifyExpression(node[2])
     373	  if (node.op == "and" or node.op == "or") then
        	
     179	    if (node[1].sem_type ~= "bool") then
      14	      Error(string.format("Operation '%s' cannot be made over type '%s'.", node.op, node[1].sem_type), node.line)
      28	    elseif (node[2].sem_type ~= "bool") then
      16	      Error(string.format("Operation '%s' cannot be made over type '%s'.", node.op, node[2].sem_type), node.line)
        	    end
        	
     192	    if (node[1].sem_dimension ~= 0) then
     186	      Error(string.format("Operation '%s' cannot be made over arrays values, but left side of expression has dimension '%d'.", node.op, node[1].sem_dimension), node.line)
     481	    elseif (node[2].sem_dimension ~= 0) then
     506	      Error(string.format("Operation '%s' cannot be made over arrays values, but right side of expression has dimension '%d'.", node.op, node[2].sem_dimension), node.line)
        	    end
        	
     530	    node.sem_type = "bool"
      90	    node.sem_dimension = 0
        	
     549	  elseif (node.op == "=" or node.op == "<>") then
        	
     348	    if (node[1].sem_type ~= node[2].sem_type) then
      77	      if ((node[1].sem_type ~= "int" and node[1].sem_type ~= "char") or (node[2].sem_type ~= "int" and node[2].sem_type ~= "char")) then
       7	        Error(string.format("Operation '%s' require 'int' or 'char' expressions on both sides, but got '%s' and '%s'.", node.op, node[1].sem_type, node[2].sem_type))
        	      end
        	    end
     140	    if (node[1].sem_dimension ~= node[2].sem_dimension) then
     164	      Error(string.format("Operation '%s' must have equal variables dimension, but got '%s' and '%s'.", node.op, node[1].sem_dimension, node[2].sem_dimension))
        	    end
     115	    node.sem_type = "bool"
     109	    node.sem_dimension = 0
        	
     102	  elseif (node.op == ">" or node.op == "<" or node.op == ">=" or node.op == "<=") then
        	
      38	    if ((node[1].sem_type ~= "int" and node[1].sem_type ~= "char") or (node[2].sem_type ~= "int" and node[2].sem_type ~= "char")) then
      85	      Error(string.format("Operation '%s' require 'int' or 'char' expressions on both sides, but got '%s' and '%s'.", node.op, node[1].sem_type, node[2].sem_type))
        	    end
      91	    if (node[1].sem_dimension ~= 0 or node[2].sem_dimension ~= 0) then
      36	      Error(string.format("Operation '%s' cannot be made over arrays values.", node.op))
        	    end
      36	    node.sem_type = "bool"
      76	    node.sem_dimension = 0
        	
      89	  elseif (node.op == "+" or node.op == "-" or node.op == "*" or node.op == "/") then
      63	    if ((node[1].sem_type ~= "int" and node[1].sem_type ~= "char") or (node[2].sem_type ~= "int" and node[2].sem_type ~= "char")) then
      13	      Error(string.format("Operation '%s' require 'int' or 'char' expressions on both sides, but got '%s' and '%s'.", node.op, node[1].sem_type, node[2].sem_type))
        	    end
      78	    if (node[1].sem_dimension ~= 0 or node[2].sem_dimension ~= 0) then
      12	      Error(string.format("Operation '%s' cannot be made over arrays values.", node.op))
        	    end
      27	    node.sem_type = "int"
      84	    node.sem_dimension = 0
        	
        	  else
     159	    Error("Unknown operation '%s'.", node.op)
        	  end
        	end
        	
        	--VerifyProgram: Verify integrity of PROGRAM node
        	--  Parameters:
        	--    [1] $table  = PROGRAM node
        	--  Return:
     432	function Semantic.VerifyProgram (t)
     390	  if (_DEBUG) then print("SEM :: VerifyProgram") end
     101	  assert(t.id == nodes_codes["PROGRAM"])
     134	  SymbolClass.AddScope()
     108	  Semantic.VerifyGlobals(t)
     141	  for _, node in ipairs(t) do
     219	    if (node.id == nodes_codes["DECLARE"]) then
        	      -- DO NOT VERIFY. SYMBOL ADDED IN GLOBALS
     122	    elseif (node.id == nodes_codes["FUNCTION"]) then
     121	      Semantic.VerifyFunction(node)
        	    else
*******0	      Error("unknown program node.")
        	    end
        	  end
      30	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyReturn: Verify integrity of RETURN node
        	--  Parameters:
        	--    [1] $table  = RETURN node
        	--  Return:
      65	function Semantic.VerifyReturn (node)
      79	  if (_DEBUG) then print("SEM :: VerifyReturn") end
     112	  assert(node.id == nodes_codes["RETURN"])
      94	  local symbol = SymbolClass.GetSymbol("@ret")
      60	  if (not symbol) then
      36	    Error(string.format("function with return 'void' must not attempt to call 'return'."), node.line)
      16	  elseif (node.exp) then
      22	    Semantic.VerifyExpression(node.exp)
      48	    Semantic.VerifyCompatibleTypes(node.line, symbol.type, symbol.dimension, node.exp.sem_type, node.exp.sem_dimension)
      58	  elseif (symbol.type) then
      40	    Error(string.format("function expected to return type '%s' but got 'nil'.", symbol.type), node.line)
        	  else
       2	    Error("unknown function return error.")
        	  end
        	end
        	
        	--VerifyUnary: Verify integrity of UNARY node
        	--  Parameters:
        	--    [1] $table  = UNARY node
        	--  Return:
     468	function Semantic.VerifyUnary (node)
     700	  if (_DEBUG) then print("SEM :: VerifyUnary") end
     790	  assert(node.id == nodes_codes["UNARY"])
     658	  Semantic.VerifyExpression(node.exp)
     289	  if ((node.exp.sem_type ~= "int" and node.exp.sem_type ~= "char") or node.exp.sem_dimension ~= 0) then
     175	    Error(string.format("'unary' must be done over type 'char' or 'int' with dimension '0', but got type '%s' with dimension '%d'.", node.exp.sem_type, node.exp.sem_dimension), node.line)
        	  end
     612	  node.sem_type = node.exp.sem_type
     423	  node.sem_dimension = node.exp.sem_dimension
        	end
        	
        	--VerifyValue: Verify integrity of VALUE node
        	--  Parameters:
        	--    [1] $table  = VALUE node
        	--  Return:
     146	function Semantic.VerifyValue (node)
     150	  if (_DEBUG) then print("SEM :: VerifyValue") end
      62	  assert(node.id == nodes_codes["VALUE"])
     190	  node.sem_type = node.type
     380	  node.sem_dimension = 0
        	end
        	
        	--VerifyVar: Verify integrity of VAR node
        	--  Parameters:
        	--    [1] $table  = VAR node
        	--  Return:
     282	function Semantic.VerifyVar (node)
     108	  if (_DEBUG) then print("SEM :: VerifyVar") end
     112	  assert(node.id == nodes_codes["VAR"])
     172	  local symbol = SymbolClass.GetSymbol(node.name)
     114	  if (not symbol) then
     121	    Error(string.format("symbol '%s' was not declared.", node.name), node.line)
        	  end
     140	  node.sem_type = symbol.type
     139	  if (symbol.dimension and symbol.dimension > 0) then
     141	    if (node.array) then
      70	      if (#node.array > symbol.dimension) then
     101	        Error(string.format("symbol '%s' dimension is '%d', but was called with dimension '%d'.", node.name, symbol.dimension, #node.array), node.line)
        	      end
      70	      for _, exp in ipairs(node.array) do
      53	        Semantic.VerifyExpression(exp)
      45	        if (exp.sem_type ~= "int" and exp.sem_type ~= "char") then
      20	          Error(string.format("symbol '%s' dimension must be an 'int' or 'char', but was called with dimension '%s'.", node.name, exp.sem_type), node.line)
        	        end
        	      end
        	    end
      38	    node.sem_dimension = symbol.dimension - #node.array
      76	  elseif (node.array and #node.array > 0) then
       6	    Error(string.format("symbol '%s' dimension is '0', but was called with dimension '%d'.", node.name, #node.array), node.line)
        	  else
      65	    node.sem_dimension = 0
        	  end
        	end
        	
        	--VerifyWhile: Verify integrity of WHILE node
        	--  Parameters:
        	--    [1] $table  = WHILE node
        	--  Return:
      70	function Semantic.VerifyWhile (node)
     223	  if (_DEBUG) then print("SEM :: VerifyWhile") end
     315	  assert(node.id == nodes_codes["WHILE"])
     425	  SymbolClass.AddScope()
     453	  Semantic.VerifyExpression(node.cond)
     548	  if (node.cond.sem_type ~= "bool" or node.cond.sem_dimension ~= 0) then
     478	    Error(string.format("While expects 'bool' expression with dimension '0', but got type '%s' with dimension '%d'.", node.cond.sem_type, node.cond.sem_dimension), node.line)
        	  end
     167	  Semantic.VerifyBlock(node.block)
      89	  SymbolClass.RemoveScope()
        	end
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Open:
        	--  parameters:
        	--    [1] $table   - table with AST tree nodes
        	--  return:
        	--    [1] $boolean - false if found any problem, true otherwise
        	--    [2] $string  - only when [1] is false, informing which error occurs
       4	function Semantic.Open (t)
      43	  if (_DEBUG) then print("SEM :: Open") end
      44	  assert(t and type(t) == "table")
      43	  SymbolClass.Clear()
      87	  local ok, msg = pcall(function () Semantic.VerifyProgram(t) end)
      44	  if (not ok) then
      33	    return false, msg
        	  end
      10	  if (printTree) then
*******0	    Semantic.Print(t)
        	  end
      11	  return true
        	end
        	
        	--Print: Print Abstract Semantic Tree with comprehensible format
        	--  parameters:
        	--  return:
       1	function Semantic.Print (t)
*******0	  PrintClass.Print(t)
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       1	return Semantic

==============================================================================
./src/symbol_table.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      14	require "lib/util"
      14	local NodesClass  = require "lib/node_codes"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      14	local SymbolTable = {}
        	
      14	local scopes = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
      14	local nodes_codes = NodesClass.GetNodesList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
      14	function Error ()
*******0	  error("Symbol error.", 0)
        	end
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--AddScope: Insert a new scope level
        	--  parameters:
        	--  return:
      14	function SymbolTable.AddScope ()
    1477	  if (_DEBUG) then print("SYB :: AddScope") end
    1477	  scopes[#scopes + 1] = {}
        	end
        	
        	--Clear: Remove all scopes
        	--  parameters:
        	--  return:
      14	function SymbolTable.Clear ()
     564	  if (_DEBUG) then print("SYB :: Clear") end
     564	  scopes = {}
        	end
        	
        	--GetCurrentScopeSymbol: Get symbol only if present in current scope
        	--  parameters:
        	--    [1] $string         - Symbol name
        	--  return:
        	--    [1] $table or $nil  - Copy of symbol structure if found, otherwise nil
     410	function SymbolTable.GetCurrentScopeSymbol (name)
    1138	  if (_DEBUG) then print("SYB :: GetCurrentScopeSymbol") end
     876	  local num_scope = #scopes
     521	  if (scopes[#scopes][name]) then
     157	    local symbol = util.TableCopy(scopes[#scopes][name])
     151	    symbol.name = name
     127	    return symbol
        	  end
     364	  return nil
        	end
        	
        	--GetSymbol: Get symbol if present in current or above scopes
        	--  parameters:
        	--    [1] $string         - Symbol name
        	--  return:
        	--    [1] $table or $nil  - Copy of symbol structure if found, otherwise nil
     811	function SymbolTable.GetSymbol (name)
    1873	  if (_DEBUG) then print("SYB :: GetSymbol") end
    1875	  local num_scope = #scopes
    3658	  while (num_scope > 0) do
    2672	    if (scopes[num_scope][name]) then
    1434	      local symbol = util.TableCopy(scopes[num_scope][name])
     887	      symbol.name = name
    1116	      return symbol
        	    end
    1840	    num_scope = num_scope - 1
        	  end
     731	  return nil
        	end
        	
        	--Print: Print symbol table
        	--  parameters:
        	--  return:
       9	function SymbolTable.Print ()
*******0	  if (_DEBUG) then print("SYB :: Print") end
*******0	  util.TablePrint(scopes)
        	end
        	
        	--RemoveScope: Remove current scope
        	--  parameters:
        	--  return:
       9	function SymbolTable.RemoveScope ()
     386	  if (_DEBUG) then print("SYB :: RemoveScope") end
     386	  scopes[#scopes] = nil
        	end
        	
        	--SetSymbol: Create a new symbol in current scope
        	--          function or var
        	--  parameters:
        	--    [1] $table  - 
        	--              id   = $number - 
        	--              name = $string - 
        	--              line = $number - 
        	--              func_params {
        	--                params        = $table  - 
        	--                ret_type      = $string - 
        	--                ret_dimension = $number - 
        	--              }
        	--              var_params {
        	--                type
        	--                dimension = $number - 
        	--              }
        	--  return:
     347	function SymbolTable.SetSymbol (t)
    1457	  if (_DEBUG) then print("SYB :: SetSymbol") end
    1618	  assert(t and type(t) == "table")
    1618	  assert(t.line and type(t.line) == "number")
    1457	  assert(t.name and type(t.name) == "string")
    1428	  local symbol = {}
    1265	  symbol.line = t.line
    1265	  symbol.name = t.name
    1265	  if (t.id == nodes_codes["FUNCTION"]) then
     660	    symbol.id = "function"
     660	    symbol.params = util.TableCopy(t.params)
     660	    symbol.ret_type = t.ret_type
     662	    symbol.ret_dimension = t.ret_dimension
     651	  elseif (t.id == nodes_codes["DECLARE"] or t.id == nodes_codes["PARAMETER"]) then
     651	    symbol.id = "variable"
     651	    symbol.type = t.type
     989	    symbol.dimension = t.dimension
        	  else
*******0	    Error()
        	  end
    1119	  scopes[#scopes] = scopes[#scopes] or {}
    1119	  scopes[#scopes][t.name] = symbol
        	  --util.TablePrint(scopes)
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       9	return SymbolTable

==============================================================================
./src/syntactic.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      14	local ParserClass 	= require "src/parser"
      14	local LanguageClass = require "src/grammar"
      14	local ASTClass		  = require "src/syntax_tree"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      14	local Syntactic = {}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--GetTree:
      14	function Syntactic.GetTree()
     564	  if (_DEBUG) then print("SYN :: GetTree") end
     564	  return ASTClass.GetTree()
        	end
        	
        	--Open:
        	--  parameters:
        	--    [1] $table   - table with tokens read in lexical
        	--  return:
        	--    [1] $boolean - false if found any problem, true otherwise
        	--    [2] $string  - only when [1] is false, informing which error occurs
      14	function Syntactic.Open (t)
     928	  if (_DEBUG) then print("SYN :: Open") end
     928	  assert(t and type(t) == "table")
     928	  ParserClass.Open(t)
     928	  local ok, msg = LanguageClass.Start(ParserClass.Advance, ParserClass.Peek, ParserClass.Peek2)
     928	  if (not ok) then
     364	  	return false, msg
        	  end
     564	  return true
        	end
        	
        	--PrintTree:
      14	function Syntactic.PrintTree()
*******0	  if (_DEBUG) then print("SYN :: PrintTree") end
*******0	  return ASTClass.Print()
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      14	return Syntactic

==============================================================================
./src/syntax_tree.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
      14	local printTree = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      14	require "lib/util"
      14	local NodesClass  = require "lib/node_codes"
       9	local PrintClass  = require "lib/util_tree"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
       9	local AbstractSyntaxTree = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
       9	local nodes_codes = NodesClass.GetNodesList()
        	
        	--  AST tree (structed nodes)
       9	local tree = {}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--GetTree:
       9	function AbstractSyntaxTree.GetTree ()
        	  --return util.TableCopy(tree)
     377	  return tree
        	end
        	
        	--NewAttributionNode:
        	--  {
        	--    id    = $number - ATTRIBUTION code
        	--    exp   = $table  - EXPRESSION node
        	--    line  = $number - line number
        	--    var   = $table  - VAR node
        	--  }
        	--  parameters:
        	--  return:
       9	function AbstractSyntaxTree.NewAttributionNode (var, expression)
     885	  if (_DEBUG) then print("AST :: NewAttributionNode") end
     885	  local node = {
     885	    id    = nodes_codes["ATTRIBUTION"],
     885	    exp   = expression,
     890	    line  = var.line,
     885	    var   = var,
       5	  }
     885	  return node
        	end
        	
        	--NewCallNode:
        	--  {
        	--    id    = $number - CALL code
        	--    line  = $number - line number
        	--    name  = $string - var name
        	--    exps  = $table  - list of EXPRESSION nodes
        	--  }
        	--  parameters:
        	--  return:
      14	function AbstractSyntaxTree.NewCallNode (line, name, expressions)
     180	  if (_DEBUG) then print("AST :: NewCallNode") end
     185	  local node = {
     180	    id   = nodes_codes["CALL"],
     180	    line = line,
     185	    name = name,
     180	    exps = expressions,
       5	  }
     180	  return node
        	end
        	
        	--NewDeclVarNode:
        	--  {
        	--    id        = $number - DECLARE code
        	--    line      = $number - line number
        	--    name      = $string - var name
        	--    dimension = $number - var dimension
        	--    type      = $string - [bool, char, int, string]
        	--  }
        	--  parameters:
        	--  return:
       9	function AbstractSyntaxTree.NewDeclVarNode (line, name, typebase, size)
     519	  if (_DEBUG) then print("AST :: NewDeclVarNode") end
     514	  local node = {
     514	    id        = nodes_codes["DECLARE"],
     514	    line      = line,
     514	    name      = name,
     519	    dimension = size,
     514	    type      = typebase,
       5	  }
     514	  return node
        	end
        	
        	--NewElseIfNode:
        	--  {
        	--    id    = $number - ELSEIF code
        	--    block = $table  - list of COMMANDS that will be executed if [cond] is true
        	--    cond  = $table  - EXPRESSION NODE, represents condition
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
      14	function AbstractSyntaxTree.NewElseIfNode (line, condition, block)
      72	  if (_DEBUG) then print("AST :: NewElseIfNode") end
      72	  local node = {
      72	    id          = nodes_codes["ELSEIF"],
      72	    block       = block,
      72	    cond        = condition,
      72	    line        = line,
        	  }
      72	  return node
        	end
        	
        	--NewFunctionNode:
        	--  {
        	--    id            = $number - FUNCTION code
        	--    block         = $table  - list of COMMANDS that will be executed
        	--    line          = $number - line number
        	--    name          = $string - var name
        	--    params        = $table  - list of PARAMETER nodes
        	--    ret_type      = $string - [bool, char, int, string], represents function return type
        	--    ret_dimension = $number - function return dimension
        	--  }
        	--  parameters:
        	--  return:
       9	function AbstractSyntaxTree.NewFunctionNode (line, name, parameters, return_type, return_size, block)
     576	  if (_DEBUG) then print("AST :: NewFunctionNode") end
     576	  local node = {
     576	    id            = nodes_codes["FUNCTION"],
     576	    line          = line,
     576	    name          = name,
     576	    params        = parameters,
     576	    ret_type      = return_type,
     576	    ret_dimension = return_size,
     576	    block         = block,
        	  }
     576	  return node
        	end
        	
        	--NewIfNode:
        	--  {
        	--    id      = $number - IF code
        	--    block   = $table  - list of COMMANDS that will be executed if [cond] is true
        	--    cond    = $table  - EXPRESSION NODE, represents condition
        	--    else    = $table  - list of COMMANDS that will be executed none conditions are true
        	--    elseif  = $table  - list of ELSEIF nodes
        	--    line    = $number - line number
        	--  }
        	--  parameters:
        	--  return:
       9	function AbstractSyntaxTree.NewIfNode (line, condition, block, elseif_node, else_block)
     162	  if (_DEBUG) then print("AST :: NewIfNode") end
     162	  local node = {
     162	    id          = nodes_codes["IF"],
     162	    block       = block,
     162	    cond        = condition,
     162	    ["else"]    = else_block,
     162	    ["elseif"]  = elseif_node,
     162	    line        = line,
        	  }
     162	  return node
        	end
        	
        	--NewNegateNode:
        	--  {
        	--    id    = $number - NEGATE code
        	--    exp   = $table  - EXPRESSION node
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
       9	function AbstractSyntaxTree.NewNegateNode (line, expression)
     104	  if (_DEBUG) then print("AST :: NewNegateNode") end
     104	  local node = {
     104	    id    = nodes_codes["NEGATE"],
     104	    exp   = expression,
     104	    line  = line,
        	  }
     104	  return node
        	end
        	
        	--NewNewVarNode:
        	--  {
        	--    id        = $number - NEWVAR code
        	--    dimension = $number - var dimension
        	--    exp       = $table  - EXPRESSION node
        	--    line      = $number - line number
        	--    type      = $string - [bool, char, int, string]
        	--  }
        	--  parameters:
        	--  return:
       9	function AbstractSyntaxTree.NewNewVarNode (line, expression, type, dimension)
      63	  if (_DEBUG) then print("AST :: NewNewVarNode") end
      63	  local node = {
      63	    id        = nodes_codes["NEWVAR"],
      63	    dimension = dimension,
      63	    exp       = expression,
      63	    line      = line,
      63	    type      = type,
        	  }
      63	  return node
        	end
        	
        	--NewOperatorNode:
        	--  {
        	--    id    = $number - OPERATOR code
        	--    line  = $number - line number
        	--    op    = $string - [and or + - * / > < >= <= = <>], one of possible operations
        	--    [1]   = $table  - EXPRESSION node, left side of operator
        	--    [2]   = $table  - EXPRESSION node, right side of operator
        	--  }
        	--  parameters:
        	--  return:
       9	function AbstractSyntaxTree.NewOperatorNode (line, left, operator, right)
     919	  if (_DEBUG) then print("AST :: NewOperatorNode") end
     924	  local node = {
    1363	    id    = nodes_codes["OPERATOR"],
    1363	    line  = line,
    1363	    op    = operator,
    1363	    left,
     444	    right,
    1363	  }
     919	  return node
        	end
        	
        	--NewParameterNode:
        	--  {
        	--    id        = $number - PARAMETER code
        	--    dimension = $number - var dimension
        	--    line      = $number - line number
        	--    name      = $string - var name
        	--    type      = $string - [bool, char, int, string]
        	--  }
        	--  parameters:
        	--  return:
      14	function AbstractSyntaxTree.NewParameterNode (line, name, typebase, size)
     356	  if (_DEBUG) then print("AST :: NewProgramNode") end
     356	  local node = {
     356	    id        = nodes_codes["PARAMETER"],
     356	    line      = line,
     356	    name      = name,
     356	    dimension = size,
     270	    type      = typebase,
      86	  }
     275	  return node
        	end
        	
        	--NewParenthesisNode:
        	--  {
        	--    id    = $number - PARENTHESIS code
        	--    exp   = $table  - EXPRESSION node
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
       9	function AbstractSyntaxTree.NewParenthesisNode (line, expression)
       5	  if (_DEBUG) then print("AST :: NewParenthesisNode") end
     224	  local node = {
     224	    id    = nodes_codes["PARENTHESIS"],
     224	    exp   = expression,
     224	    line  = line,
     224	  }
     224	  return node
        	end
        	
        	--NewProgramNode:
        	--  {
        	--    id       = $number - PROGRAM code
        	--    [1 to N] = DECLARE or FUNCTION node
        	--  }
        	--  parameters:
        	--  return:
       9	function AbstractSyntaxTree.NewProgramNode (ast_tree)
     377	  if (_DEBUG) then print("AST :: NewProgramNode") end
     377	  tree = {}
     377	  tree = util.TableCopy(ast_tree)
     377	  tree.id = nodes_codes["PROGRAM"]
     382	  if (printTree) then AbstractSyntaxTree.Print() end
        	end
        	
        	--NewReturnNode:
        	--  {
        	--    id    = $number - RETURN code
        	--    line  = $number - line number
        	--    exp   = $table  - EXPRESSION node
        	--  }
        	--  parameters:
        	--  return:
       9	function AbstractSyntaxTree.NewReturnNode (line, expression)
     171	  if (_DEBUG) then print("AST :: NewReturnNode") end
     171	  local node = {
     171	    id    = nodes_codes["RETURN"],
     171	    exp   = expression,
     171	    line  = line,
        	  }
     171	  return node
        	end
        	
        	--NewUnaryNode:
        	--  {
        	--    id    = $number - UNARY code
        	--    exp   = $table  - EXPRESSION node
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
     293	function AbstractSyntaxTree.NewUnaryNode (line, expression)
     351	  if (_DEBUG) then print("AST :: NewUnaryNode") end
     351	  local node = {
     351	    id    = nodes_codes["UNARY"],
      67	    exp   = expression,
     351	    line  = line,
       5	  }
      67	  return node
        	end
        	
        	--NewValueNode:
        	--  {
        	--    id    = $number   - VALUE code
        	--    line  = $number - line number
        	--    type  = $string   - [bool, char, int, string]
        	--    value = $string   - if type == char or string,
        	--            $number   - if type == int,
        	--            $boolean  - if type == bool,
        	--  }
        	--  parameters:
        	--  return:
      91	function AbstractSyntaxTree.NewValueNode (line, type, value)
    1345	  if (_DEBUG) then print("AST :: NewValueNode") end
    1345	  local node = {
    1345	    id    = nodes_codes["VALUE"],
    1345	    line  = line,
    1345	    type  = type,
    1345	    value = value,
        	  }
    1345	  return node
        	end
        	
        	--NewVarNode:
        	--  {
        	--    id    = $number - VAR code
        	--    array = $table  - list of EXPRESSIONS, one for each dimension
        	--    line  = $number - line number
        	--    name  = $string - var name
        	--  }
        	--  parameters:
        	--  return:
      62	function AbstractSyntaxTree.NewVarNode (line, name, array)
    2282	  if (_DEBUG) then print("AST :: NewVarNode") end
    2282	  local node = {
    2282	    id    = nodes_codes["VAR"],
    2282	    line  = line,
    2229	    name  = name,
    2282	    array = array,
       5	  }
    2229	  return node
        	end
        	
        	--NewWhileNode:
        	--  {
        	--    id    = $number - WHILE code
        	--    block = $table  - list of COMMANDS that will be executed if [cond] is true
        	--    cond  = $table  - EXPRESSION node, represents condition
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
      42	function AbstractSyntaxTree.NewWhileNode (line, condition, block)
      78	  if (_DEBUG) then print("AST :: NewWhileNode") end
      78	  local node = {
      78	    id    = nodes_codes["WHILE"],
      78	    block = block,
      78	    cond  = condition,
      78	    line  = line,
        	  }
      78	  return node
        	end
        	
        	--Print: Print Abstract Syntax Tree with comprehensible format
        	--  parameters:
        	--  return:
       9	function AbstractSyntaxTree.Print ()
*******0	  if (_DEBUG) then print("AST :: Print") end
*******0	  PrintClass.Print(tree)
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
     488	return AbstractSyntaxTree

==============================================================================
src/auto_test.lua
==============================================================================
        	--==============================================================================
        	-- Global Defines
        	--==============================================================================
        	
      14	_DEBUG = false
      13	local printFailMessage = true
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      14	require "lib/util"
      14	local Lexical   = require "src/lexical"
      14	local Syntactic = require "src/syntactic"
      13	local Semantic  = require "src/semantic"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      13	local files = {
       1	  {
      14	    name      = "nil_file",
      14	    open      = false,
      13	  },
       1	  {
      14	    name      = "lex_fail",
      14	    open      = true,
      14	    lexical   = false,
      14	  },
        	  {
      14	    name      = "lex_overload_01",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = false,
      14	  },
        	  {
      14	    name      = "lex_overload_02",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = false,
      14	  },
        	  {
      14	    name      = "lex_overload_03",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = false,
      14	  },
        	  {
      14	    name      = "lex_overload_04",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = false,
      14	  },
       1	  {
      13	    name      = "sem_complete_program",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = true,
      14	  },
       1	  {
      13	    name      = "sem_elseif_block",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = true,
      14	  },
       1	  {
      13	    name      = "sem_fail_attrib_string_char",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      13	    name      = "sem_fail_attrib_char_string",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      13	    name      = "sem_fail_attrib_int_bool",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      13	    name      = "sem_fail_call_not_function",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      13	    name      = "sem_fail_call_wrong_param_number",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      13	    name      = "sem_fail_declare_same_name_01",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      13	    name      = "sem_fail_declare_same_name_02",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  }, 
       1	  {
      13	    name      = "sem_fail_elseif_condition",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      13	    name      = "sem_fail_exp_negate_char",
      13	    open      = true,
      13	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      14	    name      = "sem_fail_exp_sum_bool",
      13	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      14	    name      = "sem_fail_exp_unary_bool",
      13	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      14	    name      = "sem_fail_func_ret_dimension_different",
      13	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      14	    name      = "sem_fail_func_ret_nil",
      13	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      14	    name      = "sem_fail_func_ret_type_different",
      13	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      14	    name      = "sem_fail_func_same_par_name",
      13	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      14	    name      = "sem_fail_func_void_return",
      13	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      13	    name      = "sem_fail_if_condition_int",
      12	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       2	  {
      12	    name      = "sem_fail_var_array_bool",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      14	  },
       1	  {
      13	    name      = "sem_fail_var_array_dimension_zero",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      13	  },
       2	  {
       7	    name      = "sem_fail_var_array_larger",
       8	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      13	  },
       8	  {
       7	    name      = "sem_fail_var_existent",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = false,
      13	  },
       8	  {
       6	    name      = "sem_fail_var_undeclared",
      13	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      13	    semantic  = false,
      14	  },
        	
        	
       9	  {
      14	    name      = "00-fail-empty",
      14	    open      = true,
      13	    lexical   = true,
      14	    syntactic = false,
      14	  },
       1	  {
      14	    name      = "01-global",
      14	    open      = true,
      13	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = true,
      14	  },
       1	  {
      14	    name      = "02-fun",
      14	    open      = true,
      13	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = true,
      13	  },
       2	  {
      14	    name      = "03-nls",
      14	    open      = true,
      13	    lexical   = true,
      14	    syntactic = true,
      13	    semantic  = false,
      14	  },
       2	  {
      14	    name      = "04-funglobal",
      13	    open      = true,
      14	    lexical   = true,
      13	    syntactic = true,
      14	    semantic  = true,
      14	  },
       2	  {
      14	    name      = "05-params",
      13	    open      = true,
      14	    lexical   = true,
      13	    syntactic = true,
      14	    semantic  = false,
       8	  },
       8	  {
      13	    name      = "06-declvar",
      14	    open      = true,
      14	    lexical   = true,
      13	    syntactic = true,
       8	    semantic  = false,
      14	  },
       8	  {
      13	    name      = "07-if",
      14	    open      = true,
      13	    lexical   = true,
       8	    syntactic = true,
      14	    semantic  = false,
      13	  },
       9	  {
      13	    name      = "08-fail-else",
      14	    open      = true,
      13	    lexical   = true,
       8	    syntactic = false,
      13	  },
       9	  {
      14	    name      = "09-fail-elseif",
      13	    open      = true,
      13	    lexical   = true,
      14	    syntactic = false,
       7	  },
       9	  {
      14	    name      = "10-fail-if",
      14	    open      = true,
      13	    lexical   = true,
      13	    syntactic = false,
       8	  },
       8	  {
      14	    name      = "11-ifdecl",
      14	    open      = true,
      13	    lexical   = true,
      14	    syntactic = true,
      13	    semantic  = false,
       8	  },
       8	  {
      14	    name      = "12-while",
      13	    open      = true,
      14	    lexical   = true,
      13	    syntactic = true,
       8	    semantic  = false,
      13	  },
       9	  {
      13	    name      = "13-fail-while",
      14	    open      = true,
      14	    lexical   = true,
      13	    syntactic = false,
       8	  },
       8	  {
      13	    name      = "14-ifwhile",
      14	    open      = true,
      14	    lexical   = true,
      13	    syntactic = true,
      14	    semantic  = true,
       7	  },
       8	  {
      14	    name      = "15-fail-ifwhile",
      14	    open      = true,
      14	    lexical   = true,
      13	    syntactic = false,
       8	  },
       7	  {
      14	    name      = "16-atrib",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
      13	    semantic  = true,
       7	  },
       8	  {
      14	    name      = "17-call",
      14	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
       6	    semantic  = true,
      13	  },
       9	  {
      14	    name      = "18-fail-call",
      14	    open      = true,
      14	    lexical   = true,
      13	    syntactic = false,
       7	  },
       8	  {
      14	    name      = "19-callargs",
      14	    open      = true,
      14	    lexical   = true,
      13	    syntactic = true,
      13	    semantic  = false,
       7	  },
       9	  {
      14	    name      = "19-fail-callargs",
      14	    open      = true,
      13	    lexical   = true,
      13	    syntactic = false,
      14	  },
       2	  {
      14	    name      = "20-return",
      14	    open      = true,
      13	    lexical   = true,
      13	    syntactic = true,
      14	    semantic  = true,
      14	  },
       2	  {
      14	    name      = "21-arrays",
      13	    open      = true,
      13	    lexical   = true,
      14	    syntactic = true,
      14	    semantic  = true,
       8	  },
       8	  {
      14	    name      = "21-return-noargs",
      12	    open      = true,
      14	    lexical   = true,
      14	    syntactic = true,
       8	    semantic  = false,
      14	  },
       8	  {
      12	    name      = "22-exp",
      14	    open      = true,
      14	    lexical   = true,
       8	    syntactic = true,
      14	    semantic  = false,
      13	  },
       7	  {
      14	    name      = "22-fail-exp",
      13	    open      = true,
       7	    lexical   = true,
      13	    syntactic = false,
      12	  },
       7	  {
      13	    name      = "23-fail-fun",
      13	    open      = true,
       8	    lexical   = true,
      14	    syntactic = false,
      70	  },
      64	  {
      13	    name      = "24-fail-fun2",
      71	    open      = true,
      64	    lexical   = true,
      70	    syntactic = false,
      69	  },
       7	  {
      13	    name      = "25-fail-fun3",
      13	    open      = true,
      64	    lexical   = true,
      70	    syntactic = false,
      69	  },
       7	  {
      13	    name      = "26-fail-fun4",
      70	    open      = true,
       7	    lexical   = true,
      13	    syntactic = false,
      69	  },
       8	  {
      13	    name      = "27-fail-global",
      69	    open      = true,
      63	    lexical   = true,
      13	    syntactic = false,
      12	  },
       7	  {
      13	    name      = "28-fail-block",
      13	    open      = true,
      64	    lexical   = true,
      69	    syntactic = false,
      68	  },
       8	  {
      12	    name      = "29-fail-params",
      69	    open      = true,
       7	    lexical   = true,
      13	    syntactic = false,
      68	  },
       8	  {
      12	    name      = "30-fail-param",
      13	    open      = true,
       7	    lexical   = true,
      13	    syntactic = false,
      12	  },
      65	  {
      68	    name      = "31-fail-type",
      69	    open      = true,
       6	    lexical   = true,
      12	    syntactic = false,
      67	  },
       7	  {
      12	    name      = "32-fail-declvar",
      68	    open      = true,
      38	    lexical   = true,
       7	    syntactic = false,
      12	  },
      73	  {
      77	    name      = "33-fail-missingexp",
      12	    open      = true,
     135	    lexical   = true,
     101	    syntactic = false,
     106	  },
      72	  {
      77	    name      = "34-fail-invalidexp",
      42	    open      = true,
      12	    lexical   = true,
       6	    syntactic = false,
     107	  },
      88	  {
      71	    name      = "35-expprio",
       6	    open      = true,
       6	    lexical   = true,
      71	    syntactic = true,
       6	    semantic  = false,
      62	  },
     129	  {
      13	    name      = "36-fail-roottoken",
     478	    open      = true,
     414	    lexical   = true,
      72	    syntactic = false,
     483	  },
     409	  {
     413	    name      = "37-invprio",
     413	    open      = true,
     413	    lexical   = true,
       5	    syntactic = true,
      72	    semantic  = false,
      65	  },
     477	}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	local function Run ()
     483	  local num_files = 0
      81	  local num_files_read = 1
     436	  for _, _ in pairs (files) do
     355	    num_files = num_files + 1
        	  end
     827	  for _, valid in ipairs (files) do
        	    local file_str                  --  keeps the convertion of file to string
     488	    local unexpected_error = false  --  inform that an unexpected error occurs (if true stop further tests)
     425	    local expected_error = false    --  inform that an expected error occurs (if true stop further tests)
        	    local ok, msg
        	
        	    -- TEST OPENING
        	    ------------------------------------------------
     820	    if (not unexpected_error and not expected_error) then
     451	      local f = io.open("data/" .. valid.name .. ".txt", "r")
     356	      if (not f and valid.open) then
     403	        unexpected_error = true
*******0	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to open.', num_files_read, num_files, valid.name))
     424	      elseif (f and not valid.open) then
     471	        unexpected_error = true
      71	        print(string.format('(%2s de %2s) FAILURE - File "%s" not expected to open.', num_files_read, num_files, valid.name))
     392	      elseif (not f and not valid.open) then
      42	        expected_error = true
       5	        msg = "file error: could not be opened."
        	      else
     457	        file_str = f:read("*a")
     827	        f:close()
        	      end
        	    end
        	    
        	    -- TEST LEXICAL
        	    ------------------------------------------------
     355	    if (not unexpected_error and not expected_error) then
     419	      ok, msg = Lexical.Open(file_str)
     747	      if (not ok and valid.lexical) then
     221	        unexpected_error = true
      65	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to PASS on lexical. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     415	      elseif (ok and not valid.lexical) then
      57	        unexpected_error = true
*******0	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to FAIL on lexical. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     420	      elseif (not ok and not valid.lexical) then
     546	        expected_error = true
        	      end
        	    end
        	    
        	    -- TEST SYNTAX
        	    ------------------------------------------------
     355	    if (not unexpected_error and not expected_error) then
     413	      ok, msg = Syntactic.Open(Lexical.GetTags())
     611	      if (not ok and valid.syntactic) then
     182	        unexpected_error = true
       1	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to PASS on syntactic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     345	      elseif (ok and not valid.syntactic) then
       1	        unexpected_error = true
*******0	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to FAIL on syntactic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     415	      elseif (not ok and not valid.syntactic) then
     580	        expected_error = true
        	      end
        	    end
        	    
        	    -- TEST SEMANTIC
        	    ------------------------------------------------
     763	    if (not unexpected_error and not expected_error) then
     257	      ok, msg = Semantic.Open(Syntactic.GetTree())
     259	      if (not ok and valid.semantic) then
       1	        unexpected_error = true
       1	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to PASS on semantic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     214	      elseif (ok and not valid.semantic) then
*******0	        unexpected_error = true
*******0	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to FAIL on semantic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     284	      elseif (not ok and not valid.semantic) then
     247	        expected_error = true
        	      end
        	    end
        	    
        	    -- PASSED ALL TESTS
        	    ------------------------------------------------
     355	    if (not unexpected_error or expected_error) then
     356	      print(string.format('(%2s de %2s) SUCCESS - File "%s".', num_files_read, num_files, valid.name))
     354	      if (expected_error and printFailMessage) then
      61	        print("        ", msg)
        	      end
        	    end
     355	    num_files_read = num_files_read + 1
        	  end
        	end
        	
        	
        	--==============================================================================
        	-- Running
        	--==============================================================================
        	
      10	local ok, msg = pcall(function () Run() end)
       5	if (not ok) then
*******0	  print("Erro inesperado no teste automático. " .. msg)
        	end

==============================================================================
Summary
==============================================================================

31	5	86.11%	./lib/lulex.lua
23	5	82.14%	./lib/node_codes.lua
51	1	98.08%	./lib/token_codes.lua
23	100	18.70%	./lib/util.lua
123	10	92.48%	./lib/util_tree.lua
346	10	97.19%	./src/grammar.lua
176	1	99.44%	./src/lexical.lua
18	0	100.00%	./src/parser.lua
271	4	98.55%	./src/semantic.lua
54	4	93.10%	./src/symbol_table.lua
17	2	89.47%	./src/syntactic.lua
158	2	98.75%	./src/syntax_tree.lua
522	6	98.86%	src/auto_test.lua
------------------------
1813	150	92.36%	
