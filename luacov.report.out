
==============================================================================
./lib/lulex.lua
==============================================================================
       	--==============================================================================
       	-- Dependency
       	--==============================================================================
       	
       	--==============================================================================
       	-- Data Structure
       	--==============================================================================
       	
      5	local Lulex = {}
       	
       	local rex_ok, rex
       	
     10	for _, flavor in ipairs{"gnu", "pcre", "tre", "posix", "oniguruma"} do
     10	   rex_ok, rex = pcall(require, "rex_"..flavor)
     10	   if rex_ok then
      5	      break
       	   end
       	end
       	
       	--==============================================================================
       	-- Private Methods
       	--==============================================================================
       	
       	local function Lua_match(rule, input, at)
       	   --if (_DEBUG) then print("Lul :: Lua_match") end
******0	   local match = string.match(input, "^"..rule[1], at)
******0	   if match then
******0	      return at + #match
       	   end
       	end
       	
       	local function Re_match(rule, input, at)
       	   --if (_DEBUG) then print("Lul :: Re_match") end
 622425	   if not rule.pat then
    215	      rule.pat = rex.new("^"..rule[1])
       	   end
 622425	   local start, finish = rule.pat:find(input:sub(at))
 622425	   if start then
  32062	      return at+(finish-start)+1
       	   end
       	end
       	
       	local function Run(self, input)
       	   --if (_DEBUG) then print("Lul :: Run") end
    321	   local at = 1
  14796	   while at <= #input do
  14475	      local lrule = nil
  14475	      local llen = 0
 636900	      for _, rule in ipairs(self.rules) do
 622425	         local found = self.match(rule, input, at)
 622425	         if found then
  32062	            local len = found - at
  32062	            if len > llen then
  14629	               llen = len
  14629	               lrule = rule
       	            end
       	         end
       	      end
  14475	      if lrule then
  14475	         lrule[2](input:sub(at, at+llen-1))
  14475	         at = at + llen
       	      else
******0	         io.write(input:sub(at, at))
******0	         at = at + 1
       	      end
       	   end
       	end
       	
       	
       	--==============================================================================
       	-- Public Methods
       	--==============================================================================
       	
      5	function Lulex.New(rules, use_lua)
       	   --if (_DEBUG) then print("Lul :: New") end
      5	   return {
      5	      match = (use_lua or not rex_ok) and Lua_match or Re_match,
      5	      rules = rules,
      5	      run = Run,
      5	   }
       	end
       	
       	
       	--==============================================================================
       	-- Return
       	--==============================================================================
       	
      5	return Lulex

==============================================================================
./lib/node_codes.lua
==============================================================================
       	--==============================================================================
       	-- Debug
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Dependency
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Data Structure
       	--==============================================================================
       	
      5	local Nodes = {}
       	
       	-- code of each node
       	--  {
       	--    ["node id"] = $number,
       	--  }
      5	local codes = {
      5	  ["ATTRIBUTION"] = 01,
      5	  ["CALL"]        = 02,
      5	  ["DECLARE"]     = 03,
      5	  ["ELSEIF"]      = 04,
      5	  ["FUNCTION"]    = 05,
      5	  ["IF"]          = 06,
      5	  ["NEGATE"]      = 07,
      5	  ["NEWVAR"]      = 08,
      5	  ["OPERATOR"]    = 09,
      5	  ["PARAMETER"]   = 10,
      5	  ["PARENTHESIS"] = 11,
      5	  ["PROGRAM"]     = 12,
      5	  ["RETURN"]      = 13,
      5	  ["UNARY"]       = 14,
      5	  ["VALUE"]       = 15,
      5	  ["VAR"]         = 16,
      5	  ["WHILE"]       = 17,
       	}
       	
       	
       	--==============================================================================
       	-- Public Methods
       	--==============================================================================
       	
      5	function Nodes.GetNodesList ()
     15	  return codes
       	end
       	
      5	function Nodes.GetNodeName (node_code)
******0	  assert(type(node_code) == "number")
******0	  for name, code in pairs(codes) do
******0	    if (code == node_code) then
******0	      return name
       	    end
       	  end
******0	  return nil
       	end
       	
       	
       	--==============================================================================
       	-- Private Methods
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Return
       	--==============================================================================
       	
      5	return Nodes

==============================================================================
./lib/token_codes.lua
==============================================================================
       	--==============================================================================
       	-- Debug
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Dependency
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Data Structure
       	--==============================================================================
       	
      5	local Tokens = {}
       	
       	-- code of each token
       	--  {
       	--    ["token id"] = $number,
       	--  }
      5	local codes = {
      5	  COMMENT_LINE  = 610,
      5	  COMMENT_BLOCK = 620,
      5	  K_IF          = 101,
      5	  K_THEN        = 102,
      5	  K_ELSE        = 103,
      5	  K_WHILE       = 104,
      5	  K_LOOP        = 105,
      5	  K_FUN         = 106,
      5	  K_RETURN      = 107,
      5	  K_NEW         = 108,
      5	  K_STRING      = 109,
      5	  K_INT         = 110,
      5	  K_CHAR        = 111,
      5	  K_BOOL        = 112,
      5	  K_TRUE        = 113,
      5	  K_FALSE       = 114,
      5	  K_AND         = 115,
      5	  K_OR          = 116,
      5	  K_NOT         = 117,
      5	  K_END         = 118,
      5	  STRING        = 200,
      5	  NUMBER        = 300,
      5	  ["OP_("]      = 401,
      5	  ["OP_)"]      = 402,
      5	  ["OP_,"]      = 403,
      5	  ["OP_:"]      = 404,
      5	  ["OP_>"]      = 405,
      5	  ["OP_<"]      = 406,
      5	  ["OP_>="]     = 407,
      5	  ["OP_<="]     = 408,
      5	  ["OP_="]      = 409,
      5	  ["OP_<>"]     = 410,
      5	  ["OP_["]      = 411,
      5	  ["OP_]"]      = 412,
      5	  ["OP_+"]      = 413,
      5	  ["OP_-"]      = 414,
      5	  ["OP_*"]      = 415,
      5	  ["OP_/"]      = 416,
      5	  LINE_END      = 500,
      5	  ID            = 800,
      5	  ERROR         = 000,
       	}
       	
       	
       	--==============================================================================
       	-- Public Methods
       	--==============================================================================
       	
      5	function Tokens.GetTokensList ()
     10	  return codes
       	end
       	
      5	function Tokens.GetTokenName (token_code)
    110	  assert(type(token_code) == "number")
   2900	  for name, code in pairs(codes) do
   2900	    if (code == token_code) then
    110	      return name
       	    end
       	  end
******0	  return nil
       	end
       	
       	
       	--==============================================================================
       	-- Private Methods
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Return
       	--==============================================================================
       	
      5	return Tokens

==============================================================================
./lib/util.lua
==============================================================================
       	--==============================================================================
       	-- Class Dependency
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Class Implementation
       	--==============================================================================
       	
      5	util = {}
       	
       	
       	--==============================================================================
       	-- Public Methods
       	--==============================================================================
       	
       	--FileExists()
       	--  parameters:
       	--    [1] $string  [file path and name including extension to be evaluated]
       	--  return:
       	--    [1] $boolean [true if file exists, false otherwise]
     10	function util.FileExists(file)
******0	  if (file == nil or type(file) ~= "string" or file == "") then
******0	    return false
       	  end
******0	  local f, msg = io.open(file, "r")
******0	  if (f == nil) then
******0	    return false
       	  end
******0	  f:close()
******0	  return true
       	end
       	
       	--FileToTable()
       	--  parameters:
       	--    [1] 
       	--  return:
       	--    [1] 
     10	function util.FileToTable(file)
******0	  if (file == nil or type(file) ~= "string" or file == "") then
******0	    return false, "Parameter 'file' is invalid"
       	  end
******0	  local f = io.open(file, "r")
******0	  if (f == nil) then
******0	    return false, "Could not open desired file"
       	  end
******0	  local t = FileToTableAux(f, {})
******0	  f:close()
******0	  if (t and type(t) == "table") then
******0	    return true, t
       	  end
******0	  return false, {}
       	end
       	
       	--StringIsNull()
       	--  parameters:
       	--    [1] $string  [string that is going to be evaluated]
       	--  return:
       	--    [1] $boolean [true if string is null]
     10	function util.StringIsNull(str)
******0	  return (str == nil or str == "")
       	end
       	
       	--TableCopy()
       	--  parameters:
       	--    [1] $table [table that is going to be duplicated]
       	--  return:
       	--    [1] $table [copy of incoming table]
     10	function util.TableCopy(t)
   6273	  if (not t or type(t) ~= "table") then
******0	    return
       	  end
   6273	  local ret = {}
   6273	  local mt = getmetatable(t)
   6273	  if mt then
******0	    setmetatable(ret, mt)
       	  end
  24973	  for k,v in pairs(t) do
  18700	    v = rawget(t, k)
  18700	    if type(v)== "table" then
   5468	      rawset(ret, k, util.TableCopy(v))
       	    else
  13232	      rawset(ret, k, v)
       	    end
       	  end
   6273	  return ret
       	end
       	
       	--TableGetChanges()
       	--  required:
       	--    [1] $table [old table]
       	--    [2] $table [new table]
       	--  return:
       	--    [1] $table [fields that have been modified from old_table to new_table]
     10	function util.TableGetChanges(old_table, new_table)
******0	  if not old_table or not new_table then 
******0	    return 
       	  end
******0	  local changes = {}
******0	  for k, v in pairs(old_table) do
******0	    if type(v) == "table" then
******0	      changes[k] = utils.GetTableChanges(v, new_table[k])
       	    else
******0	      if new_table[k] ~= nil and new_table[k] ~= v then
******0	        changes[k] = new_table[k]
       	      end
       	    end
       	  end
******0	  if next(changes) then
******0	    return changes
       	  end
       	end
       	
       	--TableIsEmpty()
       	--  parameters:
       	--    [1] $table   [table that is going to be valuated]
       	--  return:
       	--    [1] $boolean [true if table is empty, false otherwise]
     10	function util.TableIsEmpty (t)
******0	  assert(type(t) == "table")
******0	  for _, _ in pairs(t) do
******0	    return false
       	  end
******0	  return true
       	end
       	
       	--TablePrint()
       	--  parameters:
       	--    [1] $table [table that is going to be printed]
     10	function util.TablePrint (t)
******0	  if (not t) then
******0	    return
       	  end
******0	  print(TablePrintAux("", t, ""))
       	end
       	
       	--TableToFile()
       	--  parameters:
       	--    [1] $table  [table that is going to be printed]
       	--  return:
       	--    [1] $string [string of copied table]
     10	function util.TableToFile (file, t)
******0	  if (file == nil or type(file) ~= "string" or file == "") then
******0	    return false, "Parameter 'file' is invalid"
       	  end
******0	  local f = io.open(file, "w")
******0	  if (f == nil) then
******0	    return false, "Could not open desired file"
       	  end
******0	  if (not t) then
******0	    return
       	  end
******0	  TableToFileAux(f, "", t, "")
******0	  f:close()
******0	  return true
       	end
       	
       	--TableToString()
       	--  parameters:
       	--    [1] $table  [table that is going to be printed]
       	--  return:
       	--    [1] $string [string of copied table]
     10	function util.TableToString (t)
******0	  if (not t) then
******0	    return
       	  end
******0	  return TablePrintAux("", t, "")
       	end
       	
       	
       	--==============================================================================
       	-- Private Methods
       	--==============================================================================
       	
      5	function FileToTableAux(file, t)
******0	  local str = file:read()
******0	  while (str) do
******0	    if (string.find(str, '%["([^"]+)"%] = {')) then
******0	      local _, _, field = string.find(str, '%["([^"]+)"%] = {')
******0	      t[field] = FileToTableAux(file, {})
******0	    elseif (string.find(str, '%[([^%]]+)%] = {')) then
******0	      local _, _, n = string.find(str, '%[([^%]]+)%] = {')
******0	      n = tonumber(n)
******0	      t[n] = FileToTableAux(file, {})
******0	    elseif (string.find(str, '%["([^"]+)"%]%s%=%s"([^"]+)"')) then
******0	      local _, _, field, value = string.find(str, '%["([^"]+)"%]%s%=%s"([^"]+)"')
******0	      t[field] = value
******0	    elseif (string.find(str, '%[([^%]]+)%]%s%=%s"([^"]+)"')) then
******0	      local _, _, n, value = string.find(str, '%[([^%]]+)%]%s%=%s"([^"]+)"')
******0	      n = tonumber(n)
******0	      t[n] = value
******0	    elseif (string.find(str, "}")) then
******0	      return t
       	    end
******0	    str = file:read()
       	  end
       	end
       	
      5	function TablePrintAux (s, t, indent)
******0	  s = s .. "{\n"
******0	  local oldindent = indent
******0	  indent = indent .. "  "
******0	  for k, v in pairs(t) do
******0	    if (type(k) == "string") then
******0	      s = s .. indent .. "[" .. string.format("%q", k) .. "] = "
******0	    elseif (type(k) == "number") then
******0	      s = s .. indent .. "[" .. k .. "] = "
       	    end
******0	    if (type(v) == "table") then
******0	      s = TablePrintAux(s, v, indent)
******0	    elseif (type(v) == "string") then
******0	      s = s .. string.format("%q", v)
       	    else
******0	      s = s .. tostring(v)
       	    end
******0	    s = s .. ",\n"
       	  end
******0	  s = s .. oldindent .. "}"
******0	  return s
       	end
       	
      5	function TableToFileAux (file, s, t, indent)
******0	  file:write("{\n")
******0	  local oldindent = indent
******0	  indent = indent .. "  "
******0	  for k, v in pairs(t) do
******0	    if (type(k) == "string") then
******0	      file:write(indent .. "[" .. string.format("%q", k) .. "] = ")
******0	    elseif (type(k) == "number") then
******0	      file:write(indent .. "[" .. k .. "] = ")
       	    end
******0	    if (type(v) == "table") then
******0	      s = TableToFileAux(file, s, v, indent)
******0	    elseif (type(v) == "string") then
******0	      file:write(string.format("%q", v))
       	    else
******0	      file:write(tostring(v))
       	    end
******0	    file:write(",\n")
       	  end
******0	  file:write(oldindent .. "}")
       	end
       	
       	
       	--==============================================================================
       	-- Return
       	--==============================================================================
       	

==============================================================================
./src/grammar.lua
==============================================================================
       	--==============================================================================
       	-- Debug
       	--==============================================================================
       	
      5	local printTokensMatch = false
       	
       	
       	--==============================================================================
       	-- Dependency
       	--==============================================================================
       	
      5	local TokensClass = require "lib/token_codes"
      5	local ASTClass    = require "src/syntax_tree"
       	
       	
       	--==============================================================================
       	-- Data Structure
       	--==============================================================================
       	
      5	local Language = {}
       	
       	-- Stores Parser Functions
       	--  {
       	--    $name = $function
       	--  }
      5	local Parser = {}
       	
       	-- Stores Grammar Functions
       	--  {
       	--    $name = $function
       	--  }
      5	local Grammar = {}
       	
       	--  list of tokens
       	--  {
       	--    [name] = $number,
       	--  }
      5	local tokens = TokensClass.GetTokensList()
       	
       	
       	--==============================================================================
       	-- Private Methods
       	--==============================================================================
       	
       	--Error: Callback of errors that occurs during syntax analysis
       	--  Parameters:
       	--    [1] $number - line number of grammar syntax error
       	--  Return:
       	local function Error (line)
     74	  error("Syntax error at line " .. line .. ".", 0)
       	end
       	
       	--Match: Receives a token code number and compare with next avaiable token received from lexical
       	--  Parameters:
       	--    [1] $number - Next expected token code number
       	--  Return:
       	--    [1] $string - Token value/name
       	--    [2] $number - Token line number
       	local function Match (code)
   9432	  if (_DEBUG) then print("LAN :: Match") end
   9432	  local token = Parser.Peek()
   9432	  if (token and token.code == code) then
   9377	    if (_DEBUG or printTokensMatch) then
******0	      print(string.format("    Match code '%10s' %s", TokensClass.GetTokenName(code), token.token))
       	    end
   9377	    Parser.Advance()
   9377	    return token.token, token.line
       	  else
     55	    if (token) then
     55	      error("Expected " .. TokensClass.GetTokenName(code) .. " got " .. TokensClass.GetTokenName(token.code) .. " at line " .. token.line, 0)
       	    else
******0	      error("Expected " .. TokensClass.GetTokenName(code) .. " got end of tokens.", 0)
       	    end
       	  end
       	end
       	
       	
       	--==============================================================================
       	-- Initialize
       	--==============================================================================
       	
       	--Block:
       	--  syntax:
       	--    bloco     → { declvar nl }
       	--                { comando nl }
       	--  parameters:
       	--  return:
       	--    [1] $table  - List of DECLARE, [...] nodes
      5	function Grammar.Block ()
    547	  if (_DEBUG) then print("LAN :: Grammar_bloco") end
    547	  local list = {}
******0	  while (true) do
    700	    local token = Parser.Peek()
    700	    local token2 = Parser.Peek2()
    700	    if (token and token2 and token.code == tokens.ID and token2.code == tokens["OP_:"]) then
    158	      table.insert(list, Grammar.DeclareVar())
    158	      Grammar.LineEnd()
       	    else
       	      break
       	    end
       	  end
******0	  while (true) do
   1239	    local token = Parser.Peek()
   1239	    if (token and
   1239	        token.code == tokens.ID or
    714	        token.code == tokens.K_IF or
    592	        token.code == tokens.K_WHILE or
    561	        token.code == tokens.K_RETURN) then
    762	      table.insert(list, Grammar.Command() or {}) -- RETIRAR OPCAO {}
    697	      Grammar.LineEnd()
       	    else
       	      break
       	    end
       	  end
    477	  return list
       	end
       	
       	--Call:
       	--  syntax:
       	--    chamada   → ID '(' listaexp ')'
       	--  parameters:
       	--  return:
       	--    [1] $table  - CALL node
      5	function Grammar.Call ()
     91	  if (_DEBUG) then print("LAN :: Grammar_chamada") end
       	  local name, line, exps
     91	  name, line = Match(tokens.ID)
     91	  Match(tokens["OP_("])
     91	  exps = Grammar.ListExpressions()
     86	  Match(tokens["OP_)"])
     86	  return ASTClass.NewCallNode(line, name, exps)
       	end
       	
       	--CmdAttrib:
       	--  syntax:
       	--    cmdatrib  → var '=' exp
       	--  parameters:
       	--  return:
       	--    [1] $table  - ATTRIBUTION node
      5	function Grammar.CmdAttrib ()
    449	  if (_DEBUG) then print("LAN :: Grammar_cmdatrib") end
       	  local var, expression
    449	  var = Grammar.Var()
    449	  Match(tokens["OP_="])
    444	  expression = Grammar.Expression()
    444	  return ASTClass.NewAttributionNode(var, expression)
       	end
       	
       	--CmdIf:
       	--  syntax:
       	--    cmdif     → 'if' exp nl
       	--                    bloco
       	--                { 'else' 'if' exp nl
       	--                    bloco
       	--                }
       	--                [ 'else' nl
       	--                    bloco
       	--                ]
       	--                'end'
      5	function Grammar.CmdIf ()
    122	  if (_DEBUG) then print("LAN :: Grammar_cmdif") end
       	  local line, condition, block, else_block
    122	  local elseif_nodes = {}
    122	  _, line = Match(tokens.K_IF)
    122	  condition = Grammar.Expression()
    102	  Grammar.LineEnd()
     97	  block = Grammar.Block()
******0	  while (true) do
    128	    local token = Parser.Peek()
    128	    local token2 = Parser.Peek2()
    128	    if (token and token2 and token.code == tokens.K_ELSE and token2.code == tokens.K_IF) then
       	      local line, condition, block
     46	      _, line = Match(tokens.K_ELSE)
     46	      Match(tokens.K_IF)
     46	      condition = Grammar.Expression()
     36	      Grammar.LineEnd()
     36	      block = Grammar.Block()
     36	      table.insert(elseif_nodes, ASTClass.NewElseIfNode(line, condition, block))
       	    else
       	      break
       	    end
       	  end
     82	  local token = Parser.Peek()
     82	  if (token and token.code == tokens.K_ELSE) then
     39	    Match(tokens.K_ELSE)
     39	    Grammar.LineEnd()
     39	    else_block = Grammar.Block()
       	  end
     82	  Match(tokens.K_END)
     82	  return ASTClass.NewIfNode(line, condition, block, elseif_nodes, else_block)
       	end
       	
       	--CmdReturn:
       	--  syntax:
       	--    cmdreturn → 'return' exp | 'return'
       	--  parameters:
       	--  return:
       	--    [1] $table  - RETURN node
      5	function Grammar.CmdReturn ()
     84	  if (_DEBUG) then print("LAN :: Grammar_cmdreturn") end
       	  local line, exp
     84	  _, line = Match(tokens.K_RETURN)
     84	  local token = Parser.Peek()
     84	  if (token and token.code ~= tokens.LINE_END) then
     71	    exp = Grammar.Expression()
       	  end
     84	  return ASTClass.NewReturnNode(line, exp)
       	end
       	
       	--CmdWhile:
       	--  syntax:
       	--    cmdwhile  → 'while' exp nl
       	--                    bloco
       	--                'loop'
       	--  parameters:
       	--  return:
       	--    [1] $table  - WHILE node
      5	function Grammar.CmdWhile ()
     31	  if (_DEBUG) then print("LAN :: Grammar_cmdwhile") end
       	  local line, exp, block
     31	  _, line = Match(tokens.K_WHILE)
     31	  exp = Grammar.Expression()
     31	  Grammar.LineEnd()
     31	  block = Grammar.Block()
     26	  Match(tokens.K_LOOP)
     21	  return ASTClass.NewWhileNode(line, exp, block)
       	end
       	
       	--Command:
       	--  syntax:
       	--    comando   → cmdif | cmdwhile | cmdatrib | cmdreturn | chamada
       	--  parameters:
       	--  return:
       	--    [1] $table - List of DECLARE, CMDATRIB, CMDIF, CMDRETURN, CMDWHILE, [...] nodes
      5	function Grammar.Command ()
    762	  if (_DEBUG) then print("LAN :: Grammar_comando") end
    762	  local token = Parser.Peek()
    762	  if (token and token.code == tokens.K_IF) then
    122	    return Grammar.CmdIf()
    640	  elseif (token and token.code == tokens.K_WHILE) then
     31	    return Grammar.CmdWhile()
    609	  elseif (token and token.code == tokens.K_RETURN) then
     84	    return Grammar.CmdReturn()
    525	  elseif (token and token.code == tokens.ID) then
    525	    local token2 = Parser.Peek2()
    525	    if (token2 and token2.code == tokens["OP_("]) then
     71	      return Grammar.Call()
    454	    elseif (token2 and 
    454	            token2.code == tokens["OP_="] or
     42	            token2.code == tokens["OP_["]) then
    449	      return Grammar.CmdAttrib()
       	    else
      5	      Error(token.line or nil)
       	    end
       	  else
******0	    Error(token.line or nil)
       	  end
       	end
       	
       	--Declare:
       	--  syntax:
       	--    decl      → funcao | global
       	--  parameters:
       	--  return:
       	--    [1] $table  - DECLARE or FUNCTION node
      5	function Grammar.Declare ()
    450	  if (_DEBUG) then print("LAN :: Grammar_decl") end
       	  local decl
    450	  local token = Parser.Peek()
    450	  if (token and token.code == tokens.K_FUN) then
    369	    decl = Grammar.Function(parent_node)
     81	  elseif (token and token.code == tokens.ID) then
     81	    decl = Grammar.Global(parent_node)
       	  else
******0	    Error(token.line or nil)
       	  end
    345	  return decl
       	end
       	
       	--DeclareVar:
       	--  syntax:
       	--    declvar   → ID ':' tipo
       	--  parameters:
       	--  return:
       	--    [1] $table  - DECLARE node
      5	function Grammar.DeclareVar ()
    239	  if (_DEBUG) then print("LAN :: Grammar_declvar") end
       	  local name, line, typebase, array
    239	  name, line = Match(tokens.ID)
    239	  Match(tokens["OP_:"])
    234	  typebase, array = Grammar.Type()
    224	  return ASTClass.NewDeclVarNode(line, name, typebase, array)
       	end
       	
       	--Expression:
       	--  syntax:
       	--    exp       → LITNUMERAL
       	--              | LITSTRING
       	--              | TRUE
       	--              | FALSE
       	--              | var
       	--              | 'new' '[' exp ']' tipo
       	--              | '(' exp ')'
       	--              | chamada
       	--              | exp '+' exp
       	--              | exp '-' exp
       	--              | exp '*' exp
       	--              | exp '/' exp
       	--              | exp '>' exp
       	--              | exp '<' exp
       	--              | exp '>=' exp
       	--              | exp '<=' exp
       	--              | exp '=' exp
       	--              | exp '<>' exp
       	--              | exp 'and' exp
       	--              | exp 'or' exp
       	--              | 'not' exp
       	--              | '-' exp
      5	function Grammar.Expression ()
    975	  if (_DEBUG) then print("LAN :: Grammar_exp") end
    975	  local exp = Grammar.ExpressionLevel1()
    935	  if (not exp) then
    166	    Error(0)
       	  end
    769	  return exp
       	end
       	
      5	function Grammar.ExpressionLevel1 ()
   1005	  local left = Grammar.ExpressionLevel2()
    965	  local token = Parser.Peek()
    965	  if (token and token.code == tokens.K_OR) then
     30	    Match(tokens.K_OR)
     30	    return ASTClass.NewOperatorNode(token.line, left, "or", Grammar.ExpressionLevel1())
       	  end
    935	  return left
       	end
       	
      5	function Grammar.ExpressionLevel2 ()
   1055	  local left = Grammar.ExpressionLevel3()
   1015	  local token = Parser.Peek()
   1015	  if (token and token.code == tokens.K_AND) then
     50	    Match(tokens.K_AND)
     50	    return ASTClass.NewOperatorNode(token.line, left, "and", Grammar.ExpressionLevel2())
       	  end
    965	  return left
       	end
       	
      5	function Grammar.ExpressionLevel3 ()
   1189	  local left = Grammar.ExpressionLevel4()
   1149	  local token = Parser.Peek()
   1149	  if (token and token.code == tokens["OP_="]) then
    101	    Match(tokens["OP_="])
    101	    return ASTClass.NewOperatorNode(token.line, left, "=", Grammar.ExpressionLevel3())
   1048	  elseif (token and token.code == tokens["OP_<>"]) then
     33	    Match(tokens["OP_<>"])
     33	    return ASTClass.NewOperatorNode(token.line, left, "<>", Grammar.ExpressionLevel3())
       	  end
   1015	  return left
       	end
       	
      5	function Grammar.ExpressionLevel4 ()
   1305	  local left = Grammar.ExpressionLevel5()
   1265	  local token = Parser.Peek()
   1265	  if (token and token.code == tokens["OP_>"]) then
     31	    Match(tokens["OP_>"])
     31	    return ASTClass.NewOperatorNode(token.line, left, ">", Grammar.ExpressionLevel4())
   1234	  elseif (token and token.code == tokens["OP_<"]) then
     60	    Match(tokens["OP_<"])
     60	    return ASTClass.NewOperatorNode(token.line, left, "<", Grammar.ExpressionLevel4())
   1174	  elseif (token and token.code == tokens["OP_>="]) then
      5	    Match(tokens["OP_>="])
      5	    return ASTClass.NewOperatorNode(token.line, left, ">=", Grammar.ExpressionLevel4())
   1169	  elseif (token and token.code == tokens["OP_<="]) then
     20	    Match(tokens["OP_<="])
     20	    return ASTClass.NewOperatorNode(token.line, left, "<=", Grammar.ExpressionLevel4())
       	  end
   1149	  return left
       	end
       	
      5	function Grammar.ExpressionLevel5 ()
   1422	  local left = Grammar.ExpressionLevel6()
   1382	  local token = Parser.Peek()
   1382	  if (token and token.code == tokens["OP_+"]) then
     95	    Match(tokens["OP_+"])
     95	    return ASTClass.NewOperatorNode(token.line, left, "+", Grammar.ExpressionLevel5())
   1287	  elseif (token and token.code == tokens["OP_-"]) then
     22	    Match(tokens["OP_-"])
     22	    return ASTClass.NewOperatorNode(token.line, left, "-", Grammar.ExpressionLevel5())
       	  end
   1265	  return left
       	end
       	
      5	function Grammar.ExpressionLevel6 ()
   1479	  local left = Grammar.ExpressionLevel7()
   1439	  local token = Parser.Peek()
   1439	  if (token and token.code == tokens["OP_*"]) then
     41	    Match(tokens["OP_*"])
     41	    return ASTClass.NewOperatorNode(token.line, left, "*", Grammar.ExpressionLevel6())
   1398	  elseif (token and token.code == tokens["OP_/"]) then
     16	    Match(tokens["OP_/"])
     16	    return ASTClass.NewOperatorNode(token.line, left, "/", Grammar.ExpressionLevel6())
       	  end
   1382	  return left
       	end
       	
      5	function Grammar.ExpressionLevel7 ()
   1562	  local token = Parser.Peek()
   1562	  if (token and token.code == tokens.NUMBER) then
    524	    return ASTClass.NewValueNode(token.line, "int", Match(tokens.NUMBER))
   1038	  elseif (token and token.code == tokens.STRING) then
     30	    return ASTClass.NewValueNode(token.line, "string", Match(tokens.STRING))
   1008	  elseif (token and token.code == tokens.K_TRUE) then
     41	    return ASTClass.NewValueNode(token.line, "bool", Match(tokens.K_TRUE))
    967	  elseif (token and token.code == tokens.K_FALSE) then
     30	    return ASTClass.NewValueNode(token.line, "bool", Match(tokens.K_FALSE))
    937	  elseif (token and token.code == tokens.K_NEW) then
     33	    Match(tokens.K_NEW)
     33	    Match(tokens["OP_["])
     33	    local exp = Grammar.Expression()
     33	    Match(tokens["OP_]"])
     33	    local typebase, dimension = Grammar.Type()
     33	    return ASTClass.NewNewVarNode(token.line, exp, typebase, dimension)
    904	  elseif (token and token.code == tokens.K_NOT) then
     53	    Match(tokens.K_NOT)
     53	    local exp = Grammar.ExpressionLevel7()
     53	    return ASTClass.NewNegateNode(token.line, exp)
    851	  elseif (token and token.code == tokens.ID) then
       	    local node
    716	    local token2 = Parser.Peek2()
    716	    if (token2 and token2.code == tokens["OP_("]) then
     20	      return Grammar.Call()
       	    else
    696	      return Grammar.Var()
       	    end
    135	  elseif (token and token.code == tokens["OP_("]) then
     70	    Match(tokens["OP_("])
     70	    local exp = Grammar.Expression()
     65	    Match(tokens["OP_)"])
     65	    return exp
     65	  elseif (token and token.code == tokens["OP_-"]) then
     30	    Match(tokens["OP_-"])
     30	    return ASTClass.NewUnaryNode(token.line, Grammar.ExpressionLevel7())
       	  else
     35	    Error(token.line or nil)
       	  end
       	end
       	
       	--Function:
       	--  syntax:
       	--    funcao    → 'fun' ID '(' params ')' [ ':' tipo ] nl
       	--                    bloco
       	--                'end' nl
       	--  parameters:
       	--  return:
       	--    [1] $table  - FUNCTION node
      5	function Grammar.Function ()
    369	  if (_DEBUG) then print("LAN :: Grammar_funcao") end
       	  local name, line, params, ret_type, array_size, block
    369	  Match(tokens.K_FUN)
    369	  name, line = Match(tokens.ID)
    359	  Match(tokens["OP_("])
    359	  params = Grammar.Parameters()
    344	  Match(tokens["OP_)"])
    344	  local token = Parser.Peek()
    344	  if (token and token.code == tokens["OP_:"]) then
    133	    Match(tokens["OP_:"])
    133	    ret_type, array_size = Grammar.Type()
       	  end
    344	  Grammar.LineEnd()
    344	  block = Grammar.Block()
    284	  Match(tokens.K_END)
    284	  Grammar.LineEnd()
    284	  return ASTClass.NewFunctionNode(line, name, params, ret_type, array_size, block)
       	end
       	
       	--Global:
       	--  syntax:
       	--    global    → declvar nl
       	--  parameters:
       	--  return:
       	--    [1] $table  - DECLARE node
      5	function Grammar.Global ()
     81	  if (_DEBUG) then print("LAN :: Grammar_global") end
     81	  local node = Grammar.DeclareVar()
     66	  Grammar.LineEnd()
     61	  return node
       	end
       	
       	--ListExpressions:
       	--  syntax:
       	--    listaexp  → /*vazio*/ | exp { ',' exp }
       	--  parameters:
       	--  return:
       	--    [1] $table  - List of EXPRESSION nodes
      5	function Grammar.ListExpressions ()
     91	  if (_DEBUG) then print("LAN :: Grammar_listaexp") end
     91	  local list = {}
     91	  local token = Parser.Peek()
     91	  if (token and token.code ~= tokens["OP_)"]) then
     72	    table.insert(list, Grammar.Expression())
******0	    while (true) do
    105	      token = Parser.Peek()
    105	      if (token and token.code == tokens["OP_,"]) then
     38	        Match(tokens["OP_,"])
     38	        table.insert(list, Grammar.Expression())
       	      else
       	        break
       	      end
       	    end
       	  end
     86	  return list
       	end
       	
       	--LineEnd:
       	--  syntax:
       	--    nl        → NL { NL }
      5	function Grammar.LineEnd()
   2028	  if (_DEBUG) then print("LAN :: Grammar_nl") end
   2028	  Match(tokens.LINE_END)
******0	  while (true) do
   2028	    local token = Parser.Peek()
   2028	    if (token and token.code == tokens.LINE_END) then
     15	      Match(tokens.LINE_END)
       	    else
       	      break
       	    end
       	  end
       	end
       	
       	--Parameter:
       	--  syntax:
       	--    parametro → ID ':' tipo
       	--  parameters:
       	--  return:
       	--    [1] $table  - PARAMETER node
      5	function Grammar.Parameter ()
    151	  if (_DEBUG) then print("LAN :: Grammar_parametro") end
       	  local name, line, typebase, array_size
    151	  name, line = Match(tokens.ID)
    141	  Match(tokens["OP_:"])
    136	  typebase, array_size = Grammar.Type()
    136	  return ASTClass.NewParameterNode(line, name, typebase, array_size)
       	end
       	
       	--Parameters:
       	--  syntax:
       	--    params    → /*vazio*/ | parametro { ',' parametro }
       	--  parameters:
       	--  return:
       	--    [1] $table  - List of PARAMETER nodes
      5	function Grammar.Parameters ()
    359	  if (_DEBUG) then print("LAN :: Grammar_params") end
    359	  local list = {}
    359	  local token = Parser.Peek()
    359	  if (token and token.code ~= tokens["OP_)"]) then
    106	    table.insert(list, Grammar.Parameter())
******0	    while (true) do
    136	      token = Parser.Peek()
    136	      if (token and token.code == tokens["OP_,"]) then
     45	        Match(tokens["OP_,"])
     45	        table.insert(list, Grammar.Parameter())
       	      else
       	        break
       	      end
       	    end
       	  end
    344	  return list
       	end
       	
       	--Program:
       	--  syntax:
       	--    programa  → { NL } decl { decl }
      5	function Grammar.Program ()
    317	  if (_DEBUG) then print("LAN :: Grammar_programa") end
    317	  local node = {}
    317	  local token = Parser.Peek()
    317	  if (token and token.code == tokens.LINE_END) then
    271	    Grammar.LineEnd()
       	  end
    317	  token = Parser.Peek()
    317	  if (token and (token.code == tokens.K_FUN or token.code == tokens.ID)) then
    296	    table.insert(node, Grammar.Declare())
     14	    while (true) do
    343	      token = Parser.Peek()
    292	      if (token) then
    188	        table.insert(node, Grammar.Declare())
       	      else
     23	        break
       	      end
       	    end
       	  else
     20	    Error(token and token.line or 0)
       	  end
    161	  ASTClass.NewProgramNode(node)
       	end
       	
       	--Type:
       	--  syntax:
       	--    tipo      → tipobase | '[' ']' tipo
       	--  parameters:
       	--  return:
       	--    [1] $typebase
       	--    [2] $array_size
      4	function Grammar.Type (array_size)
    570	  if (_DEBUG) then print("LAN :: Grammar_tipo") end
    571	  array_size = array_size or 0
       	  local typebase
    672	  local token = Parser.Peek()
    672	  if (token and
    672	      token.code == tokens.K_INT or
    348	      token.code == tokens.K_BOOL or
    277	      token.code == tokens.K_CHAR or
    175	      token.code == tokens.K_STRING) then
    462	    typebase = Grammar.Typebase()
    147	  elseif (token and token.code == tokens["OP_["]) then
    206	    Match(tokens["OP_["])
    138	    Match(tokens["OP_]"])
    136	    array_size = array_size + 1
    136	    typebase, array_size = Grammar.Type(array_size)
       	  else
     23	    Error(token.line or nil)
       	  end
    564	  return typebase, array_size
       	end
       	
       	--Typebase:
       	--  syntax:
       	--    tipobase  → 'int' | 'bool' | 'char' | 'string'
       	--  parameters:
       	--  return:
       	--    [1] $typebase
      4	function Grammar.Typebase ()
    441	  if (_DEBUG) then print("LAN :: Grammar_tipobase") end
    442	  local token = Parser.Peek()
    526	  if (token and token.code == tokens.K_INT) then
    409	    Match(tokens.K_INT)
    409	    return "int"
    185	  elseif (token and token.code == tokens.K_BOOL) then
    139	    Match(tokens.K_BOOL)
     88	    return "bool"
     59	  elseif (token and token.code == tokens.K_CHAR) then
     47	    Match(tokens.K_CHAR)
     38	    return "char"
     15	  elseif (token and token.code == tokens.K_STRING) then
     15	    Match(tokens.K_STRING)
     13	    return "string"
       	  else
      1	    Error(token.line or nil)
       	  end
       	end
       	
       	--Var:
       	--  syntax:
       	--    var       → ID | var '[' exp ']'
       	--  parameters:
       	--  return:
       	--    [1] $table - VAR node
      4	function Grammar.Var ()
    929	  if (_DEBUG) then print("LAN :: Grammar_var") end
       	  local name, line
   1145	  local array = {}
   1145	  name, line = Match(tokens.ID)
    216	  while (true) do
   1185	    local token = Parser.Peek()
    969	    if (token and token.code == tokens["OP_["]) then
    264	      Match(tokens["OP_["])
    264	      table.insert(array, Grammar.Expression())
     48	      Match(tokens["OP_]"])
       	    else
      8	      break
       	    end
       	  end
    929	  return ASTClass.NewVarNode(line, name, array)
       	end
       	
       	
       	--==============================================================================
       	-- Public Methods
       	--==============================================================================
       	
      4	function Language.Start (func_advance, func_peek, func_peek2)
    261	  if (_DEBUG) then print("LAN :: Start") end
    262	  assert(type(func_advance) == "function")
    317	  assert(type(func_peek) == "function")
    317	  assert(type(func_peek2) == "function")
    317	  Parser.Advance = func_advance
    317	  Parser.Peek = func_peek
    317	  Parser.Peek2 = func_peek2
    578	  local ok, msg = pcall(function () Grammar.Program() end)
    317	  if (not ok) then
    216	    return false, msg
       	  end
    183	  return true
       	end
       	
       	
       	--==============================================================================
       	-- Return
       	--==============================================================================
       	
      4	return Language
       	
       	
       	--==============================================================================
       	-- Grammar
       	--==============================================================================
       	
       	-- programa  → { NL } decl { decl }
       	--
       	-- decl      → funcao | global
       	--
       	-- nl        → NL { NL }
       	--
       	-- global    → declvar nl
       	--
       	-- funcao    → 'fun' ID '(' params ')' [ ':' tipo ] nl
       	--                bloco
       	--             'end' nl
       	--
       	-- bloco     → { declvar nl }
       	--             { comando nl }
       	--
       	-- params    → /*vazio*/ | parametro { ',' parametro }
       	--
       	-- parametro → ID ':' tipo
       	--
       	-- tipo      → tipobase | '[' ']' tipo
       	--
       	-- tipobase  → 'int' | 'bool' | 'char' | 'string'
       	--
       	-- declvar   → ID ':' tipo
       	--
       	-- comando   → cmdif | cmdwhile | cmdatrib | cmdreturn | chamada 
       	--
       	-- cmdif     → 'if' exp nl
       	--                bloco
       	--             { 'else' 'if' exp nl
       	--                bloco
       	--             }
       	--             [ 'else' nl
       	--                bloco
       	--             ]
       	--             'end'
       	--
       	-- cmdwhile  → 'while' exp nl
       	--                bloco
       	--             'loop'
       	--
       	-- cmdatrib  → var '=' exp
       	--
       	-- chamada   → ID '(' listaexp ')'
       	--
       	-- listaexp  → /*vazio*/ | exp { ',' exp }
       	--
       	-- cmdreturn → 'return' exp | 'return'
       	--
       	-- var       → ID | var '[' exp ']'
       	--
       	-- exp       → LITNUMERAL
       	--           | LITSTRING
       	--           | TRUE
       	--           | FALSE
       	--           | var
       	--           | 'new' '[' exp ']' tipo
       	--           | '(' exp ')'
       	--           | chamada
       	--           | exp '+' exp
       	--           | exp '-' exp
       	--           | exp '*' exp
       	--           | exp '/' exp
       	--           | exp '>' exp
       	--           | exp '<' exp
       	--           | exp '>=' exp
       	--           | exp '<=' exp
       	--           | exp '=' exp
       	--           | exp '<>' exp
       	--           | exp 'and' exp
       	--           | exp 'or' exp
       	--           | 'not' exp
       	--           | '-' exp

==============================================================================
./src/lexical.lua
==============================================================================
       	--==============================================================================
       	-- Debug
       	--==============================================================================
       	
      5	local printTokensCapture  = false
       	
       	
       	--==============================================================================
       	-- Dependency
       	--==============================================================================
       	
      5	local lulex       = require "lib/lulex"
      5	local TokensClass = require "lib/token_codes"
       	
       	
       	--==============================================================================
       	-- Data Structure
       	--==============================================================================
       	
      5	local Lexical = {}
       	
       	-- number of current line
       	local line_number
       	
       	-- lexer instructions and callbacks
       	--  {
       	--    [#] = {
       	--      [1] = pattern,
       	--      [2] = function,
       	--    }
       	--  }
      5	local lexer = {}
       	
       	-- tags read in input
       	--  {
       	--    [#] = {
       	--      code  = $number,
       	--      line  = $number,
       	--      token = $string,
       	--    }
       	--  }
      5	local tags = {}
       	
       	--  list of tokens
       	--  {
       	--    [name] = $number,
       	--  }
      5	local tokens = TokensClass.GetTokensList()
       	
       	
       	--==============================================================================
       	-- Private Methods
       	--==============================================================================
       	
       	local function StoreToken (code, token, line)
  11185	  if (_DEBUG) then print("LEX :: StoreToken") end
  11185	  assert(code and type(code) == "number")
  11185	  assert(token)
  11185	  assert(line and type(line) == "number")
  11185	  if (_DEBUG or printTokensCapture) then
******0	    print(string.format("codigo: '%10s' linha: %4d token: %s", TokensClass.GetTokenName(code), line, tostring(token)))
       	  end
  11185	  local t = {
  11185	    code = code,
  11185	    line = line,
  11185	    token = token,
       	  }
  11185	  table.insert(tags, t)
       	end
       	
       	
       	--==============================================================================
       	-- Initialize
       	--==============================================================================
       	
     10	lexer = lulex.New{
      5	  { '[ \t]+',
       	    function (token)
       	    end
      5	  },
      5	  { '//[^\n]+',
       	    function (token)
       	      --StoreToken(tokens.COMMENT_LINE, token, line_number)
       	    end
      5	  },
      5	  { '/\\*([^\\*]|\\*[^/])*\\*/',
       	    function (token)
       	      --StoreToken(tokens.COMMENT_BLOCK, token, line_number)
     15	      local init = 0
     45	      while (string.find(token, "\n", init)) do
     30	        _, init = string.find(token, "\n", init)
     30	        init = init + 1
     30	        line_number = line_number + 1
       	      end
       	    end
      5	  },
      5	  { 'if',
       	    function (token)
    203	      StoreToken(tokens.K_IF, token, line_number)
       	    end
      5	  },
      5	  { 'then',
       	    function (token)
      5	      StoreToken(tokens.K_THEN, token, line_number)
       	    end
      5	  },
      5	  { 'else',
       	    function (token)
    130	      StoreToken(tokens.K_ELSE, token, line_number)
       	    end
      5	  },
      5	  { 'while',
       	    function (token)
     31	      StoreToken(tokens.K_WHILE, token, line_number)
       	    end
      5	  },
      5	  { 'loop',
       	    function (token)
     31	      StoreToken(tokens.K_LOOP, token, line_number)
       	    end
      5	  },
      5	  { 'fun',
       	    function (token)
    374	      StoreToken(tokens.K_FUN, token, line_number)
       	    end
      5	  },
      5	  { 'return',
       	    function (token)
    109	      StoreToken(tokens.K_RETURN, token, line_number)
       	    end
      5	  },
      5	  { 'new',
       	    function (token)
     38	      StoreToken(tokens.K_NEW, token, line_number)
       	    end
      5	  },
      5	  { 'string',
       	    function (token)
     18	      StoreToken(tokens.K_STRING, token, line_number)
       	    end
      5	  },
      5	  { 'int',
       	    function (token)
    407	      StoreToken(tokens.K_INT, token, line_number)
       	    end
      5	  },
      5	  { 'char',
       	    function (token)
     42	      StoreToken(tokens.K_CHAR, token, line_number)
       	    end
      5	  },
      5	  { 'bool',
       	    function (token)
     94	      StoreToken(tokens.K_BOOL, token, line_number)
       	    end
      5	  },
      5	  { 'true',
       	    function (token)
     61	      StoreToken(tokens.K_TRUE, token, line_number)
       	    end
      5	  },
      5	  { 'false',
       	    function (token)
     50	      StoreToken(tokens.K_FALSE, token, line_number)
       	    end
      5	  },
      5	  { 'and',
       	    function (token)
     55	      StoreToken(tokens.K_AND, token, line_number)
       	    end
      5	  },
      5	  { 'or',
       	    function (token)
     40	      StoreToken(tokens.K_OR, token, line_number)
       	    end
      5	  },
      5	  { 'not',
       	    function (token)
     58	      StoreToken(tokens.K_NOT, token, line_number)
       	    end
      5	  },
      5	  { 'end',
       	    function (token)
    516	      StoreToken(tokens.K_END, token, line_number)
       	    end
      5	  },
      5	  { '\\"([^\\"\\\\]|\\\\[nt\\\\"])*\\"',
       	    function (token)
     65	      local str = token
     65	      str = string.gsub(str, '^"', '')
     65	      str = string.gsub(str, '"$', '')
     65	      str = string.gsub(str, '\\"', '"')
     65	      str = string.gsub(str, '\\n', '\n')
     65	      str = string.gsub(str, '\\t', '\t')
     65	      str = string.gsub(str, '\\\\', '\\')
     65	      StoreToken(tokens.STRING, str, line_number)
       	    end
      5	  },
      5	  { '[0-9]+',
       	    function (token)
    679	      StoreToken(tokens.NUMBER, token, line_number)
       	    end
      5	  },
      5	  { '0x[0-9a-fA-F]+',
       	    function (token)
     10	      StoreToken(tokens.NUMBER, tonumber(token), line_number)
       	    end
      5	  },
      5	  { '\\(',
       	    function (token)
    565	      StoreToken(tokens["OP_("], token, line_number)
       	    end
      5	  },
      5	  { '\\)',
       	    function (token)
    565	      StoreToken(tokens["OP_)"], token, line_number)
       	    end
      5	  },
      5	  { ',',
       	    function (token)
     98	      StoreToken(tokens["OP_,"], token, line_number)
       	    end
      5	  },
      5	  { ':',
       	    function (token)
    523	      StoreToken(tokens["OP_:"], token, line_number)
       	    end
      5	  },
      5	  { '>',
       	    function (token)
     36	      StoreToken(tokens["OP_>"], token, line_number)
       	    end
      5	  },
      5	  { '<',
       	    function (token)
     70	      StoreToken(tokens["OP_<"], token, line_number)
       	    end
      5	  },
      5	  { '>=',
       	    function (token)
     10	      StoreToken(tokens["OP_>="], token, line_number)
       	    end
      5	  },
      5	  { '<=',
       	    function (token)
     30	      StoreToken(tokens["OP_<="], token, line_number)
       	    end
      5	  },
      5	  { '=',
       	    function (token)
    710	      StoreToken(tokens["OP_="], token, line_number)
       	    end
      5	  },
      5	  { '<>',
       	    function (token)
     43	      StoreToken(tokens["OP_<>"], token, line_number)
       	    end
      5	  },
      5	  { '\\[',
       	    function (token)
    227	      StoreToken(tokens["OP_["], token, line_number)
       	    end
      5	  },
      5	  { '\\]',
       	    function (token)
    227	      StoreToken(tokens["OP_]"], token, line_number)
       	    end
      5	  },
      5	  { '\\+',
       	    function (token)
    110	      StoreToken(tokens["OP_+"], token, line_number)
       	    end
      5	  },
      5	  { '-',
       	    function (token)
     62	      StoreToken(tokens["OP_-"], token, line_number)
       	    end
      5	  },
      5	  { '\\*',
       	    function (token)
     46	      StoreToken(tokens["OP_*"], token, line_number)
       	    end
      5	  },
      5	  { '/',
       	    function (token)
     21	      StoreToken(tokens["OP_/"], token, line_number)
       	    end
      5	  },
      5	  { '[ \n]+',
       	    function (token)
   2578	      StoreToken(tokens.LINE_END, token, line_number)
   2578	      local init = 0
   5508	      while (string.find(token, "\n", init)) do
   2930	        _, init = string.find(token, "\n", init)
   2930	        init = init + 1
   2930	        line_number = line_number + 1
       	      end
       	    end
      5	  },
      5	  { '[a-zA-Z_][a-zA-Z0-9_]*',
       	    function (token)
   2232	      StoreToken(tokens.ID, token, line_number)
       	    end
      5	  },
      5	  { '.',
       	    function (token)
     16	      StoreToken(tokens.ERROR, token, line_number)
       	    end
      5	  },
     10	}
       	
       	
       	--==============================================================================
       	-- Public Methods
       	--==============================================================================
       	
       	--Open:
       	--  parameters:
       	--    [1] $string  - path of file to be analysed
       	--  return:
       	--    [1] $boolean - false if found any problem, true otherwise
       	--    [2] $string  - only when [1] is false, informing which error occurs
      5	function Lexical.Open (txt)
    321	  if (_DEBUG) then print("LEX :: Open") end
    321	  assert(txt and type(txt) == "string")
    321	  tags = {}
    321	  line_number = 1
    321	  lexer:run(txt, true)
  11450	  for _, tab in ipairs(tags) do
  11133	    if (tab.code == tokens.ERROR) then
      4	      return false, "Erro na identificação das tags na linha " .. tab.line
       	    end
       	  end
    317	  return true
       	end
       	
      5	function Lexical.GetTags()
    317	  if (_DEBUG) then print("LEX :: GetTags") end
    317	  return tags
       	end
       	
       	
       	--==============================================================================
       	-- Return
       	--==============================================================================
       	
      5	return Lexical

==============================================================================
./src/parser.lua
==============================================================================
       	--==============================================================================
       	-- Debug
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Dependency
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Data Structure
       	--==============================================================================
       	
      5	local Parser = {}
       	
       	-- store tokens list received in input
      5	local tokens_list = {}
       	
       	-- keep the number of the current token
      5	local current = 0
       	
       	
       	--==============================================================================
       	-- Private Methods
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Initialize
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Public Methods
       	--==============================================================================
       	
       	--Advance:
       	--  parameters:
       	--  return:
      5	function Parser.Advance ()
   9377	  if (_DEBUG) then print("PAR :: Advance") end
   9377	  current = current + 1
       	end
       	
       	--Open: Start a new parser with current table input, erasing any previous one
       	--  parameters:
       	--    [1] $table   - table with tokens read in lexical
       	--  return:
      5	function Parser.Open (t)
    317	  if (_DEBUG) then print("PAR :: Open") end
    317	  assert(type(t) == "table")
    317	  current = 0
    317	  tokens_list = t
       	end
       	
       	--Peek: peek the next token
       	--  parameters:
       	--  return:
      5	function Parser.Peek ()
  28087	  if (_DEBUG) then print("PAR :: Peek") end
  28087	  return tokens_list[current + 1]
       	end
       	
       	--Peek2: peek the second next token
       	--  parameters:
       	--  return:
      5	function Parser.Peek2 ()
   2069	  if (_DEBUG) then print("PAR :: Peek2") end
   2069	  return tokens_list[current + 2]
       	end
       	
       	
       	--==============================================================================
       	-- Return
       	--==============================================================================
       	
      5	return Parser

==============================================================================
./src/semantic.lua
==============================================================================
       	--==============================================================================
       	-- Considerations
       	--==============================================================================
       	
       	-- Functions sets new unreach code variable '@ret' as its return VAR variable
       	-- Functions sets PARAMETER nodes to own scope
       	-- ALLOW overwrite variable in diferent parameters
       	
       	--==============================================================================
       	-- Debug
       	--==============================================================================
       	
       	-- char dentro de array
       	
       	
       	--==============================================================================
       	-- Dependency
       	--==============================================================================
       	
      5	require "lib/util"
      5	local SymbolClass = require "src/symbol_table"
      3	local NodesClass  = require "lib/node_codes"
       	
       	
       	--==============================================================================
       	-- Data Structure
       	--==============================================================================
       	
      3	local Semantic = {}
       	
       	--  list of nodes code
       	--  {
       	--    [name] = $number,
       	--  }
      3	local nodes_codes = NodesClass.GetNodesList()
       	
       	
       	--==============================================================================
       	-- Private Methods
       	--==============================================================================
       	
       	--Error: Callback of errors that occurs during semantic analysis
       	--  Parameters:
       	--    [1] $string
       	--  Return:
       	local function Error (msg, line)
    115	  local str = string.format("Semantic error: @%d %s", line or 0, msg)
     74	  error(str, 0)
       	end
       	
       	--ErrorDeclaredSymbol: Callback of errors that occurs during semantic analysis
       	--  Parameters:
       	--    [1] $string
       	--  Return:
       	local function ErrorDeclaredSymbol (sym_prev, sym_new)
     17	  error(string.format("Semantic error: @%d Symbol '%s' was declared at line %d", sym_new.line, sym_prev.name, sym_prev.line), 0)
       	end
       	
       	
       	
       	--VerifyAttribution:
       	--  Parameters:
       	--    [1] $table  = ATTRIBUTION node
       	--  Return:
     53	function Semantic.VerifyAttribution (node)
    152	  if (_DEBUG) then print("SEM :: VerifyAttribution") end
    152	  assert(node.id == nodes_codes["ATTRIBUTION"])
    136	  Semantic.VerifyVar(node.var)
    112	  Semantic.VerifyExpression(node.exp)
     81	  if (node.var.sem_type ~= node.exp.sem_type) then
     10	    if (node.var.sem_type == "bool" or node.exp.sem_type == "bool") then
      5	      Error(string.format("Attribution of variable '%s' type '%s' cannot receive type '%s'.", node.var.name, node.var.sem_type, node.exp.sem_type), node.line)
      7	    elseif (node.var.sem_type == "char" or node.exp.sem_type == "string") then
      4	      if not (node.var.sem_dimension - 1 == node.exp.sem_dimension) then
      3	        Error(string.format("Attribution of '%s' 'char' dimension '%d' not compatible with expression 'string' dimension '%d'.", node.var.name, node.var.sem_dimension, node.exp.sem_dimension), node.line)
       	      end
      4	    elseif (node.var.sem_type == "string" or node.exp.sem_type == "char") then
      4	      if not (node.var.sem_dimension == node.exp.sem_dimension - 1) then
      3	        Error(string.format("Attribution of '%s' 'string' dimension '%d' not compatible with expression 'char' dimension '%d'.", node.var.name, node.var.sem_dimension, node.exp.sem_dimension), node.line)
       	      end
       	    else
******0	      if (node.var.sem_dimension ~= node.exp.sem_dimension) then
******0	        Error(string.format("Attribution expects same dimension at both sides, but got '%d' and '%d'.", node.var.sem_dimension, node.exp.sem_dimension), node.line)
       	      end
       	    end
       	  else
     69	    if (node.var.sem_dimension ~= node.exp.sem_dimension) then
******0	      Error(string.format("Attribution expects same dimension at both sides, but got '%d' and '%d'.", node.var.sem_dimension, node.exp.sem_dimension), node.line)
       	    end
       	  end
       	  -- MUST UPDATE SYMBOL TABLE VALUE
       	end
       	
       	--VerifyBlock:
       	--  Parameters:
       	--  Return:
     94	function Semantic.VerifyBlock (block)
    366	  if (_DEBUG) then print("SEM :: VerifyBlock") end
    528	  for _, node in ipairs(block) do
    331	    if (node.id == nodes_codes["DECLARE"]) then
    186	      Semantic.VerifyDeclare(node)
    253	    elseif (node.id == nodes_codes["ATTRIBUTION"]) then
    154	      Semantic.VerifyAttribution(node)
    107	    elseif (node.id == nodes_codes["CALL"]) then
     66	      Semantic.VerifyCall(node)
     99	    elseif (node.id == nodes_codes["IF"]) then
     62	      Semantic.VerifyIf(node)
     67	    elseif (node.id == nodes_codes["RETURN"]) then
     42	      Semantic.VerifyReturn(node)
     21	    elseif (node.id == nodes_codes["WHILE"]) then
     13	      Semantic.VerifyWhile(node)
       	    else
******0	      Error("Unknown block node")
       	    end
       	  end
       	end
       	
       	--VerifyCall:
       	--  Parameters:
       	--    [1] $table  = CALL node
       	--  Return:
     13	function Semantic.VerifyCall (node)
     36	  if (_DEBUG) then print("SEM :: VerifyCall") end
     36	  assert(node.id == nodes_codes["CALL"])
     36	  local symbol = SymbolClass.GetSymbol(node.name)
     30	  if (not symbol) then
      6	    Error(string.format("Undeclared symbol '%s'.", node.name), node.line)
       	  end
     21	  if (symbol.id ~= "function") then
      3	    Error(string.format("Attempt to call %s '%s', but it is a '%s', not a 'function'.", symbol.id, symbol.name, symbol.type), node.line)
       	  end
     22	  local num_func_params = symbol.params and #symbol.params or 0
     22	  local num_call_params = node.exps and #node.exps or 0
     18	  if (num_func_params ~= num_call_params) then
      3	    Error(string.format("Function '%s' expects '%d' parameters, but got '%d'.", symbol.name, num_func_params, num_call_params), node.line)
       	  end
     30	  for i = 1, num_func_params do
     16	    Semantic.VerifyExpression(node.exps[i])
     12	    Semantic.VerifyCompatibleTypes(node.line, symbol.params[i].type, symbol.params[i].dimension, node.exps[i].sem_type, node.exps[i].sem_dimension)
       	  end
     18	  node.sem_type = symbol.ret_type
     20	  node.sem_dimension = symbol.ret_dimension
       	end
       	
     23	function Semantic.VerifyCompatibleTypes (line, first_type, first_dimension, second_type, second_dimension)
     57	  local err = false
     41	  if (first_type ~= second_type) then
      8	    if (first_type == "int" and second_type == "char") or (first_type == "char" and second_type == "int") then
      3	      if (first_dimension ~= second_dimension) then
******0	        err = true
       	      end
      3	    elseif (first_type == "string" and second_type == "char") then
******0	      if (first_dimension + 1 ~= second_dimension) then
******0	        err = true
       	      end
      3	    elseif (first_type == "char" and second_type == "string") then
******0	      if (first_dimension ~= second_dimension + 1) then
******0	        err = true
       	      end
       	    else
      5	      err = true
       	    end
       	  else
     33	    if (first_dimension ~= second_dimension) then
      3	      err = true
       	    end
       	  end
     41	  if (err) then
      6	    Error(string.format("Uncompatible types '%s' dimension '%d' and '%s' dimension '%d'.", first_type, first_dimension, second_type, second_dimension), line)
       	  end
     33	  return true
       	end
       	
       	--VerifyDeclare:
       	--    verify if symbol was already used
       	--    set new symbol
       	--  Parameters:
       	--    [1] $table  = DECLARE node
       	--  Return:
     47	function Semantic.VerifyDeclare (node)
    128	  if (_DEBUG) then print("SEM :: VerifyDeclare") end
    128	  assert(node.id == nodes_codes["DECLARE"])
    128	  local symbol = SymbolClass.GetCurrentScopeSymbol(node.name)
     88	  if (symbol) then
      3	    ErrorDeclaredSymbol(symbol, node)
       	  else
     81	    SymbolClass.SetSymbol(node)
       	  end
       	end
       	
       	--VerifyElseIf
       	--  Parameters:
       	--    [1] $table  = ELSEIF node
       	--  Return:
      5	function Semantic.VerifyElseIf (node)
     11	  if (_DEBUG) then print("SEM :: VerifyElseIf") end
     11	  assert(node.id == nodes_codes["ELSEIF"])
     11	  SymbolClass.AddScope()
     11	  Semantic.VerifyExpression(node.cond)
     10	  if (node.cond.sem_type ~= "bool" or node.cond.sem_dimension ~= 0) then
      3	    Error(string.format("Else if expects 'bool' expression with dimension '0', but got type '%s' with dimension '%d'.", node.cond.sem_type, node.cond.sem_dimension), node.line)
       	  end
      7	  Semantic.VerifyBlock(node.block)
      9	  SymbolClass.RemoveScope()
       	end
       	
       	--VerifyExpression:
       	--  Parameters:
       	--  Return:
    175	function Semantic.VerifyExpression (node)
    510	  if (_DEBUG) then print("SEM :: VerifyExpression") end
    342	  if (node.id == nodes_codes["CALL"]) then
    174	    Semantic.VerifyCall(node)
    332	  elseif (node.id == nodes_codes["NEGATE"]) then
      3	    Semantic.VerifyExpression(node.exp)
      3	    if (node.exp.sem_type ~= "bool" or node.exp.sem_dimension ~= 0) then
******0	      Error(string.format("Operation 'negate' must be done over type 'bool' with dimension '0', but got type '%s' with dimension '%d'.", node.exp.sem_type, node.exp.sem_dimension))
       	    end
      3	    node.sem_type = "bool"
    171	    node.sem_dimension = 0
    337	  elseif (node.id == nodes_codes["NEWVAR"]) then
     23	    Semantic.VerifyExpression(node.exp)
     15	    if (node.exp.sem_type ~= "int" and node.exp.sem_type ~= "char") then
******0	      Error(string.format("New var expression must have type 'int' or 'char', but got type '%s'.", node.exp.sem_type), node.line)
       	    end
     23	    node.sem_type = node.type
    175	    node.sem_dimension = node.dimension + 1
    352	  elseif (node.id == nodes_codes["OPERATOR"]) then
    102	    Semantic.VerifyExpression(node[1])
     99	    Semantic.VerifyExpression(node[2])
     63	    if (node.op == "and" or node.op == "or") then
******0	      if (node[1].sem_type ~= "bool" or node[2].sem_type ~= "bool") then
******0	        Error(string.format(""))
       	      end
******0	      if (node[1].sem_dimension ~= 0 or node[2].sem_dimension ~= 0) then
******0	        Error(string.format("Operation '%s' cannot be made over arrays values.", node.op))
       	      end
******0	      node.sem_type = "bool"
     36	      node.sem_dimension = 0
     69	    elseif (node.op == "=" or node.op == "<>") then
     15	      if (node[1].sem_type ~= node[2].sem_type) then
      3	        if ((node[1].sem_type ~= "int" and node[1].sem_type ~= "char") or (node[2].sem_type ~= "int" and node[2].sem_type ~= "char")) then
******0	          Error(string.format("Operation '%s' require 'int' or 'char' expressions on both sides, but got '%s' and '%s'.", node.op, node[1].sem_type, node[2].sem_type))
       	        end
       	      end
     13	      if (node[1].sem_dimension ~= node[2].sem_dimension) then
******0	        Error(string.format("Operation '%s' must have equal variables dimension, but got '%s' and '%s'.", node.op, node[1].sem_dimension, node[2].sem_dimension))
       	      end
     19	      node.sem_type = "bool"
     43	      node.sem_dimension = 0
     62	    elseif (node.op == ">" or node.op == "<" or node.op == ">=" or node.op == "<=") then
     19	      if ((node[1].sem_type ~= "int" and node[1].sem_type ~= "char") or (node[2].sem_type ~= "int" and node[2].sem_type ~= "char")) then
******0	        Error(string.format("Operation '%s' require 'int' or 'char' expressions on both sides, but got '%s' and '%s'.", node.op, node[1].sem_type, node[2].sem_type))
       	      end
     19	      if (node[1].sem_dimension ~= 0 or node[2].sem_dimension ~= 0) then
******0	        Error(string.format("Operation '%s' cannot be made over arrays values.", node.op))
       	      end
     31	      node.sem_type = "bool"
     37	      node.sem_dimension = 0
     49	    elseif (node.op == "+" or node.op == "-" or node.op == "*" or node.op == "/") then
     31	      if ((node[1].sem_type ~= "int" and node[1].sem_type ~= "char") or (node[2].sem_type ~= "int" and node[2].sem_type ~= "char")) then
******0	        Error(string.format("Operation '%s' require 'int' or 'char' expressions on both sides, but got '%s' and '%s'.", node.op, node[1].sem_type, node[2].sem_type))
       	      end
     40	      if (node[1].sem_dimension ~= 0 or node[2].sem_dimension ~= 0) then
      9	        Error(string.format("Operation '%s' cannot be made over arrays values.", node.op))
       	      end
     40	      node.sem_type = "int"
     49	      node.sem_dimension = 0
       	    else
******0	      Error("Unknown operation '%s'.", node.op)
       	    end
    292	  elseif (node.id == nodes_codes["UNARY"]) then
     78	    Semantic.VerifyExpression(node.exp)
******0	    if ((node.exp.sem_type ~= "int" and node.exp.sem_type ~= "char") or node.exp.sem_dimension ~= 0) then
******0	      Error(string.format("Operation 'unary' must be done over type 'char' or 'int' with dimension '0', but got type '%s' with dimension '%d'.", node.exp.sem_type, node.exp.sem_dimension))
       	    end
******0	    node.sem_type = node.exp.sem_type
******0	    node.sem_dimension = node.exp.sem_dimension
    292	  elseif (node.id == nodes_codes["VALUE"]) then
    230	    node.sem_type = node.type
    193	    node.sem_dimension = 0
    181	  elseif (node.id == nodes_codes["VAR"]) then
    177	    Semantic.VerifyVar(node)
       	  else
******0	    Error("Unknown expression node")
       	  end
       	end
       	
       	--VerifyFunction:
       	--    add scope
       	--    add function parameters as symbols
       	--    add function return as symbol '@ret'
       	--    call verifications for block
       	--    remove scope
       	--  Parameters:
       	--    [1] $table  = FUNCTION node
       	--  Return:
      4	function Semantic.VerifyFunction (node)
    149	  if (_DEBUG) then print("SEM :: VerifyFunction") end
    189	  assert(node.id == nodes_codes["FUNCTION"])
    189	  SymbolClass.AddScope()
    189	  if (node.params) then
    218	    for _, param in ipairs(node.params) do
     81	      if (SymbolClass.GetCurrentScopeSymbol(param.name)) then
     12	        Error()
       	      end
     83	      SymbolClass.SetSymbol(param)
       	    end
       	  end
    102	  if (node.ret_type) then
     84	    local ret = {
     55	      id        = nodes_codes["DECLARE"],
     55	      name      = "@ret",
     35	      line      = node.line,
     55	      type      = node.ret_type,
     35	      dimension = node.ret_dimension,
     75	    }
     44	    SymbolClass.SetSymbol(ret)
       	  end
     82	  Semantic.VerifyBlock(node.block)
     72	  SymbolClass.RemoveScope()
       	end
       	
       	--VerifyGlobals:
       	--    add global functions and variables to scope
       	--  Parameters:
       	--    [1] $table  = PROGRAM node
       	--  Return:
    160	function Semantic.VerifyGlobals (t)
    180	  if (_DEBUG) then print("SEM :: VerifyGlobals") end
    219	  assert(t.id == nodes_codes["PROGRAM"])
    258	  for _, node in ipairs(t) do
    242	    local symbol = SymbolClass.GetSymbol(node.name)
    297	    if (symbol) then
     76	      ErrorDeclaredSymbol(symbol, node)
       	    end
    130	    SymbolClass.SetSymbol(node)
       	  end
       	end
       	
       	--VerifyIf
       	--  Parameters:
       	--    [1] $table  = IF node
       	--  Return:
     20	function Semantic.VerifyIf (node)
     42	  if (_DEBUG) then print("SEM :: VerifyIf") end
     48	  assert(node.id == nodes_codes["IF"])
     36	  SymbolClass.AddScope()
     34	  Semantic.VerifyExpression(node.cond)
     42	  if (node.cond.sem_type ~= "bool" or node.cond.sem_dimension ~= 0) then
     19	    Error(string.format("If expects 'bool' expression with dimension '0', but got type '%s' with dimension '%d'.", node.cond.sem_type, node.cond.sem_dimension), node.line)
       	  end
     19	  Semantic.VerifyBlock(node.block)
     21	  if (node["elseif"]) then
     23	    for _, n in ipairs (node["elseif"]) do
     21	      Semantic.VerifyElseIf(n)
       	    end
       	  end
     17	  if (node["else"]) then
     14	    SymbolClass.AddScope()
     20	    Semantic.VerifyBlock(node["else"])
     22	    SymbolClass.RemoveScope()
       	  end
     11	  SymbolClass.RemoveScope()
       	end
       	
       	
       	--VerifyProgram:
       	--  Parameters:
       	--    [1] $table  = PROGRAM node
       	--  Return:
     69	function Semantic.VerifyProgram (t)
    148	  if (_DEBUG) then print("SEM :: VerifyProgram") end
    210	  assert(t.id == nodes_codes["PROGRAM"])
    195	  SymbolClass.AddScope()
    120	  Semantic.VerifyGlobals(t)
    238	  for _, node in ipairs(t) do
    244	    if (node.id == nodes_codes["DECLARE"]) then
       	      -- DO NOT VERIFY. SYMBOL ADDED IN GLOBALS
     84	    elseif (node.id == nodes_codes["FUNCTION"]) then
    125	      Semantic.VerifyFunction(node)
       	    else
     15	      Error("Unknown node")
       	    end
       	  end
     20	  SymbolClass.RemoveScope()
       	end
       	
       	--VerifyReturn:
       	--    verify if function is void and return value
       	--    verify if function return nil but expect value
       	--    verify if type and dimension of return equals function description
       	--  Parameters:
       	--    [1] $table  = RETURN node
       	--  Return:
     22	function Semantic.VerifyReturn (node)
     44	  if (_DEBUG) then print("SEM :: VerifyReturn") end
     38	  assert(node.id == nodes_codes["RETURN"])
     50	  local symbol = SymbolClass.GetSymbol("@ret")
     50	  if (not symbol) then
     31	    Error(string.format("Void function must not return values at line '%s'.", node.line))
     21	  elseif (node.exp) then
     26	    Semantic.VerifyExpression(node.exp)
     25	    Semantic.VerifyCompatibleTypes(node.line, symbol.type, symbol.dimension, node.exp.sem_type, node.exp.sem_dimension)
     10	  elseif (symbol.type) then
      3	    Error(string.format("Function expected to return type '%s' but got 'nil'.", symbol.type), node.line)
       	  else
******0	    Error("Unknown error.")
       	  end
       	end
       	
       	--VerifyVar:
       	--    verify if symbol was declared
       	--    verify if given dimension is greater than symbol dimension
       	--    verify if array expressions are 'int' or 'char'
       	--    verify if given dimension exists but symbol dimension is null
       	--  Parameters:
       	--    [1] $table  = VAR node
       	--  Return:
    115	function Semantic.VerifyVar (node)
    260	  if (_DEBUG) then print("SEM :: VerifyVar") end
    230	  assert(node.id == nodes_codes["VAR"])
    216	  local symbol = SymbolClass.GetSymbol(node.name)
    315	  if (not symbol) then
    183	    Error(string.format("Undeclared symbol '%s'.", node.name), node.line)
       	  end
    152	  node.sem_type = symbol.type
    197	  if (symbol.dimension and symbol.dimension > 0) then
     94	    if (node.array) then
     70	      if (#node.array > symbol.dimension) then
     25	        Error(string.format("Symbol '%s' dimension is '%d', but was called with dimension '%d'.", node.name, symbol.dimension, #node.array), node.line)
       	      end
     43	      for _, exp in ipairs(node.array) do
     33	        Semantic.VerifyExpression(exp)
     20	        if (exp.sem_type ~= "int" and exp.sem_type ~= "char") then
      8	          Error(string.format("Dimension of symbol '%s' must be a type 'int' or 'char', but got '%s'.", node.name, exp.sem_type), node.line)
       	        end
       	      end
       	    end
     27	    node.sem_dimension = symbol.dimension - #node.array
    191	  elseif (node.array and #node.array > 0) then
     50	    Error(string.format("Symbol '%s' dimension is '0', but was called with dimension '%d'.", node.name, #node.array), node.line)
       	  else
     99	    node.sem_dimension = 0
       	  end
       	end
       	
       	--VerifyWhile:
       	--  Parameters:
       	--    [1] $table  = WHILE node
       	--  Return:
     10	function Semantic.VerifyWhile (node)
     18	  if (_DEBUG) then print("SEM :: VerifyWhile") end
     21	  assert(node.id == nodes_codes["WHILE"])
     13	  SymbolClass.AddScope()
     13	  Semantic.VerifyExpression(node.cond)
     21	  if (node.cond.sem_type ~= "bool" or node.cond.sem_dimension ~= 0) then
     10	    Error(string.format("While expects 'bool' expression with dimension '0', but got type '%s' with dimension '%d'.", node.cond.sem_type, node.cond.sem_dimension), node.line)
       	  end
      9	  Semantic.VerifyBlock(node.block)
     11	  SymbolClass.RemoveScope()
       	end
       	
       	--==============================================================================
       	-- Initialize
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Public Methods
       	--==============================================================================
       	
       	--Open:
       	--  parameters:
       	--    [1] $table   - table with AST tree nodes
       	--  return:
       	--    [1] $boolean - false if found any problem, true otherwise
       	--    [2] $string  - only when [1] is false, informing which error occurs
     69	function Semantic.Open (t)
    215	  if (_DEBUG) then print("SEM :: Open") end
    187	  assert(t and type(t) == "table")
    172	  SymbolClass.Clear()
    200	  local ok, msg = pcall(function () Semantic.VerifyProgram(t) end)
    175	  if (not ok) then
    102	    return false, msg
       	  end
     20	  return true
       	end
       	
       	
       	--==============================================================================
       	-- Return
       	--==============================================================================
       	
      2	return Semantic

==============================================================================
./src/symbol_table.lua
==============================================================================
       	--==============================================================================
       	-- Debug
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Dependency
       	--==============================================================================
       	
      5	require "lib/util"
      5	local NodesClass  = require "lib/node_codes"
       	
       	
       	--==============================================================================
       	-- Data Structure
       	--==============================================================================
       	
      5	local SymbolTable = {}
       	
      5	local scopes = {}
       	
       	--  list of nodes code
       	--  {
       	--    [name] = $number,
       	--  }
      5	local nodes_codes = NodesClass.GetNodesList()
       	
       	
       	--==============================================================================
       	-- Private Methods
       	--==============================================================================
       	
      5	function Error ()
******0	  error("Symbol error.", 0)
       	end
       	
       	--==============================================================================
       	-- Initialize
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Public Methods
       	--==============================================================================
       	
       	--AddScope:
       	--  parameters:
       	--  return:
      5	function SymbolTable.AddScope ()
    479	  if (_DEBUG) then print("SYB :: AddScope") end
    479	  scopes[#scopes + 1] = {}
       	end
       	
       	--Clear:
       	--  parameters:
       	--  return:
      5	function SymbolTable.Clear ()
    187	  if (_DEBUG) then print("SYB :: Clear") end
    187	  scopes = {}
       	end
       	
       	--GetCurrentScopeSymbol:
       	--  parameters:
       	--  return:
      5	function SymbolTable.GetCurrentScopeSymbol (name)
    401	  if (_DEBUG) then print("SYB :: GetCurrentScopeSymbol") end
    401	  local num_scope = #scopes
    756	  if (scopes[#scopes][name]) then
    494	    local symbol = util.TableCopy(scopes[#scopes][name])
    139	    symbol.name = name
    139	    return symbol
       	  end
    109	  return nil
       	end
       	
       	--GetSymbol:
       	--  parameters:
       	--  return:
      3	function SymbolTable.GetSymbol (name)
    482	  if (_DEBUG) then print("SYB :: GetSymbol") end
    482	  local num_scope = #scopes
   1031	  while (num_scope > 0) do
    802	    if (scopes[num_scope][name]) then
    255	      local symbol = util.TableCopy(scopes[num_scope][name])
    257	      symbol.name = name
    255	      return symbol
       	    end
    547	    num_scope = num_scope - 1
       	  end
    229	  return nil
       	end
       	
       	--Print:
       	--  parameters:
       	--  return:
      3	function SymbolTable.Print ()
******0	  if (_DEBUG) then print("SYB :: Print") end
******0	  util.TablePrint(scopes)
       	end
       	
       	--RemoveScope:
       	--  parameters:
       	--  return:
      3	function SymbolTable.RemoveScope ()
    122	  if (_DEBUG) then print("SYB :: RemoveScope") end
    122	  scopes[#scopes] = nil
       	end
       	
       	--SetSymbol:
       	--          function or var
       	--  parameters:
       	--    [1] $table  - 
       	--              id   = $number - 
       	--              name = $string - 
       	--              line = $number - 
       	--              func_params {
       	--                params        = $table  - 
       	--                ret_type      = $string - 
       	--                ret_dimension = $number - 
       	--              }
       	--              var_params {
       	--                type
       	--                dimension = $number - 
       	--              }
       	--  return:
     86	function SymbolTable.SetSymbol (t)
    421	  if (_DEBUG) then print("SYB :: SetSymbol") end
    421	  assert(t and type(t) == "table")
    338	  assert(t.line and type(t.line) == "number")
    338	  assert(t.name and type(t.name) == "string")
    338	  local symbol = {}
    499	  symbol.line = t.line
    499	  symbol.name = t.name
    338	  if (t.id == nodes_codes["FUNCTION"]) then
    309	    symbol.id = "function"
    146	    symbol.params = util.TableCopy(t.params)
    146	    symbol.ret_type = t.ret_type
    146	    symbol.ret_dimension = t.ret_dimension
    192	  elseif (t.id == nodes_codes["DECLARE"] or t.id == nodes_codes["PARAMETER"]) then
    192	    symbol.id = "variable"
    192	    symbol.type = t.type
    194	    symbol.dimension = t.dimension
       	  else
******0	    Error()
       	  end
    338	  scopes[#scopes] = scopes[#scopes] or {}
    338	  scopes[#scopes][t.name] = symbol
       	  --util.TablePrint(scopes)
       	end
       	
       	
       	--==============================================================================
       	-- Return
       	--==============================================================================
       	
      3	return SymbolTable

==============================================================================
./src/syntactic.lua
==============================================================================
       	--==============================================================================
       	-- Debug
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Dependency
       	--==============================================================================
       	
      5	local ParserClass 	= require "src/parser"
      5	local LanguageClass = require "src/grammar"
      5	local ASTClass		  = require "src/syntax_tree"
       	
       	
       	--==============================================================================
       	-- Data Structure
       	--==============================================================================
       	
      5	local Syntactic = {}
       	
       	
       	--==============================================================================
       	-- Private Methods
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Initialize
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Public Methods
       	--==============================================================================
       	
       	--GetTree:
      5	function Syntactic.GetTree()
    187	  if (_DEBUG) then print("SYN :: GetTree") end
    187	  return ASTClass.GetTree()
       	end
       	
       	--Open:
       	--  parameters:
       	--    [1] $table   - table with tokens read in lexical
       	--  return:
       	--    [1] $boolean - false if found any problem, true otherwise
       	--    [2] $string  - only when [1] is false, informing which error occurs
      5	function Syntactic.Open (t)
    317	  if (_DEBUG) then print("SYN :: Open") end
    317	  assert(t and type(t) == "table")
    317	  ParserClass.Open(t)
    317	  local ok, msg = LanguageClass.Start(ParserClass.Advance, ParserClass.Peek, ParserClass.Peek2)
    317	  if (not ok) then
    130	  	return false, msg
       	  end
    187	  return true
       	end
       	
       	--PrintTree:
      5	function Syntactic.PrintTree()
******0	  if (_DEBUG) then print("SYN :: PrintTree") end
******0	  return ASTClass.Print()
       	end
       	
       	
       	--==============================================================================
       	-- Return
       	--==============================================================================
       	
      5	return Syntactic

==============================================================================
./src/syntax_tree.lua
==============================================================================
       	--==============================================================================
       	-- Debug
       	--==============================================================================
       	
      5	local printTree = false
       	
       	
       	--==============================================================================
       	-- Dependency
       	--==============================================================================
       	
      5	require "lib/util"
      5	local NodesClass  = require "lib/node_codes"
       	
       	
       	--==============================================================================
       	-- Data Structure
       	--==============================================================================
       	
      5	local AbstractSyntaxTree = {}
       	
       	--  list of nodes print functions
      5	local Print = {}
       	
       	--  list of nodes code
       	--  {
       	--    [name] = $number,
       	--  }
      5	local nodes_codes = NodesClass.GetNodesList()
       	
       	--  AST tree (structed nodes)
      5	local tree = {}
       	
       	
       	--==============================================================================
       	-- Private Methods
       	--==============================================================================
       	
      5	function Print.Block (indent, t)
******0	  if (t) then
******0	    for _, node in ipairs(t) do
******0	      if (node.id == nodes_codes["ATTRIBUTION"]) then
******0	        Print.ComandAttribution(indent, node)
******0	      elseif (node.id == nodes_codes["IF"]) then
******0	        Print.ComandIf(indent, node)
******0	      elseif (node.id == nodes_codes["RETURN"]) then
******0	        Print.ComandReturn(indent, node)
******0	      elseif (node.id == nodes_codes["WHILE"]) then
******0	        Print.ComandWhile(indent, node)
******0	      elseif (node.id == nodes_codes["DECLARE"]) then
******0	        Print.Declare(indent, node)
******0	      elseif (node.id == nodes_codes["CALL"]) then
******0	        Print.Call(indent, node)
       	      --elseif (node.id == nodes_codes["VAR"]) then
       	        --Print.Variable(indent, node)
       	      else
******0	        error("block node error")
       	      end
       	    end
       	  end
       	end
       	
      5	function Print.Call (indent, t)
******0	  print(indent .. "CALL [" .. t.name .. "] @" .. t.line .. "  {")
******0	  for _, node in ipairs(t.exps) do
******0	    print(indent .. "  PARAM " .. Print.Expression(node))
       	  end
******0	  print(indent .. "}")
       	end
       	
      5	function Print.ComandAttribution (indent, t)
******0	  print(indent .. "ATRIB @" .. t.line .. " {")
******0	  local str = ""
******0	  str = str .. t.var.name
******0	  if (t.var.array) then
******0	    for _, exp in ipairs(t.var.array) do
******0	      str = str .. "[" .. Print.Expression(exp) .. "]"
       	    end
       	  end
******0	  Print.Variable(indent .. "  ", t.var)
       	
******0	  print(indent .. "  =" .. Print.Expression(t.exp))
******0	  print(indent .. "}")
       	end
       	
      5	function Print.ComandElseIf (indent, t)
******0	  print(indent .. "ELSEIF [" .. Print.Expression(t.cond) .. "] @" .. t.line)
******0	  Print.Block(indent .. "  ", t.block)
       	end
       	
      5	function Print.ComandIf (indent, t)
******0	  print(indent .. "IF [" .. Print.Expression(t.cond) .. "] @" .. t.line .. " {")
******0	  Print.Block(indent .. "  ", t.block)
******0	  if (t["elseif"]) then
******0	    for _, elseif_node in ipairs(t["elseif"]) do
******0	      Print.ComandElseIf(indent, elseif_node)
       	    end
       	  end
******0	  if (t["else"]) then
******0	    print(indent .. "ELSE ")
******0	    Print.Block(indent .. "  ", t["else"])
       	  end
******0	  print(indent .. "}")
       	end
       	
      5	function Print.ComandReturn (indent, t)
******0	  print(indent .. "RETURN @" .. t.line .. " {")
******0	  print(indent .. "  " .. Print.Expression(t.exp))
******0	  print(indent .. "}")
       	  -- print(indent .. "RETURN [" .. Print.Expression(t.exp) .. "] @" .. t.line)
       	end
       	
      5	function Print.ComandWhile (indent, t)
******0	  print(indent .. "WHILE [" .. Print.Expression(t.cond) .. "] @" .. t.line .. " {")
******0	  Print.Block(indent .. "  ", t.block)
******0	  print(indent .. "}")
       	end
       	
      5	function Print.Declare (indent, t)
******0	  print(indent .. "DECLARE @" .. t.line .. "{")
******0	  print(indent .. "  ID [" .. t.name .. "] " .. t.type .. string.rep("[]", t.dimension) .. " @" .. t.line)
******0	  print(indent .. "}")
       	  -- print(indent .. "DECLARE [" .. t.name .. "] " .. t.type .. string.rep("[]", t.dimension) .. " @" .. t.line)
       	end
       	
      5	function Print.Expression (node)
******0	  local str = "("
******0	  if (not node) then
******0	    return ""
       	  end
******0	  if (node.id == nodes_codes["PARENTHESIS"]) then
******0	    str = str .. " (" .. Print.Expression(node.exp) .. ")"
******0	  elseif (node.id == nodes_codes["NEWVAR"]) then
******0	    str = str .. " new [" .. Print.Expression(node.exp) .. "] " .. node.type
******0	  elseif (node.id == nodes_codes["NEGATE"]) then
******0	    str = str .. " not " .. Print.Expression(node.exp)
******0	  elseif (node.id == nodes_codes["UNARY"]) then
******0	    str = str .. " - " .. Print.Expression(node.exp)
******0	  elseif (node.id == nodes_codes["OPERATOR"]) then
******0	    str = str .. Print.Expression(node[1]) .. " " .. node.op .. " " .. Print.Expression(node[2])
******0	  elseif (node.id == nodes_codes["VALUE"]) then
******0	    str = str .. " " .. node.value
******0	  elseif (node.id == nodes_codes["CALL"]) then
******0	    str = str .. " " .. node.name .. "("
******0	    if (node.exps) then
******0	      str = str .. Print.Expression(node.exps[1])
******0	      if (node.exps[2]) then
******0	        for i = 2, #node.exps do
******0	          str = str .. ", " .. Print.Expression(node.exps[i])
       	        end
       	      end
       	    end
******0	    str = str .. ")"
******0	  elseif (node.id == nodes_codes["VAR"]) then
******0	    str = str .. " " .. node.name
******0	    if (node.array) then
******0	      for _, exp in ipairs(node.array) do
******0	        str = str .. "["
******0	        str = str .. Print.Expression(exp)
******0	        str = str .. "]"
       	      end
       	    end
       	  else
******0	    error("expression node error")
       	  end
******0	  return str..")"
       	end
       	
      5	function Print.Function (indent, t)
******0	  print(indent .. "FUN [" .. t.name .. "] @" .. t.line .. " {")
******0	  for _, node in ipairs(t.params) do
******0	    print(indent .. "  FUNC_PARAMETER [" .. node.name .. "] " .. node.type .. string.rep("[]", node.dimension))
       	  end
******0	  print(indent .. "  FUNC_RETURN " .. (t.ret_type or "VOID") .. string.rep("[]", t.ret_dimension or 0))
******0	  for _, node in ipairs(t.block) do
******0	    if (node.id == nodes_codes["DECLARE"]) then
******0	      Print.Declare(indent .. "  ", node)
******0	    elseif (node.id == nodes_codes["CALL"]) then
******0	      Print.Call(indent .. "  ", node)
******0	    elseif (node.id == nodes_codes["ATTRIBUTION"]) then
******0	      Print.ComandAttribution(indent .. "  ", node)
******0	    elseif (node.id == nodes_codes["IF"]) then
******0	      Print.ComandIf(indent .. "  ", node)
******0	    elseif (node.id == nodes_codes["RETURN"]) then
******0	      Print.ComandReturn(indent .. "  ", node)
******0	    elseif (node.id == nodes_codes["WHILE"]) then
******0	      Print.ComandWhile(indent .. "  ", node)
       	    end
       	  end
******0	  print(indent .. "}")
       	end
       	
      5	function Print.Program (indent, t)
******0	  print(indent .. "PROGRAM {")
******0	  for _, node in ipairs(t) do
******0	    if (node.id == nodes_codes["DECLARE"]) then
******0	      Print.Declare(indent .. "  ", node)
******0	    elseif (node.id == nodes_codes["FUNCTION"]) then
******0	      Print.Function(indent .. "  ", node)
       	    end
       	  end
******0	  print(indent .. "}")
       	end
       	
      5	function Print.Variable (indent, t)
******0	  local array_str = ""
******0	  for _, exp in ipairs(t.array) do
******0	    array_str = array_str .. "[" .. Print.Expression() .. "]"
       	  end
******0	  print(indent .. "ID [" .. t.name .. "] " .. array_str .. " @" .. t.line)
       	end
       	
       	
       	--==============================================================================
       	-- Initialize
       	--==============================================================================
       	
       	
       	
       	--==============================================================================
       	-- Public Methods
       	--==============================================================================
       	
       	--GetTree:
      5	function AbstractSyntaxTree.GetTree ()
       	  --return util.TableCopy(tree)
    187	  return tree
       	end
       	
       	--NewAttributionNode:
       	--  {
       	--    id    = $number - ATTRIBUTION code
       	--    exp   = $table  - EXPRESSION node
       	--    line  = $number - line number
       	--    var   = $table  - VAR node
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewAttributionNode (var, expression)
    444	  if (_DEBUG) then print("AST :: NewAttributionNode") end
    444	  local node = {
    444	    id    = nodes_codes["ATTRIBUTION"],
    444	    exp   = expression,
    444	    line  = var.line,
    444	    var   = var,
       	  }
    444	  return node
       	end
       	
       	--NewCallNode:
       	--  {
       	--    id    = $number - CALL code
       	--    line  = $number - line number
       	--    name  = $string - var name
       	--    exps  = $table  - list of EXPRESSION nodes
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewCallNode (line, name, expressions)
     86	  if (_DEBUG) then print("AST :: NewCallNode") end
     86	  local node = {
     86	    id   = nodes_codes["CALL"],
     86	    line = line,
     86	    name = name,
     86	    exps = expressions,
       	  }
     86	  return node
       	end
       	
       	--NewDeclVarNode:
       	--  {
       	--    id        = $number - DECLARE code
       	--    line      = $number - line number
       	--    name      = $string - var name
       	--    dimension = $number - var dimension
       	--    type      = $string - [bool, char, int, string]
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewDeclVarNode (line, name, typebase, size)
    224	  if (_DEBUG) then print("AST :: NewDeclVarNode") end
    224	  local node = {
    224	    id        = nodes_codes["DECLARE"],
    224	    line      = line,
    224	    name      = name,
    224	    dimension = size,
    224	    type      = typebase,
       	  }
    224	  return node
       	end
       	
       	--NewElseIfNode:
       	--  {
       	--    id    = $number - ELSEIF code
       	--    block = $table  - list of COMMANDS that will be executed if [cond] is true
       	--    cond  = $table  - EXPRESSION NODE, represents condition
       	--    line  = $number - line number
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewElseIfNode (line, condition, block)
     36	  if (_DEBUG) then print("AST :: NewElseIfNode") end
     36	  local node = {
     36	    id          = nodes_codes["ELSEIF"],
     36	    block       = block,
     36	    cond        = condition,
     36	    line        = line,
       	  }
     36	  return node
       	end
       	
       	--NewFunctionNode:
       	--  {
       	--    id            = $number - FUNCTION code
       	--    block         = $table  - list of COMMANDS that will be executed
       	--    line          = $number - line number
       	--    name          = $string - var name
       	--    params        = $table  - list of PARAMETER nodes
       	--    ret_type      = $string - [bool, char, int, string], represents function return type
       	--    ret_dimension = $number - function return dimension
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewFunctionNode (line, name, parameters, return_type, return_size, block)
    284	  if (_DEBUG) then print("AST :: NewFunctionNode") end
    284	  local node = {
    284	    id            = nodes_codes["FUNCTION"],
    284	    line          = line,
    284	    name          = name,
    284	    params        = parameters,
    284	    ret_type      = return_type,
    284	    ret_dimension = return_size,
    284	    block         = block,
       	  }
    284	  return node
       	end
       	
       	--NewIfNode:
       	--  {
       	--    id      = $number - IF code
       	--    block   = $table  - list of COMMANDS that will be executed if [cond] is true
       	--    cond    = $table  - EXPRESSION NODE, represents condition
       	--    else    = $table  - list of COMMANDS that will be executed none conditions are true
       	--    elseif  = $table  - list of ELSEIF nodes
       	--    line    = $number - line number
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewIfNode (line, condition, block, elseif_node, else_block)
     82	  if (_DEBUG) then print("AST :: NewIfNode") end
     82	  local node = {
     82	    id          = nodes_codes["IF"],
     82	    block       = block,
     82	    cond        = condition,
     82	    ["else"]    = else_block,
     82	    ["elseif"]  = elseif_node,
     82	    line        = line,
       	  }
     82	  return node
       	end
       	
       	--NewNegateNode:
       	--  {
       	--    id    = $number - NEGATE code
       	--    exp   = $table  - EXPRESSION node
       	--    line  = $number - line number
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewNegateNode (line, expression)
     53	  if (_DEBUG) then print("AST :: NewNegateNode") end
     53	  local node = {
     53	    id    = nodes_codes["NEGATE"],
     53	    exp   = expression,
     53	    line  = line,
       	  }
     53	  return node
       	end
       	
       	--NewNewVarNode:
       	--  {
       	--    id        = $number - NEWVAR code
       	--    dimension = $number - var dimension
       	--    exp       = $table  - EXPRESSION node
       	--    line      = $number - line number
       	--    type      = $string - [bool, char, int, string]
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewNewVarNode (line, expression, type, dimension)
     33	  if (_DEBUG) then print("AST :: NewNewVarNode") end
     33	  local node = {
     33	    id        = nodes_codes["NEWVAR"],
     33	    dimension = dimension,
     33	    exp       = expression,
     33	    line      = line,
     33	    type      = type,
       	  }
     33	  return node
       	end
       	
       	--NewOperatorNode:
       	--  {
       	--    id    = $number - OPERATOR code
       	--    line  = $number - line number
       	--    op    = $string - [and or + - * / > < >= <= = <>], one of possible operations
       	--    [1]   = $table  - EXPRESSION node, left side of operator
       	--    [2]   = $table  - EXPRESSION node, right side of operator
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewOperatorNode (line, left, operator, right)
    479	  if (_DEBUG) then print("AST :: NewOperatorNode") end
    479	  local node = {
    479	    id    = nodes_codes["OPERATOR"],
    479	    line  = line,
    479	    op    = operator,
    479	    left,
       	    right,
    479	  }
    479	  return node
       	end
       	
       	--NewParameterNode:
       	--  {
       	--    id        = $number - PARAMETER code
       	--    dimension = $number - var dimension
       	--    line      = $number - line number
       	--    name      = $string - var name
       	--    type      = $string - [bool, char, int, string]
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewParameterNode (line, name, typebase, size)
    136	  if (_DEBUG) then print("AST :: NewProgramNode") end
    136	  local node = {
    136	    id        = nodes_codes["PARAMETER"],
    136	    line      = line,
    136	    name      = name,
    136	    dimension = size,
    136	    type      = typebase,
       	  }
    136	  return node
       	end
       	
       	--NewParenthesisNode:
       	--  {
       	--    id    = $number - PARENTHESIS code
       	--    exp   = $table  - EXPRESSION node
       	--    line  = $number - line number
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewParenthesisNode (line, expression)
******0	  if (_DEBUG) then print("AST :: NewParenthesisNode") end
******0	  local node = {
       	    id    = nodes_codes["PARENTHESIS"],
       	    exp   = expression,
       	    line  = line,
       	  }
******0	  return node
       	end
       	
       	--NewProgramNode:
       	--  {
       	--    id       = $number - PROGRAM code
       	--    [1 to N] = DECLARE or FUNCTION node
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewProgramNode (ast_tree)
    187	  if (_DEBUG) then print("AST :: NewProgramNode") end
    187	  tree = {}
    187	  tree = util.TableCopy(ast_tree)
    187	  tree.id = nodes_codes["PROGRAM"]
    187	  if (printTree) then AbstractSyntaxTree.Print() end
       	end
       	
       	--NewReturnNode:
       	--  {
       	--    id    = $number - RETURN code
       	--    line  = $number - line number
       	--    exp   = $table  - EXPRESSION node
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewReturnNode (line, expression)
     84	  if (_DEBUG) then print("AST :: NewReturnNode") end
     84	  local node = {
     84	    id    = nodes_codes["RETURN"],
     84	    exp   = expression,
     84	    line  = line,
       	  }
     84	  return node
       	end
       	
       	--NewUnaryNode:
       	--  {
       	--    id    = $number - UNARY code
       	--    exp   = $table  - EXPRESSION node
       	--    line  = $number - line number
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewUnaryNode (line, expression)
     30	  if (_DEBUG) then print("AST :: NewUnaryNode") end
     30	  local node = {
     30	    id    = nodes_codes["UNARY"],
     30	    exp   = expression,
     30	    line  = line,
       	  }
     30	  return node
       	end
       	
       	--NewValueNode:
       	--  {
       	--    id    = $number   - VALUE code
       	--    line  = $number - line number
       	--    type  = $string   - [bool, char, int, string]
       	--    value = $string   - if type == char or string,
       	--            $number   - if type == int,
       	--            $boolean  - if type == bool,
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewValueNode (line, type, value)
    625	  if (_DEBUG) then print("AST :: NewValueNode") end
    625	  local node = {
    625	    id    = nodes_codes["VALUE"],
    625	    line  = line,
    625	    type  = type,
    625	    value = value,
       	  }
    625	  return node
       	end
       	
       	--NewVarNode:
       	--  {
       	--    id    = $number - VAR code
       	--    array = $table  - list of EXPRESSIONS, one for each dimension
       	--    line  = $number - line number
       	--    name  = $string - var name
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewVarNode (line, name, array)
   1145	  if (_DEBUG) then print("AST :: NewVarNode") end
   1145	  local node = {
   1145	    id    = nodes_codes["VAR"],
   1145	    line  = line,
   1145	    name  = name,
   1145	    array = array,
       	  }
   1145	  return node
       	end
       	
       	--NewWhileNode:
       	--  {
       	--    id    = $number - WHILE code
       	--    block = $table  - list of COMMANDS that will be executed if [cond] is true
       	--    cond  = $table  - EXPRESSION node, represents condition
       	--    line  = $number - line number
       	--  }
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.NewWhileNode (line, condition, block)
     21	  if (_DEBUG) then print("AST :: NewWhileNode") end
     21	  local node = {
     21	    id    = nodes_codes["WHILE"],
     21	    block = block,
     21	    cond  = condition,
     21	    line  = line,
       	  }
     21	  return node
       	end
       	
       	--Print: Print Abstract Syntax Tree with comprehensible format
       	--  parameters:
       	--  return:
      5	function AbstractSyntaxTree.Print ()
******0	  if (_DEBUG) then print("AST :: Print") end
******0	  Print.Program("", tree)
       	end
       	
       	
       	--==============================================================================
       	-- Return
       	--==============================================================================
       	
      5	return AbstractSyntaxTree

==============================================================================
src/auto_test.lua
==============================================================================
       	--==============================================================================
       	-- Global Defines
       	--==============================================================================
       	
      5	_DEBUG = false
      4	local printFailMessage = false
       	
       	
       	--==============================================================================
       	-- Dependency
       	--==============================================================================
       	
      5	require "lib/util"
      5	local Lexical   = require "src/lexical"
      5	local Syntactic = require "src/syntactic"
      4	local Semantic  = require "src/semantic"
       	
       	
       	--==============================================================================
       	-- Data Structure
       	--==============================================================================
       	
      4	local files = {
      1	  {
      5	    name      = "nil_file",
      5	    open      = false,
      4	  },
      1	  {
      5	    name      = "lex_fail",
      5	    open      = true,
      5	    lexical   = false,
      5	  },
       	  {
      5	    name      = "lex_overload_01",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = false,
      5	  },
       	  {
      5	    name      = "lex_overload_02",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = false,
      5	  },
       	  {
      5	    name      = "lex_overload_03",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = false,
      5	  },
       	  {
      5	    name      = "lex_overload_04",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = false,
      5	  },
      1	  {
      4	    name      = "sem_complete_program",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = true,
      5	  },
      1	  {
      4	    name      = "sem_elseif_block",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = true,
      5	  },
      1	  {
      4	    name      = "sem_fail_attrib_string_char",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      4	    name      = "sem_fail_attrib_char_string",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      4	    name      = "sem_fail_attrib_int_bool",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      4	    name      = "sem_fail_call_not_function",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      4	    name      = "sem_fail_call_wrong_param_number",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      4	    name      = "sem_fail_declare_same_name_01",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      4	    name      = "sem_fail_declare_same_name_02",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  }, 
      1	  {
      4	    name      = "sem_fail_elseif_condition",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      4	    name      = "sem_fail_func_ret_dimension_different",
      4	    open      = true,
      4	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      5	    name      = "sem_fail_func_ret_nil",
      4	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      5	    name      = "sem_fail_func_ret_type_different",
      4	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      5	    name      = "sem_fail_func_same_par_name",
      4	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      5	    name      = "sem_fail_func_void_return",
      4	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      5	    name      = "sem_fail_if_condition_int",
      4	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      5	    name      = "sem_fail_var_array_bool",
      4	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      5	    name      = "sem_fail_var_array_dimension_zero",
      4	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      4	    name      = "sem_fail_var_array_larger",
      3	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      2	  {
      3	    name      = "sem_fail_var_existent",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      4	    name      = "sem_fail_var_undeclared",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      4	  },
       	
       	
      2	  {
      5	    name      = "00-fail-empty",
      5	    open      = true,
      5	    lexical   = true,
      4	    syntactic = false,
      5	  },
      1	  {
      5	    name      = "01-global",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      4	    semantic  = true,
      5	  },
      1	  {
      5	    name      = "02-fun",
      5	    open      = true,
      5	    lexical   = true,
      4	    syntactic = true,
      5	    semantic  = true,
      5	  },
      1	  {
      5	    name      = "03-nls",
      5	    open      = true,
      5	    lexical   = true,
      4	    syntactic = true,
      5	    semantic  = false,
      5	  },
      1	  {
      5	    name      = "04-funglobal",
      5	    open      = true,
      4	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = true,
      5	  },
      1	  {
      5	    name      = "05-params",
      5	    open      = true,
      4	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      4	  },
      2	  {
      5	    name      = "06-declvar",
      5	    open      = true,
      4	    lexical   = true,
      5	    syntactic = true,
      4	    semantic  = false,
      5	  },
      2	  {
      5	    name      = "07-if",
      4	    open      = true,
      5	    lexical   = true,
      4	    syntactic = true,
      5	    semantic  = false,
      5	  },
      2	  {
      5	    name      = "08-fail-else",
      4	    open      = true,
      5	    lexical   = true,
      4	    syntactic = false,
      5	  },
      2	  {
      5	    name      = "09-fail-elseif",
      4	    open      = true,
      5	    lexical   = true,
      5	    syntactic = false,
      4	  },
      2	  {
      5	    name      = "10-fail-if",
      5	    open      = true,
      4	    lexical   = true,
      5	    syntactic = false,
      4	  },
      2	  {
      5	    name      = "11-ifdecl",
      5	    open      = true,
      5	    lexical   = true,
      4	    syntactic = true,
      5	    semantic  = false,
      4	  },
      2	  {
      5	    name      = "12-while",
      5	    open      = true,
      5	    lexical   = true,
      4	    syntactic = true,
      4	    semantic  = false,
      5	  },
      2	  {
      5	    name      = "13-fail-while",
      5	    open      = true,
      5	    lexical   = true,
      4	    syntactic = false,
      4	  },
      2	  {
      5	    name      = "14-ifwhile",
      5	    open      = true,
      5	    lexical   = true,
      4	    syntactic = true,
      5	    semantic  = true,
      4	  },
      2	  {
      5	    name      = "15-fail-ifwhile",
      5	    open      = true,
      4	    lexical   = true,
      5	    syntactic = false,
      4	  },
      2	  {
      5	    name      = "16-atrib",
      5	    open      = true,
      4	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = true,
      4	  },
      2	  {
      5	    name      = "17-call",
      4	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      4	    semantic  = true,
      5	  },
      2	  {
      4	    name      = "18-fail-call",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = false,
      4	  },
      2	  {
      4	    name      = "19-callargs",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = false,
      4	  },
      1	  {
      5	    name      = "19-fail-callargs",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = false,
      5	  },
       	  {
      5	    name      = "20-return",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      5	    semantic  = true,
      4	  },
      1	  {
      5	    name      = "21-arrays",
      5	    open      = true,
      5	    lexical   = true,
      5	    syntactic = true,
      4	    semantic  = true,
      4	  },
      2	  {
      5	    name      = "21-return-noargs",
      5	    open      = true,
      5	    lexical   = true,
      4	    syntactic = true,
      4	    semantic  = false,
      5	  },
      2	  {
      5	    name      = "22-exp",
      5	    open      = true,
      4	    lexical   = true,
      4	    syntactic = true,
      5	    semantic  = false,
      5	  },
      2	  {
      5	    name      = "22-fail-exp",
      4	    open      = true,
      4	    lexical   = true,
      5	    syntactic = false,
      5	  },
      2	  {
      5	    name      = "23-fail-fun",
      5	    open      = true,
      3	    lexical   = true,
      5	    syntactic = false,
      5	  },
      2	  {
      5	    name      = "24-fail-fun2",
      5	    open      = true,
      3	    lexical   = true,
      5	    syntactic = false,
      5	  },
      2	  {
      5	    name      = "25-fail-fun3",
      5	    open      = true,
      3	    lexical   = true,
      5	    syntactic = false,
      4	  },
      1	  {
      4	    name      = "26-fail-fun4",
      4	    open      = true,
      3	    lexical   = true,
      4	    syntactic = false,
      4	  },
      2	  {
      5	    name      = "27-fail-global",
     62	    open      = true,
     60	    lexical   = true,
      4	    syntactic = false,
     62	  },
     58	  {
     61	    name      = "28-fail-block",
     61	    open      = true,
      3	    lexical   = true,
      4	    syntactic = false,
      4	  },
     58	  {
     61	    name      = "29-fail-params",
     61	    open      = true,
      3	    lexical   = true,
      4	    syntactic = false,
     61	  },
      1	  {
      4	    name      = "30-fail-param",
     61	    open      = true,
      4	    lexical   = true,
      4	    syntactic = false,
     60	  },
     57	  {
      4	    name      = "31-fail-type",
      4	    open      = true,
      3	    lexical   = true,
      4	    syntactic = false,
      4	  },
     58	  {
     60	    name      = "32-fail-declvar",
     60	    open      = true,
      4	    lexical   = true,
      3	    syntactic = false,
     60	  },
      1	  {
      4	    name      = "33-fail-missingexp",
     60	    open      = true,
      4	    lexical   = true,
      3	    syntactic = false,
      4	  },
      1	  {
      4	    name      = "34-fail-invalidexp",
      4	    open      = true,
     61	    lexical   = true,
     59	    syntactic = false,
     60	  },
       	  {
      3	    name      = "35-expprio",
     59	    open      = true,
      3	    lexical   = true,
      3	    syntactic = true,
     59	    semantic  = false,
     29	  },
      1	  {
      4	    name      = "36-fail-roottoken",
     69	    open      = true,
     68	    lexical   = true,
      3	    syntactic = false,
    126	  },
     95	  {
     98	    name      = "37-invprio",
     68	    open      = true,
     68	    lexical   = true,
     33	    syntactic = true,
      3	    semantic  = false,
******0	  },
     98	}
       	
       	
       	--==============================================================================
       	-- Private Methods
       	--==============================================================================
       	
       	local function Run ()
    125	  local num_files = 0
      4	  local num_files_read = 1
    265	  for _, _ in pairs (files) do
    204	    num_files = num_files + 1
       	  end
    271	  for _, valid in ipairs (files) do
       	    local file_str                  --  keeps the convertion of file to string
    204	    local unexpected_error = false  --  inform that an unexpected error occurs (if true stop further tests)
    204	    local expected_error = false    --  inform that an expected error occurs (if true stop further tests)
       	    local ok, msg
       	
       	    -- TEST OPENING
       	    ------------------------------------------------
    268	    if (not unexpected_error and not expected_error) then
    205	      local f = io.open("data/" .. valid.name .. ".txt", "r")
    204	      if (not f and valid.open) then
     64	        unexpected_error = true
******0	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to open.', num_files_read, num_files, valid.name))
    204	      elseif (f and not valid.open) then
     64	        unexpected_error = true
      1	        print(string.format('(%2s de %2s) FAILURE - File "%s" not expected to open.', num_files_read, num_files, valid.name))
    204	      elseif (not f and not valid.open) then
      3	        expected_error = true
      3	        msg = "File could not be opened"
       	      else
    201	        file_str = f:read("*a")
    266	        f:close()
       	      end
       	    end
       	    
       	    -- TEST LEXICAL
       	    ------------------------------------------------
    204	    if (not unexpected_error and not expected_error) then
    201	      ok, msg = Lexical.Open(file_str)
    264	      if (not ok and valid.lexical) then
     26	        unexpected_error = true
******0	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to PASS on lexical. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
    201	      elseif (ok and not valid.lexical) then
******0	        unexpected_error = true
******0	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to FAIL on lexical. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
    201	      elseif (not ok and not valid.lexical) then
     68	        expected_error = true
       	      end
       	    end
       	    
       	    -- TEST SYNTAX
       	    ------------------------------------------------
    204	    if (not unexpected_error and not expected_error) then
    198	      ok, msg = Syntactic.Open(Lexical.GetTags())
    235	      if (not ok and valid.syntactic) then
     29	        unexpected_error = true
******0	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to PASS on syntactic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
    198	      elseif (ok and not valid.syntactic) then
******0	        unexpected_error = true
******0	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to FAIL on syntactic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
    198	      elseif (not ok and not valid.syntactic) then
    143	        expected_error = true
       	      end
       	    end
       	    
       	    -- TEST SEMANTIC
       	    ------------------------------------------------
    269	    if (not unexpected_error and not expected_error) then
    120	      ok, msg = Semantic.Open(Syntactic.GetTree())
    122	      if (not ok and valid.semantic) then
******0	        unexpected_error = true
******0	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to PASS on semantic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
    120	      elseif (ok and not valid.semantic) then
******0	        unexpected_error = true
******0	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to FAIL on semantic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
    120	      elseif (not ok and not valid.semantic) then
     92	        expected_error = true
       	      end
       	    end
       	    
       	    -- PASSED ALL TESTS
       	    ------------------------------------------------
    204	    if (not unexpected_error or expected_error) then
    204	      print(string.format('(%2s de %2s) SUCCESS - File "%s".', num_files_read, num_files, valid.name))
    204	      if (expected_error and printFailMessage) then
******0	        print("    ", msg)
       	      end
       	    end
    204	    num_files_read = num_files_read + 1
       	  end
       	end
       	
       	
       	--==============================================================================
       	-- Running
       	--==============================================================================
       	
      6	local ok, msg = pcall(function () Run() end)
      3	if (not ok) then
******0	  print("Erro inesperado no teste automático. " .. msg)
       	end

==============================================================================
Summary
==============================================================================

31	5	86.11%	./lib/lulex.lua
23	5	82.14%	./lib/node_codes.lua
51	1	98.08%	./lib/token_codes.lua
23	100	18.70%	./lib/util.lua
346	10	97.19%	./src/grammar.lua
176	1	99.44%	./src/lexical.lua
18	0	100.00%	./src/parser.lua
230	28	89.15%	./src/semantic.lua
54	4	93.10%	./src/symbol_table.lua
17	2	89.47%	./src/syntactic.lua
156	114	57.78%	./src/syntax_tree.lua
491	14	97.23%	src/auto_test.lua
------------------------
1616	284	85.05%	
