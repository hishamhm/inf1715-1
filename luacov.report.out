
==============================================================================
./lib/lulex.lua
==============================================================================
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      16	local Lulex = {}
        	
        	local rex_ok, rex
        	
      32	for _, flavor in ipairs{"gnu", "pcre", "tre", "posix", "oniguruma"} do
      32	   rex_ok, rex = pcall(require, "rex_"..flavor)
      32	   if rex_ok then
      16	      break
        	   end
        	end
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	local function Lua_match(rule, input, at)
        	   --if (_DEBUG) then print("Lul :: Lua_match") end
*******0	   local match = string.match(input, "^"..rule[1], at)
*******0	   if match then
*******0	      return at + #match
        	   end
        	end
        	
        	local function Re_match(rule, input, at)
        	   --if (_DEBUG) then print("Lul :: Re_match") end
 2144152	   if not rule.pat then
     688	      rule.pat = rex.new("^"..rule[1])
        	   end
 2144152	   local start, finish = rule.pat:find(input:sub(at))
 2144152	   if start then
  110361	      return at+(finish-start)+1
        	   end
        	end
        	
        	local function Run(self, input)
        	   --if (_DEBUG) then print("Lul :: Run") end
    1081	   local at = 1
   50945	   while at <= #input do
   49864	      local lrule = nil
   49864	      local llen = 0
 2194016	      for _, rule in ipairs(self.rules) do
 2144152	         local found = self.match(rule, input, at)
 2144152	         if found then
  110361	            local len = found - at
  110361	            if len > llen then
   50370	               llen = len
   50370	               lrule = rule
        	            end
        	         end
        	      end
   49864	      if lrule then
   49864	         lrule[2](input:sub(at, at+llen-1))
   49864	         at = at + llen
        	      else
*******0	         io.write(input:sub(at, at))
*******0	         at = at + 1
        	      end
        	   end
        	end
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
      16	function Lulex.New(rules, use_lua)
        	   --if (_DEBUG) then print("Lul :: New") end
      16	   return {
      16	      match = (use_lua or not rex_ok) and Lua_match or Re_match,
      16	      rules = rules,
      16	      run = Run,
      16	   }
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      16	return Lulex

==============================================================================
./lib/node_codes.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      16	local Nodes = {}
        	
        	-- code of each node
        	--  {
        	--    ["node id"] = $number,
        	--  }
      16	local codes = {
      16	  ["ATTRIBUTION"] = 01,
      16	  ["CALL"]        = 02,
      16	  ["DECLARE"]     = 03,
      16	  ["ELSEIF"]      = 04,
      16	  ["FUNCTION"]    = 05,
      16	  ["IF"]          = 06,
      16	  ["NEGATE"]      = 07,
      16	  ["NEWVAR"]      = 08,
      16	  ["OPERATOR"]    = 09,
      16	  ["PARAMETER"]   = 10,
      16	  ["PARENTHESIS"] = 11,
      16	  ["PROGRAM"]     = 12,
      16	  ["RETURN"]      = 13,
      16	  ["UNARY"]       = 14,
      16	  ["VALUE"]       = 15,
      16	  ["VAR"]         = 16,
      16	  ["WHILE"]       = 17,
        	}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
      16	function Nodes.GetNodesList ()
      59	  return codes
        	end
        	
      16	function Nodes.GetNodeName (node_code)
*******0	  assert(type(node_code) == "number")
*******0	  for name, code in pairs(codes) do
*******0	    if (code == node_code) then
*******0	      return name
        	    end
        	  end
*******0	  return nil
        	end
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      16	return Nodes

==============================================================================
./lib/token_codes.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      16	local Tokens = {}
        	
        	-- code of each token
        	--  {
        	--    ["token id"] = $number,
        	--  }
      16	local codes = {
      16	  COMMENT_LINE  = 610,
      16	  COMMENT_BLOCK = 620,
      16	  K_IF          = 101,
      16	  K_THEN        = 102,
      16	  K_ELSE        = 103,
      16	  K_WHILE       = 104,
      16	  K_LOOP        = 105,
      16	  K_FUN         = 106,
      16	  K_RETURN      = 107,
      16	  K_NEW         = 108,
      16	  K_STRING      = 109,
      16	  K_INT         = 110,
      16	  K_CHAR        = 111,
      16	  K_BOOL        = 112,
      16	  K_TRUE        = 113,
      16	  K_FALSE       = 114,
      16	  K_AND         = 115,
      16	  K_OR          = 116,
      16	  K_NOT         = 117,
      16	  K_END         = 118,
      16	  STRING        = 200,
      16	  NUMBER        = 300,
      16	  ["OP_("]      = 401,
      16	  ["OP_)"]      = 402,
      16	  ["OP_,"]      = 403,
      16	  ["OP_:"]      = 404,
      16	  ["OP_>"]      = 405,
      16	  ["OP_<"]      = 406,
      16	  ["OP_>="]     = 407,
      16	  ["OP_<="]     = 408,
      16	  ["OP_="]      = 409,
      16	  ["OP_<>"]     = 410,
      16	  ["OP_["]      = 411,
      16	  ["OP_]"]      = 412,
      16	  ["OP_+"]      = 413,
      16	  ["OP_-"]      = 414,
      16	  ["OP_*"]      = 415,
      16	  ["OP_/"]      = 416,
      16	  LINE_END      = 500,
      16	  ID            = 800,
      16	  ERROR         = 000,
        	}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
      16	function Tokens.GetTokensList ()
      32	  return codes
        	end
        	
      16	function Tokens.GetTokenName (token_code)
     352	  assert(type(token_code) == "number")
    9280	  for name, code in pairs(codes) do
    9280	    if (code == token_code) then
     352	      return name
        	    end
        	  end
*******0	  return nil
        	end
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      16	return Tokens

==============================================================================
./lib/util.lua
==============================================================================
        	--==============================================================================
        	-- Class Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Class Implementation
        	--==============================================================================
        	
      16	util = {}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--FileExists()
        	--  parameters:
        	--    [1] $string  [file path and name including extension to be evaluated]
        	--  return:
        	--    [1] $boolean [true if file exists, false otherwise]
      32	function util.FileExists(file)
*******0	  if (file == nil or type(file) ~= "string" or file == "") then
*******0	    return false
        	  end
*******0	  local f, msg = io.open(file, "r")
*******0	  if (f == nil) then
*******0	    return false
        	  end
*******0	  f:close()
*******0	  return true
        	end
        	
        	--FileToTable()
        	--  parameters:
        	--    [1] 
        	--  return:
        	--    [1] 
      32	function util.FileToTable(file)
*******0	  if (file == nil or type(file) ~= "string" or file == "") then
*******0	    return false, "Parameter 'file' is invalid"
        	  end
*******0	  local f = io.open(file, "r")
*******0	  if (f == nil) then
*******0	    return false, "Could not open desired file"
        	  end
*******0	  local t = FileToTableAux(f, {})
*******0	  f:close()
*******0	  if (t and type(t) == "table") then
*******0	    return true, t
        	  end
*******0	  return false, {}
        	end
        	
        	--StringIsNull()
        	--  parameters:
        	--    [1] $string  [string that is going to be evaluated]
        	--  return:
        	--    [1] $boolean [true if string is null]
      32	function util.StringIsNull(str)
*******0	  return (str == nil or str == "")
        	end
        	
        	--TableCopy()
        	--  parameters:
        	--    [1] $table [table that is going to be duplicated]
        	--  return:
        	--    [1] $table [copy of incoming table]
      32	function util.TableCopy(t)
   22072	  if (not t or type(t) ~= "table") then
*******0	    return
        	  end
   22072	  local ret = {}
   22072	  local mt = getmetatable(t)
   22072	  if mt then
*******0	    setmetatable(ret, mt)
        	  end
   88534	  for k,v in pairs(t) do
   66462	    v = rawget(t, k)
   66462	    if type(v)== "table" then
   19079	      rawset(ret, k, util.TableCopy(v))
        	    else
   47383	      rawset(ret, k, v)
        	    end
        	  end
   22072	  return ret
        	end
        	
        	--TableGetChanges()
        	--  required:
        	--    [1] $table [old table]
        	--    [2] $table [new table]
        	--  return:
        	--    [1] $table [fields that have been modified from old_table to new_table]
      32	function util.TableGetChanges(old_table, new_table)
*******0	  if not old_table or not new_table then 
*******0	    return 
        	  end
*******0	  local changes = {}
*******0	  for k, v in pairs(old_table) do
*******0	    if type(v) == "table" then
*******0	      changes[k] = utils.GetTableChanges(v, new_table[k])
        	    else
*******0	      if new_table[k] ~= nil and new_table[k] ~= v then
*******0	        changes[k] = new_table[k]
        	      end
        	    end
        	  end
*******0	  if next(changes) then
*******0	    return changes
        	  end
        	end
        	
        	--TableIsEmpty()
        	--  parameters:
        	--    [1] $table   [table that is going to be valuated]
        	--  return:
        	--    [1] $boolean [true if table is empty, false otherwise]
      32	function util.TableIsEmpty (t)
*******0	  assert(type(t) == "table")
*******0	  for _, _ in pairs(t) do
*******0	    return false
        	  end
*******0	  return true
        	end
        	
        	--TablePrint()
        	--  parameters:
        	--    [1] $table [table that is going to be printed]
      32	function util.TablePrint (t)
*******0	  if (not t) then
*******0	    return
        	  end
*******0	  print(TablePrintAux("", t, ""))
        	end
        	
        	--TableToFile()
        	--  parameters:
        	--    [1] $table  [table that is going to be printed]
        	--  return:
        	--    [1] $string [string of copied table]
      32	function util.TableToFile (file, t)
*******0	  if (file == nil or type(file) ~= "string" or file == "") then
*******0	    return false, "Parameter 'file' is invalid"
        	  end
*******0	  local f = io.open(file, "w")
*******0	  if (f == nil) then
*******0	    return false, "Could not open desired file"
        	  end
*******0	  if (not t) then
*******0	    return
        	  end
*******0	  TableToFileAux(f, "", t, "")
*******0	  f:close()
*******0	  return true
        	end
        	
        	--TableToString()
        	--  parameters:
        	--    [1] $table  [table that is going to be printed]
        	--  return:
        	--    [1] $string [string of copied table]
      32	function util.TableToString (t)
*******0	  if (not t) then
*******0	    return
        	  end
*******0	  return TablePrintAux("", t, "")
        	end
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
      16	function FileToTableAux(file, t)
*******0	  local str = file:read()
*******0	  while (str) do
*******0	    if (string.find(str, '%["([^"]+)"%] = {')) then
*******0	      local _, _, field = string.find(str, '%["([^"]+)"%] = {')
*******0	      t[field] = FileToTableAux(file, {})
*******0	    elseif (string.find(str, '%[([^%]]+)%] = {')) then
*******0	      local _, _, n = string.find(str, '%[([^%]]+)%] = {')
*******0	      n = tonumber(n)
*******0	      t[n] = FileToTableAux(file, {})
*******0	    elseif (string.find(str, '%["([^"]+)"%]%s%=%s"([^"]+)"')) then
*******0	      local _, _, field, value = string.find(str, '%["([^"]+)"%]%s%=%s"([^"]+)"')
*******0	      t[field] = value
*******0	    elseif (string.find(str, '%[([^%]]+)%]%s%=%s"([^"]+)"')) then
*******0	      local _, _, n, value = string.find(str, '%[([^%]]+)%]%s%=%s"([^"]+)"')
*******0	      n = tonumber(n)
*******0	      t[n] = value
*******0	    elseif (string.find(str, "}")) then
*******0	      return t
        	    end
*******0	    str = file:read()
        	  end
        	end
        	
      16	function TablePrintAux (s, t, indent)
*******0	  s = s .. "{\n"
*******0	  local oldindent = indent
*******0	  indent = indent .. "  "
*******0	  for k, v in pairs(t) do
*******0	    if (type(k) == "string") then
*******0	      s = s .. indent .. "[" .. string.format("%q", k) .. "] = "
*******0	    elseif (type(k) == "number") then
*******0	      s = s .. indent .. "[" .. k .. "] = "
        	    end
*******0	    if (type(v) == "table") then
*******0	      s = TablePrintAux(s, v, indent)
*******0	    elseif (type(v) == "string") then
*******0	      s = s .. string.format("%q", v)
        	    else
*******0	      s = s .. tostring(v)
        	    end
*******0	    s = s .. ",\n"
        	  end
*******0	  s = s .. oldindent .. "}"
*******0	  return s
        	end
        	
      16	function TableToFileAux (file, s, t, indent)
*******0	  file:write("{\n")
*******0	  local oldindent = indent
*******0	  indent = indent .. "  "
*******0	  for k, v in pairs(t) do
*******0	    if (type(k) == "string") then
*******0	      file:write(indent .. "[" .. string.format("%q", k) .. "] = ")
*******0	    elseif (type(k) == "number") then
*******0	      file:write(indent .. "[" .. k .. "] = ")
        	    end
*******0	    if (type(v) == "table") then
*******0	      s = TableToFileAux(file, s, v, indent)
*******0	    elseif (type(v) == "string") then
*******0	      file:write(string.format("%q", v))
        	    else
*******0	      file:write(tostring(v))
        	    end
*******0	    file:write(",\n")
        	  end
*******0	  file:write(oldindent .. "}")
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	

==============================================================================
./lib/util_tree.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      11	local NodesClass  = require "lib/node_codes"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      11	local Print = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
      11	local nodes_codes = NodesClass.GetNodesList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
      11	function Print.Block (indent, t)
      17	  if (t) then
      42	    for _, node in ipairs(t) do
      25	      if (node.id == nodes_codes["ATTRIBUTION"]) then
      11	        Print.ComandAttribution(indent, node)
      14	      elseif (node.id == nodes_codes["IF"]) then
       1	        Print.ComandIf(indent, node)
      13	      elseif (node.id == nodes_codes["RETURN"]) then
       5	        Print.ComandReturn(indent, node)
       8	      elseif (node.id == nodes_codes["WHILE"]) then
       2	        Print.ComandWhile(indent, node)
       6	      elseif (node.id == nodes_codes["DECLARE"]) then
       2	        Print.Declare(indent, node)
       4	      elseif (node.id == nodes_codes["CALL"]) then
       4	        Print.Call(indent, node)
        	      --elseif (node.id == nodes_codes["VAR"]) then
        	        --Print.Variable(indent, node)
        	      else
*******0	        error("block node error")
        	      end
        	    end
        	  end
        	end
        	
      11	function Print.Call (indent, t)
       4	  print(indent .. "CALL [" .. t.name .. "] @" .. t.line .. "  {")
       6	  for _, node in ipairs(t.exps) do
       2	    print(indent .. "  PARAM " .. Print.Expression(node))
        	  end
       4	  local str = indent .. "}"
       4	  if (t.sem_type and t.sem_dimension) then
       3	    str = str .. string.format(" #%s:%d", t.sem_type, t.sem_dimension)
        	  end
       4	  print(str)
        	end
        	
      11	function Print.ComandAttribution (indent, t)
      23	  print(indent .. "ATRIB @" .. t.line .. " {")
      23	  local str = ""
      23	  str = str .. t.var.name
      23	  if (t.var.array) then
      30	    for _, exp in ipairs(t.var.array) do
       7	      str = str .. "[" .. Print.Expression(exp) .. "]"
        	    end
        	  end
      23	  Print.Variable(indent .. "  ", t.var)
        	
      23	  print(indent .. "  =" .. Print.Expression(t.exp))
      23	  print(indent .. "}")
        	end
        	
      11	function Print.ComandElseIf (indent, t)
       2	  print(indent .. "ELSEIF [" .. Print.Expression(t.cond) .. "] @" .. t.line)
       2	  Print.Block(indent .. "  ", t.block)
        	end
        	
      11	function Print.ComandIf (indent, t)
       6	  print(indent .. "IF [" .. Print.Expression(t.cond) .. "] @" .. t.line .. " {")
       6	  Print.Block(indent .. "  ", t.block)
       6	  if (t["elseif"]) then
       8	    for _, elseif_node in ipairs(t["elseif"]) do
       2	      Print.ComandElseIf(indent, elseif_node)
        	    end
        	  end
       6	  if (t["else"]) then
       5	    print(indent .. "ELSE ")
       5	    Print.Block(indent .. "  ", t["else"])
        	  end
       6	  print(indent .. "}")
        	end
        	
      11	function Print.ComandReturn (indent, t)
       8	  print(indent .. "RETURN @" .. t.line .. " {")
       8	  print(indent .. "  " .. Print.Expression(t.exp))
       8	  print(indent .. "}")
        	  -- print(indent .. "RETURN [" .. Print.Expression(t.exp) .. "] @" .. t.line)
        	end
        	
      11	function Print.ComandWhile (indent, t)
       4	  print(indent .. "WHILE [" .. Print.Expression(t.cond) .. "] @" .. t.line .. " {")
       4	  Print.Block(indent .. "  ", t.block)
       4	  print(indent .. "}")
        	end
        	
      11	function Print.Declare (indent, t)
      24	  print(indent .. "DECLARE @" .. t.line .. "{")
      24	  print(indent .. "  ID [" .. t.name .. "] " .. t.type .. string.rep("[]", t.dimension) .. " @" .. t.line)
      24	  print(indent .. "}")
        	  -- print(indent .. "DECLARE [" .. t.name .. "] " .. t.type .. string.rep("[]", t.dimension) .. " @" .. t.line)
        	end
        	
      11	function Print.Expression (t)
     109	  local str = "("
     109	  if (not t) then
       7	    return ""
        	  end
     102	  if (t.id == nodes_codes["PARENTHESIS"]) then
*******0	    str = str .. " (" .. Print.Expression(t.exp) .. ")"
     102	  elseif (t.id == nodes_codes["NEWVAR"]) then
       3	    str = str .. " new [" .. Print.Expression(t.exp) .. "] " .. t.type
      99	  elseif (t.id == nodes_codes["NEGATE"]) then
       1	    str = str .. " not " .. Print.Expression(t.exp)
      98	  elseif (t.id == nodes_codes["UNARY"]) then
*******0	    str = str .. " - " .. Print.Expression(t.exp)
      98	  elseif (t.id == nodes_codes["OPERATOR"]) then
      22	    str = str .. Print.Expression(t[1]) .. " " .. t.op .. " " .. Print.Expression(t[2])
      76	  elseif (t.id == nodes_codes["VALUE"]) then
      44	    str = str .. " " .. t.value
      32	  elseif (t.id == nodes_codes["CALL"]) then
       2	    str = str .. " " .. t.name .. "("
       2	    if (t.exps) then
       2	      str = str .. Print.Expression(t.exps[1])
       2	      if (t.exps[2]) then
*******0	        for i = 2, #t.exps do
*******0	          str = str .. ", " .. Print.Expression(t.exps[i])
        	        end
        	      end
        	    end
       2	    str = str .. ")"
      30	  elseif (t.id == nodes_codes["VAR"]) then
      30	    str = str .. " " .. t.name
      30	    if (t.array) then
      30	      for _, exp in ipairs(t.array) do
*******0	        str = str .. "["
*******0	        str = str .. Print.Expression(exp)
*******0	        str = str .. "]"
        	      end
        	    end
        	  else
*******0	    error("expression node error")
        	  end
     102	  if (t.sem_type and t.sem_dimension) then
     102	    str = str .. string.format(" #%s:%d", t.sem_type, t.sem_dimension)
        	  end
     102	  return str .. ")"
        	end
        	
      11	function Print.Function (indent, t)
      15	  print(indent .. "FUN [" .. t.name .. "] @" .. t.line .. " {")
      22	  for _, node in ipairs(t.params) do
       7	    print(indent .. "  FUNC_PARAMETER [" .. node.name .. "] " .. node.type .. string.rep("[]", node.dimension))
        	  end
      15	  print(indent .. "  FUNC_RETURN " .. (t.ret_type or "VOID") .. string.rep("[]", t.ret_dimension or 0))
      45	  for _, node in ipairs(t.block) do
      30	    if (node.id == nodes_codes["DECLARE"]) then
       8	      Print.Declare(indent .. "  ", node)
      22	    elseif (node.id == nodes_codes["CALL"]) then
*******0	      Print.Call(indent .. "  ", node)
      22	    elseif (node.id == nodes_codes["ATTRIBUTION"]) then
      12	      Print.ComandAttribution(indent .. "  ", node)
      10	    elseif (node.id == nodes_codes["IF"]) then
       5	      Print.ComandIf(indent .. "  ", node)
       5	    elseif (node.id == nodes_codes["RETURN"]) then
       3	      Print.ComandReturn(indent .. "  ", node)
       2	    elseif (node.id == nodes_codes["WHILE"]) then
       2	      Print.ComandWhile(indent .. "  ", node)
        	    end
        	  end
      15	  print(indent .. "}")
        	end
        	
      11	function Print.Program (indent, t)
      10	  print(indent .. "PROGRAM {")
      39	  for _, node in ipairs(t) do
      29	    if (node.id == nodes_codes["DECLARE"]) then
      14	      Print.Declare(indent .. "  ", node)
      15	    elseif (node.id == nodes_codes["FUNCTION"]) then
      15	      Print.Function(indent .. "  ", node)
        	    end
        	  end
      10	  print(indent .. "}")
        	end
        	
      11	function Print.Variable (indent, t)
      23	  local array_str = ""
      30	  for _, exp in ipairs(t.array) do
       7	    array_str = array_str .. "[" .. Print.Expression() .. "]"
        	  end
      23	  print(indent .. "ID [" .. t.name .. "] " .. array_str .. " @" .. t.line)
        	end
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Print: Print Abstract Syntax or Semantic Tree with comprehensible format
        	--  parameters:
        	--  return:
      11	function Print.Print (tree)
      10	  if (_DEBUG) then print("PRT :: Print") end
      10	  Print.Program("", tree)
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      11	return Print

==============================================================================
./src/grammar.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
      16	local printTokensMatch = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      16	local TokensClass = require "lib/token_codes"
      16	local ASTClass    = require "src/syntax_tree"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      16	local Language = {}
        	
        	-- Stores Parser Functions
        	--  {
        	--    $name = $function
        	--  }
      16	local Parser = {}
        	
        	-- Stores Grammar Functions
        	--  {
        	--    $name = $function
        	--  }
      16	local Grammar = {}
        	
        	--  list of tokens
        	--  {
        	--    [name] = $number,
        	--  }
      16	local tokens = TokensClass.GetTokensList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	--Error: Callback of errors that occurs during syntax analysis
        	--  Parameters:
        	--    [1] $number - line number of grammar syntax error
        	--  Return:
        	local function Error (line)
     239	  error(string.format("@%d syntactic error.", line), 0)
        	end
        	
        	--Match: Receives a token code number and compare with next avaiable token received from lexical
        	--  Parameters:
        	--    [1] $number - Next expected token code number
        	--  Return:
        	--    [1] $string - Token value/name
        	--    [2] $number - Token line number
        	local function Match (code)
   32994	  if (_DEBUG) then print("LAN :: Match") end
   32994	  local token = Parser.Peek()
   32994	  if (token and token.code == code) then
   32818	    if (_DEBUG or printTokensMatch) then
*******0	      print(string.format("    Match code '%10s' %s", TokensClass.GetTokenName(code), token.token))
        	    end
   32818	    Parser.Advance()
   32818	    return token.token, token.line
        	  else
     176	    if (token) then
     176	      error(string.format("@%d syntactic error: expected token '%s' got token '%s'.", token.line, TokensClass.GetTokenName(code), TokensClass.GetTokenName(token.code)), 0)
        	    else
*******0	      error(string.format("@EOF syntactic error: expected token '%s' got 'END_OF_TOKENS'.", TokensClass.GetTokenName(code)), 0)
        	    end
        	  end
        	end
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	--Block:
        	--  syntax:
        	--    bloco     → { declvar nl }
        	--                { comando nl }
        	--  parameters:
        	--  return:
        	--    [1] $table  - List of DECLARE, [...] nodes
      16	function Grammar.Block ()
    1882	  if (_DEBUG) then print("LAN :: Grammar_bloco") end
    1882	  local list = {}
*******0	  while (true) do
    2443	    local token = Parser.Peek()
    2443	    local token2 = Parser.Peek2()
    2443	    if (token and token2 and token.code == tokens.ID and token2.code == tokens["OP_:"]) then
     577	      table.insert(list, Grammar.DeclareVar())
     577	      Grammar.LineEnd()
        	    else
        	      break
        	    end
        	  end
*******0	  while (true) do
    4302	    local token = Parser.Peek()
    4302	    if (token and
    4302	        token.code == tokens.ID or
    2467	        token.code == tokens.K_IF or
    2059	        token.code == tokens.K_WHILE or
    1951	        token.code == tokens.K_RETURN) then
    2644	      table.insert(list, Grammar.Command() or {}) -- RETIRAR OPCAO {}
    2436	      Grammar.LineEnd()
        	    else
        	      break
        	    end
        	  end
    1658	  return list
        	end
        	
        	--Call:
        	--  syntax:
        	--    chamada   → ID '(' listaexp ')'
        	--  parameters:
        	--  return:
        	--    [1] $table  - CALL node
      16	function Grammar.Call ()
     322	  if (_DEBUG) then print("LAN :: Grammar_chamada") end
        	  local name, line, exps
     322	  name, line = Match(tokens.ID)
     322	  Match(tokens["OP_("])
     322	  exps = Grammar.ListExpressions()
     306	  Match(tokens["OP_)"])
     306	  return ASTClass.NewCallNode(line, name, exps)
        	end
        	
        	--CmdAttrib:
        	--  syntax:
        	--    cmdatrib  → var '=' exp
        	--  parameters:
        	--  return:
        	--    [1] $table  - ATTRIBUTION node
      16	function Grammar.CmdAttrib ()
    1561	  if (_DEBUG) then print("LAN :: Grammar_cmdatrib") end
        	  local var, expression
    1561	  var = Grammar.Var()
    1561	  Match(tokens["OP_="])
    1545	  expression = Grammar.Expression()
    1545	  return ASTClass.NewAttributionNode(var, expression)
        	end
        	
        	--CmdIf:
        	--  syntax:
        	--    cmdif     → 'if' exp nl
        	--                    bloco
        	--                { 'else' 'if' exp nl
        	--                    bloco
        	--                }
        	--                [ 'else' nl
        	--                    bloco
        	--                ]
        	--                'end'
      16	function Grammar.CmdIf ()
     408	  if (_DEBUG) then print("LAN :: Grammar_cmdif") end
        	  local line, condition, block, else_block
     408	  local elseif_nodes = {}
     408	  _, line = Match(tokens.K_IF)
     408	  condition = Grammar.Expression()
     344	  Grammar.LineEnd()
     328	  block = Grammar.Block()
*******0	  while (true) do
     436	    local token = Parser.Peek()
     436	    local token2 = Parser.Peek2()
     436	    if (token and token2 and token.code == tokens.K_ELSE and token2.code == tokens.K_IF) then
        	      local line, condition, block
     156	      _, line = Match(tokens.K_ELSE)
     156	      Match(tokens.K_IF)
     156	      condition = Grammar.Expression()
     124	      Grammar.LineEnd()
     124	      block = Grammar.Block()
     124	      table.insert(elseif_nodes, ASTClass.NewElseIfNode(line, condition, block))
        	    else
        	      break
        	    end
        	  end
     280	  local token = Parser.Peek()
     280	  if (token and token.code == tokens.K_ELSE) then
     138	    Match(tokens.K_ELSE)
     138	    Grammar.LineEnd()
     138	    else_block = Grammar.Block()
        	  end
     280	  Match(tokens.K_END)
     280	  return ASTClass.NewIfNode(line, condition, block, elseif_nodes, else_block)
        	end
        	
        	--CmdReturn:
        	--  syntax:
        	--    cmdreturn → 'return' exp | 'return'
        	--  parameters:
        	--  return:
        	--    [1] $table  - RETURN node
      16	function Grammar.CmdReturn ()
     293	  if (_DEBUG) then print("LAN :: Grammar_cmdreturn") end
        	  local line, exp
     293	  _, line = Match(tokens.K_RETURN)
     293	  local token = Parser.Peek()
     293	  if (token and token.code ~= tokens.LINE_END) then
     247	    exp = Grammar.Expression()
        	  end
     293	  return ASTClass.NewReturnNode(line, exp)
        	end
        	
        	--CmdWhile:
        	--  syntax:
        	--    cmdwhile  → 'while' exp nl
        	--                    bloco
        	--                'loop'
        	--  parameters:
        	--  return:
        	--    [1] $table  - WHILE node
      16	function Grammar.CmdWhile ()
     108	  if (_DEBUG) then print("LAN :: Grammar_cmdwhile") end
        	  local line, exp, block
     108	  _, line = Match(tokens.K_WHILE)
     108	  exp = Grammar.Expression()
     108	  Grammar.LineEnd()
     108	  block = Grammar.Block()
      92	  Match(tokens.K_LOOP)
      76	  return ASTClass.NewWhileNode(line, exp, block)
        	end
        	
        	--Command:
        	--  syntax:
        	--    comando   → cmdif | cmdwhile | cmdatrib | cmdreturn | chamada
        	--  parameters:
        	--  return:
        	--    [1] $table - List of DECLARE, CMDATRIB, CMDIF, CMDRETURN, CMDWHILE, [...] nodes
      16	function Grammar.Command ()
    2644	  if (_DEBUG) then print("LAN :: Grammar_comando") end
    2644	  local token = Parser.Peek()
    2644	  if (token and token.code == tokens.K_IF) then
     408	    return Grammar.CmdIf()
    2236	  elseif (token and token.code == tokens.K_WHILE) then
     108	    return Grammar.CmdWhile()
    2128	  elseif (token and token.code == tokens.K_RETURN) then
     293	    return Grammar.CmdReturn()
    1835	  elseif (token and token.code == tokens.ID) then
    1835	    local token2 = Parser.Peek2()
    1835	    if (token2 and token2.code == tokens["OP_("]) then
     258	      return Grammar.Call()
    1577	    elseif (token2 and 
    1577	            token2.code == tokens["OP_="] or
     155	            token2.code == tokens["OP_["]) then
    1561	      return Grammar.CmdAttrib()
        	    else
      16	      Error(token and token.line or 0)
        	    end
        	  else
*******0	    Error(token and token.line or 0)
        	  end
        	end
        	
        	--Declare:
        	--  syntax:
        	--    decl      → funcao | global
        	--  parameters:
        	--  return:
        	--    [1] $table  - DECLARE or FUNCTION node
      16	function Grammar.Declare ()
    1597	  if (_DEBUG) then print("LAN :: Grammar_decl") end
        	  local decl
    1597	  local token = Parser.Peek()
    1597	  if (token and token.code == tokens.K_FUN) then
    1264	    decl = Grammar.Function(parent_node)
     333	  elseif (token and token.code == tokens.ID) then
     333	    decl = Grammar.Global(parent_node)
        	  else
*******0	    Error(token and token.line or 0)
        	  end
    1261	  return decl
        	end
        	
        	--DeclareVar:
        	--  syntax:
        	--    declvar   → ID ':' tipo
        	--  parameters:
        	--  return:
        	--    [1] $table  - DECLARE node
      16	function Grammar.DeclareVar ()
     910	  if (_DEBUG) then print("LAN :: Grammar_declvar") end
        	  local name, line, typebase, array
     910	  name, line = Match(tokens.ID)
     910	  Match(tokens["OP_:"])
     894	  typebase, array = Grammar.Type()
     862	  return ASTClass.NewDeclVarNode(line, name, typebase, array)
        	end
        	
        	--Expression:
        	--  syntax:
        	--    exp       → LITNUMERAL
        	--              | LITSTRING
        	--              | TRUE
        	--              | FALSE
        	--              | var
        	--              | 'new' '[' exp ']' tipo
        	--              | '(' exp ')'
        	--              | chamada
        	--              | exp '+' exp
        	--              | exp '-' exp
        	--              | exp '*' exp
        	--              | exp '/' exp
        	--              | exp '>' exp
        	--              | exp '<' exp
        	--              | exp '>=' exp
        	--              | exp '<=' exp
        	--              | exp '=' exp
        	--              | exp '<>' exp
        	--              | exp 'and' exp
        	--              | exp 'or' exp
        	--              | 'not' exp
        	--              | '-' exp
      16	function Grammar.Expression ()
    3391	  if (_DEBUG) then print("LAN :: Grammar_exp") end
    3391	  local exp = Grammar.ExpressionLevel1()
    3263	  if (not exp) then
     166	    Error(0)
        	  end
    3097	  return exp
        	end
        	
      16	function Grammar.ExpressionLevel1 ()
    3487	  local left = Grammar.ExpressionLevel2()
    3359	  local token = Parser.Peek()
    3359	  if (token and token.code == tokens.K_OR) then
      96	    Match(tokens.K_OR)
      96	    return ASTClass.NewOperatorNode(token.line, left, "or", Grammar.ExpressionLevel1())
        	  end
    3263	  return left
        	end
        	
      16	function Grammar.ExpressionLevel2 ()
    3647	  local left = Grammar.ExpressionLevel3()
    3519	  local token = Parser.Peek()
    3519	  if (token and token.code == tokens.K_AND) then
     160	    Match(tokens.K_AND)
     160	    return ASTClass.NewOperatorNode(token.line, left, "and", Grammar.ExpressionLevel2())
        	  end
    3359	  return left
        	end
        	
      16	function Grammar.ExpressionLevel3 ()
    4089	  local left = Grammar.ExpressionLevel4()
    3961	  local token = Parser.Peek()
    3961	  if (token and token.code == tokens["OP_="]) then
     332	    Match(tokens["OP_="])
     332	    return ASTClass.NewOperatorNode(token.line, left, "=", Grammar.ExpressionLevel3())
    3629	  elseif (token and token.code == tokens["OP_<>"]) then
     110	    Match(tokens["OP_<>"])
     110	    return ASTClass.NewOperatorNode(token.line, left, "<>", Grammar.ExpressionLevel3())
        	  end
    3519	  return left
        	end
        	
      16	function Grammar.ExpressionLevel4 ()
    4469	  local left = Grammar.ExpressionLevel5()
    4341	  local token = Parser.Peek()
    4341	  if (token and token.code == tokens["OP_>"]) then
     108	    Match(tokens["OP_>"])
     108	    return ASTClass.NewOperatorNode(token.line, left, ">", Grammar.ExpressionLevel4())
    4233	  elseif (token and token.code == tokens["OP_<"]) then
     192	    Match(tokens["OP_<"])
     192	    return ASTClass.NewOperatorNode(token.line, left, "<", Grammar.ExpressionLevel4())
    4041	  elseif (token and token.code == tokens["OP_>="]) then
      16	    Match(tokens["OP_>="])
      16	    return ASTClass.NewOperatorNode(token.line, left, ">=", Grammar.ExpressionLevel4())
    4025	  elseif (token and token.code == tokens["OP_<="]) then
      64	    Match(tokens["OP_<="])
      64	    return ASTClass.NewOperatorNode(token.line, left, "<=", Grammar.ExpressionLevel4())
        	  end
    3961	  return left
        	end
        	
      16	function Grammar.ExpressionLevel5 ()
    4875	  local left = Grammar.ExpressionLevel6()
    4747	  local token = Parser.Peek()
    4747	  if (token and token.code == tokens["OP_+"]) then
     307	    Match(tokens["OP_+"])
     307	    return ASTClass.NewOperatorNode(token.line, left, "+", Grammar.ExpressionLevel5())
    4440	  elseif (token and token.code == tokens["OP_-"]) then
      99	    Match(tokens["OP_-"])
      99	    return ASTClass.NewOperatorNode(token.line, left, "-", Grammar.ExpressionLevel5())
        	  end
    4341	  return left
        	end
        	
      16	function Grammar.ExpressionLevel6 ()
    5081	  local left = Grammar.ExpressionLevel7()
    4953	  local token = Parser.Peek()
    4953	  if (token and token.code == tokens["OP_*"]) then
     143	    Match(tokens["OP_*"])
     143	    return ASTClass.NewOperatorNode(token.line, left, "*", Grammar.ExpressionLevel6())
    4810	  elseif (token and token.code == tokens["OP_/"]) then
      63	    Match(tokens["OP_/"])
      63	    return ASTClass.NewOperatorNode(token.line, left, "/", Grammar.ExpressionLevel6())
        	  end
    4747	  return left
        	end
        	
      16	function Grammar.ExpressionLevel7 ()
    5375	  local token = Parser.Peek()
    5375	  if (token and token.code == tokens.NUMBER) then
    1804	    return ASTClass.NewValueNode(token.line, "int", Match(tokens.NUMBER))
    3571	  elseif (token and token.code == tokens.STRING) then
      96	    return ASTClass.NewValueNode(token.line, "string", Match(tokens.STRING))
    3475	  elseif (token and token.code == tokens.K_TRUE) then
     162	    return ASTClass.NewValueNode(token.line, "bool", Match(tokens.K_TRUE))
    3313	  elseif (token and token.code == tokens.K_FALSE) then
     118	    return ASTClass.NewValueNode(token.line, "bool", Match(tokens.K_FALSE))
    3195	  elseif (token and token.code == tokens.K_NEW) then
     110	    Match(tokens.K_NEW)
     110	    Match(tokens["OP_["])
     110	    local exp = Grammar.Expression()
     110	    Match(tokens["OP_]"])
     110	    local typebase, dimension = Grammar.Type()
     110	    return ASTClass.NewNewVarNode(token.line, exp, typebase, dimension)
    3085	  elseif (token and token.code == tokens.K_NOT) then
     181	    Match(tokens.K_NOT)
     181	    local exp = Grammar.ExpressionLevel7()
     181	    return ASTClass.NewNegateNode(token.line, exp)
    2904	  elseif (token and token.code == tokens.ID) then
        	    local node
    2411	    local token2 = Parser.Peek2()
    2411	    if (token2 and token2.code == tokens["OP_("]) then
      64	      return Grammar.Call()
        	    else
    2347	      return Grammar.Var()
        	    end
     493	  elseif (token and token.code == tokens["OP_("]) then
     268	    Match(tokens["OP_("])
     268	    local exp = Grammar.Expression()
     252	    Match(tokens["OP_)"])
     252	    return exp
     225	  elseif (token and token.code == tokens["OP_-"]) then
     113	    Match(tokens["OP_-"])
     113	    return ASTClass.NewUnaryNode(token.line, Grammar.ExpressionLevel7())
        	  else
     112	    Error(token and token.line or 0)
        	  end
        	end
        	
        	--Function:
        	--  syntax:
        	--    funcao    → 'fun' ID '(' params ')' [ ':' tipo ] nl
        	--                    bloco
        	--                'end' nl
        	--  parameters:
        	--  return:
        	--    [1] $table  - FUNCTION node
      16	function Grammar.Function ()
    1264	  if (_DEBUG) then print("LAN :: Grammar_funcao") end
        	  local name, line, params, ret_type, array_size, block
    1264	  Match(tokens.K_FUN)
    1264	  name, line = Match(tokens.ID)
    1232	  Match(tokens["OP_("])
    1232	  params = Grammar.Parameters()
    1184	  Match(tokens["OP_)"])
    1184	  local token = Parser.Peek()
    1184	  if (token and token.code == tokens["OP_:"]) then
     463	    Match(tokens["OP_:"])
     463	    ret_type, array_size = Grammar.Type()
        	  end
    1184	  Grammar.LineEnd()
    1184	  block = Grammar.Block()
     992	  Match(tokens.K_END)
     992	  Grammar.LineEnd()
     992	  return ASTClass.NewFunctionNode(line, name, params, ret_type, array_size, block)
        	end
        	
        	--Global:
        	--  syntax:
        	--    global    → declvar nl
        	--  parameters:
        	--  return:
        	--    [1] $table  - DECLARE node
      16	function Grammar.Global ()
     333	  if (_DEBUG) then print("LAN :: Grammar_global") end
     333	  local node = Grammar.DeclareVar()
     285	  Grammar.LineEnd()
     269	  return node
        	end
        	
        	--ListExpressions:
        	--  syntax:
        	--    listaexp  → /*vazio*/ | exp { ',' exp }
        	--  parameters:
        	--  return:
        	--    [1] $table  - List of EXPRESSION nodes
      16	function Grammar.ListExpressions ()
     322	  if (_DEBUG) then print("LAN :: Grammar_listaexp") end
     322	  local list = {}
     322	  local token = Parser.Peek()
     322	  if (token and token.code ~= tokens["OP_)"]) then
     237	    table.insert(list, Grammar.Expression())
*******0	    while (true) do
     347	      token = Parser.Peek()
     347	      if (token and token.code == tokens["OP_,"]) then
     126	        Match(tokens["OP_,"])
     126	        table.insert(list, Grammar.Expression())
        	      else
        	        break
        	      end
        	    end
        	  end
     306	  return list
        	end
        	
        	--LineEnd:
        	--  syntax:
        	--    nl        → NL { NL }
      16	function Grammar.LineEnd()
    7075	  if (_DEBUG) then print("LAN :: Grammar_nl") end
    7075	  Match(tokens.LINE_END)
*******0	  while (true) do
    7075	    local token = Parser.Peek()
    7075	    if (token and token.code == tokens.LINE_END) then
      48	      Match(tokens.LINE_END)
        	    else
        	      break
        	    end
        	  end
        	end
        	
        	--Parameter:
        	--  syntax:
        	--    parametro → ID ':' tipo
        	--  parameters:
        	--  return:
        	--    [1] $table  - PARAMETER node
      16	function Grammar.Parameter ()
     514	  if (_DEBUG) then print("LAN :: Grammar_parametro") end
        	  local name, line, typebase, array_size
     514	  name, line = Match(tokens.ID)
     482	  Match(tokens["OP_:"])
     466	  typebase, array_size = Grammar.Type()
     466	  return ASTClass.NewParameterNode(line, name, typebase, array_size)
        	end
        	
        	--Parameters:
        	--  syntax:
        	--    params    → /*vazio*/ | parametro { ',' parametro }
        	--  parameters:
        	--  return:
        	--    [1] $table  - List of PARAMETER nodes
      16	function Grammar.Parameters ()
    1232	  if (_DEBUG) then print("LAN :: Grammar_params") end
    1232	  local list = {}
    1232	  local token = Parser.Peek()
    1232	  if (token and token.code ~= tokens["OP_)"]) then
     359	    table.insert(list, Grammar.Parameter())
*******0	    while (true) do
     466	      token = Parser.Peek()
     466	      if (token and token.code == tokens["OP_,"]) then
     155	        Match(tokens["OP_,"])
     155	        table.insert(list, Grammar.Parameter())
        	      else
        	        break
        	      end
        	    end
        	  end
    1184	  return list
        	end
        	
        	--Program:
        	--  syntax:
        	--    programa  → { NL } decl { decl }
      16	function Grammar.Program ()
    1066	  if (_DEBUG) then print("LAN :: Grammar_programa") end
    1066	  local node = {}
    1066	  local token = Parser.Peek()
    1066	  if (token and token.code == tokens.LINE_END) then
     887	    Grammar.LineEnd()
        	  end
    1066	  token = Parser.Peek()
    1066	  if (token and (token.code == tokens.K_FUN or token.code == tokens.ID)) then
     990	    table.insert(node, Grammar.Declare())
      14	    while (true) do
    1259	      token = Parser.Peek()
    1208	      if (token) then
     641	        table.insert(node, Grammar.Declare())
        	      else
      23	        break
        	      end
        	    end
        	  else
      75	    Error(token and token.line or 0)
        	  end
     624	  ASTClass.NewProgramNode(node)
        	end
        	
        	--Type:
        	--  syntax:
        	--    tipo      → tipobase | '[' ']' tipo
        	--  parameters:
        	--  return:
        	--    [1] $typebase
        	--    [2] $array_size
      15	function Grammar.Type (array_size)
    2350	  if (_DEBUG) then print("LAN :: Grammar_tipo") end
    2351	  array_size = array_size or 0
        	  local typebase
    2452	  local token = Parser.Peek()
    2452	  if (token and
    2452	      token.code == tokens.K_INT or
    1177	      token.code == tokens.K_BOOL or
     841	      token.code == tokens.K_CHAR or
     622	      token.code == tokens.K_STRING) then
    1837	    typebase = Grammar.Typebase()
     552	  elseif (token and token.code == tokens["OP_["]) then
     589	    Match(tokens["OP_["])
     521	    Match(tokens["OP_]"])
     519	    array_size = array_size + 1
     519	    typebase, array_size = Grammar.Type(array_size)
        	  else
      45	    Error(token and token.line or 0)
        	  end
    2322	  return typebase, array_size
        	end
        	
        	--Typebase:
        	--  syntax:
        	--    tipobase  → 'int' | 'bool' | 'char' | 'string'
        	--  parameters:
        	--  return:
        	--    [1] $typebase
      15	function Grammar.Typebase ()
    1816	  if (_DEBUG) then print("LAN :: Grammar_tipobase") end
    1817	  local token = Parser.Peek()
    1901	  if (token and token.code == tokens.K_INT) then
    1360	    Match(tokens.K_INT)
    1360	    return "int"
     609	  elseif (token and token.code == tokens.K_BOOL) then
     404	    Match(tokens.K_BOOL)
     353	    return "bool"
     218	  elseif (token and token.code == tokens.K_CHAR) then
     164	    Match(tokens.K_CHAR)
     155	    return "char"
      57	  elseif (token and token.code == tokens.K_STRING) then
      57	    Match(tokens.K_STRING)
      55	    return "string"
        	  else
       1	    Error(token and token.line or 0)
        	  end
        	end
        	
        	--Var:
        	--  syntax:
        	--    var       → ID | var '[' exp ']'
        	--  parameters:
        	--  return:
        	--    [1] $table - VAR node
      15	function Grammar.Var ()
    3692	  if (_DEBUG) then print("LAN :: Grammar_var") end
        	  local name, line
    3908	  local array = {}
    3908	  name, line = Match(tokens.ID)
     216	  while (true) do
    4086	    local token = Parser.Peek()
    3870	    if (token and token.code == tokens["OP_["]) then
     402	      Match(tokens["OP_["])
     402	      table.insert(array, Grammar.Expression())
     186	      Match(tokens["OP_]"])
        	    else
       8	      break
        	    end
        	  end
    3692	  return ASTClass.NewVarNode(line, name, array)
        	end
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
      15	function Language.Start (func_advance, func_peek, func_peek2)
    1010	  if (_DEBUG) then print("LAN :: Start") end
    1011	  assert(type(func_advance) == "function")
    1066	  assert(type(func_peek) == "function")
    1066	  assert(type(func_peek2) == "function")
    1066	  Parser.Advance = func_advance
    1066	  Parser.Peek = func_peek
    1066	  Parser.Peek2 = func_peek2
    2076	  local ok, msg = pcall(function () Grammar.Program() end)
    1066	  if (not ok) then
     502	    return false, msg
        	  end
     646	  return true
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      15	return Language
        	
        	
        	--==============================================================================
        	-- Grammar
        	--==============================================================================
        	
        	-- programa  → { NL } decl { decl }
        	--
        	-- decl      → funcao | global
        	--
        	-- nl        → NL { NL }
        	--
        	-- global    → declvar nl
        	--
        	-- funcao    → 'fun' ID '(' params ')' [ ':' tipo ] nl
        	--                bloco
        	--             'end' nl
        	--
        	-- bloco     → { declvar nl }
        	--             { comando nl }
        	--
        	-- params    → /*vazio*/ | parametro { ',' parametro }
        	--
        	-- parametro → ID ':' tipo
        	--
        	-- tipo      → tipobase | '[' ']' tipo
        	--
        	-- tipobase  → 'int' | 'bool' | 'char' | 'string'
        	--
        	-- declvar   → ID ':' tipo
        	--
        	-- comando   → cmdif | cmdwhile | cmdatrib | cmdreturn | chamada 
        	--
        	-- cmdif     → 'if' exp nl
        	--                bloco
        	--             { 'else' 'if' exp nl
        	--                bloco
        	--             }
        	--             [ 'else' nl
        	--                bloco
        	--             ]
        	--             'end'
        	--
        	-- cmdwhile  → 'while' exp nl
        	--                bloco
        	--             'loop'
        	--
        	-- cmdatrib  → var '=' exp
        	--
        	-- chamada   → ID '(' listaexp ')'
        	--
        	-- listaexp  → /*vazio*/ | exp { ',' exp }
        	--
        	-- cmdreturn → 'return' exp | 'return'
        	--
        	-- var       → ID | var '[' exp ']'
        	--
        	-- exp       → LITNUMERAL
        	--           | LITSTRING
        	--           | TRUE
        	--           | FALSE
        	--           | var
        	--           | 'new' '[' exp ']' tipo
        	--           | '(' exp ')'
        	--           | chamada
        	--           | exp '+' exp
        	--           | exp '-' exp
        	--           | exp '*' exp
        	--           | exp '/' exp
        	--           | exp '>' exp
        	--           | exp '<' exp
        	--           | exp '>=' exp
        	--           | exp '<=' exp
        	--           | exp '=' exp
        	--           | exp '<>' exp
        	--           | exp 'and' exp
        	--           | exp 'or' exp
        	--           | 'not' exp
        	--           | '-' exp

==============================================================================
./src/lexical.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
      16	local printTokensCapture  = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      16	local lulex       = require "lib/lulex"
      16	local TokensClass = require "lib/token_codes"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      16	local Lexical = {}
        	
        	-- number of current line
        	local line_number
        	
        	-- lexer instructions and callbacks
        	--  {
        	--    [#] = {
        	--      [1] = pattern,
        	--      [2] = function,
        	--    }
        	--  }
      16	local lexer = {}
        	
        	-- tags read in input
        	--  {
        	--    [#] = {
        	--      code  = $number,
        	--      line  = $number,
        	--      token = $string,
        	--    }
        	--  }
      16	local tags = {}
        	
        	--  list of tokens
        	--  {
        	--    [name] = $number,
        	--  }
      16	local tokens = TokensClass.GetTokensList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	local function StoreToken (code, token, line)
   38641	  if (_DEBUG) then print("LEX :: StoreToken") end
   38641	  assert(code and type(code) == "number")
   38641	  assert(token)
   38641	  assert(line and type(line) == "number")
   38641	  if (_DEBUG or printTokensCapture) then
*******0	    print(string.format("codigo: '%10s' linha: %4d token: %s", TokensClass.GetTokenName(code), line, tostring(token)))
        	  end
   38641	  local t = {
   38641	    code = code,
   38641	    line = line,
   38641	    token = token,
        	  }
   38641	  table.insert(tags, t)
        	end
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
      32	lexer = lulex.New{
      16	  { '[ \t]+',
        	    function (token)
        	    end
      16	  },
      16	  { '//[^\n]+',
        	    function (token)
        	      --StoreToken(tokens.COMMENT_LINE, token, line_number)
        	    end
      16	  },
      16	  { '/\\*([^\\*]|\\*[^/])*\\*/',
        	    function (token)
        	      --StoreToken(tokens.COMMENT_BLOCK, token, line_number)
      48	      local init = 0
     144	      while (string.find(token, "\n", init)) do
      96	        _, init = string.find(token, "\n", init)
      96	        init = init + 1
      96	        line_number = line_number + 1
        	      end
        	    end
      16	  },
      16	  { 'if',
        	    function (token)
     676	      StoreToken(tokens.K_IF, token, line_number)
        	    end
      16	  },
      16	  { 'then',
        	    function (token)
      16	      StoreToken(tokens.K_THEN, token, line_number)
        	    end
      16	  },
      16	  { 'else',
        	    function (token)
     438	      StoreToken(tokens.K_ELSE, token, line_number)
        	    end
      16	  },
      16	  { 'while',
        	    function (token)
     108	      StoreToken(tokens.K_WHILE, token, line_number)
        	    end
      16	  },
      16	  { 'loop',
        	    function (token)
     108	      StoreToken(tokens.K_LOOP, token, line_number)
        	    end
      16	  },
      16	  { 'fun',
        	    function (token)
    1280	      StoreToken(tokens.K_FUN, token, line_number)
        	    end
      16	  },
      16	  { 'return',
        	    function (token)
     373	      StoreToken(tokens.K_RETURN, token, line_number)
        	    end
      16	  },
      16	  { 'new',
        	    function (token)
     126	      StoreToken(tokens.K_NEW, token, line_number)
        	    end
      16	  },
      16	  { 'string',
        	    function (token)
      71	      StoreToken(tokens.K_STRING, token, line_number)
        	    end
      16	  },
      16	  { 'int',
        	    function (token)
    1391	      StoreToken(tokens.K_INT, token, line_number)
        	    end
      16	  },
      16	  { 'char',
        	    function (token)
     170	      StoreToken(tokens.K_CHAR, token, line_number)
        	    end
      16	  },
      16	  { 'bool',
        	    function (token)
     381	      StoreToken(tokens.K_BOOL, token, line_number)
        	    end
      16	  },
      16	  { 'true',
        	    function (token)
     226	      StoreToken(tokens.K_TRUE, token, line_number)
        	    end
      16	  },
      16	  { 'false',
        	    function (token)
     182	      StoreToken(tokens.K_FALSE, token, line_number)
        	    end
      16	  },
      16	  { 'and',
        	    function (token)
     176	      StoreToken(tokens.K_AND, token, line_number)
        	    end
      16	  },
      16	  { 'or',
        	    function (token)
     128	      StoreToken(tokens.K_OR, token, line_number)
        	    end
      16	  },
      16	  { 'not',
        	    function (token)
     197	      StoreToken(tokens.K_NOT, token, line_number)
        	    end
      16	  },
      16	  { 'end',
        	    function (token)
    1752	      StoreToken(tokens.K_END, token, line_number)
        	    end
      16	  },
      16	  { '\\"([^\\"\\\\]|\\\\[nt\\\\"])*\\"',
        	    function (token)
     208	      local str = token
     208	      str = string.gsub(str, '^"', '')
     208	      str = string.gsub(str, '"$', '')
     208	      str = string.gsub(str, '\\"', '"')
     208	      str = string.gsub(str, '\\n', '\n')
     208	      str = string.gsub(str, '\\t', '\t')
     208	      str = string.gsub(str, '\\\\', '\\')
     208	      StoreToken(tokens.STRING, str, line_number)
        	    end
      16	  },
      16	  { '[0-9]+',
        	    function (token)
    2300	      StoreToken(tokens.NUMBER, token, line_number)
        	    end
      16	  },
      16	  { '0x[0-9a-fA-F]+',
        	    function (token)
      32	      StoreToken(tokens.NUMBER, tonumber(token), line_number)
        	    end
      16	  },
      16	  { '\\(',
        	    function (token)
    1966	      StoreToken(tokens["OP_("], token, line_number)
        	    end
      16	  },
      16	  { '\\)',
        	    function (token)
    1966	      StoreToken(tokens["OP_)"], token, line_number)
        	    end
      16	  },
      16	  { ',',
        	    function (token)
     329	      StoreToken(tokens["OP_,"], token, line_number)
        	    end
      16	  },
      16	  { ':',
        	    function (token)
    1887	      StoreToken(tokens["OP_:"], token, line_number)
        	    end
      16	  },
      16	  { '>',
        	    function (token)
     124	      StoreToken(tokens["OP_>"], token, line_number)
        	    end
      16	  },
      16	  { '<',
        	    function (token)
     224	      StoreToken(tokens["OP_<"], token, line_number)
        	    end
      16	  },
      16	  { '>=',
        	    function (token)
      32	      StoreToken(tokens["OP_>="], token, line_number)
        	    end
      16	  },
      16	  { '<=',
        	    function (token)
      96	      StoreToken(tokens["OP_<="], token, line_number)
        	    end
      16	  },
      16	  { '=',
        	    function (token)
    2405	      StoreToken(tokens["OP_="], token, line_number)
        	    end
      16	  },
      16	  { '<>',
        	    function (token)
     142	      StoreToken(tokens["OP_<>"], token, line_number)
        	    end
      16	  },
      16	  { '\\[',
        	    function (token)
     847	      StoreToken(tokens["OP_["], token, line_number)
        	    end
      16	  },
      16	  { '\\]',
        	    function (token)
     847	      StoreToken(tokens["OP_]"], token, line_number)
        	    end
      16	  },
      16	  { '\\+',
        	    function (token)
     355	      StoreToken(tokens["OP_+"], token, line_number)
        	    end
      16	  },
      16	  { '-',
        	    function (token)
     244	      StoreToken(tokens["OP_-"], token, line_number)
        	    end
      16	  },
      16	  { '\\*',
        	    function (token)
     159	      StoreToken(tokens["OP_*"], token, line_number)
        	    end
      16	  },
      16	  { '/',
        	    function (token)
      79	      StoreToken(tokens["OP_/"], token, line_number)
        	    end
      16	  },
      16	  { '[ \n]+',
        	    function (token)
    8835	      StoreToken(tokens.LINE_END, token, line_number)
    8835	      local init = 0
   18890	      while (string.find(token, "\n", init)) do
   10055	        _, init = string.find(token, "\n", init)
   10055	        init = init + 1
   10055	        line_number = line_number + 1
        	      end
        	    end
      16	  },
      16	  { '[a-zA-Z_][a-zA-Z0-9_]*',
        	    function (token)
    7705	      StoreToken(tokens.ID, token, line_number)
        	    end
      16	  },
      16	  { '.',
        	    function (token)
      60	      StoreToken(tokens.ERROR, token, line_number)
        	    end
      16	  },
      32	}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Open:
        	--  parameters:
        	--    [1] $string  - path of file to be analysed
        	--  return:
        	--    [1] $boolean - false if found any problem, true otherwise
        	--    [2] $string  - only when [1] is false, informing which error occurs
      16	function Lexical.Open (txt)
    1081	  if (_DEBUG) then print("LEX :: Open") end
    1081	  assert(txt and type(txt) == "string")
    1081	  tags = {}
    1081	  line_number = 1
    1081	  lexer:run(txt, true)
   39512	  for _, tab in ipairs(tags) do
   38446	    if (tab.code == tokens.ERROR) then
      15	      return false, string.format("@%d lexical error: could not recognize tags.", tab.line)
        	    end
        	  end
    1066	  return true
        	end
        	
      16	function Lexical.GetTags()
    1066	  if (_DEBUG) then print("LEX :: GetTags") end
    1066	  return tags
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      16	return Lexical

==============================================================================
./src/parser.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      16	local Parser = {}
        	
        	-- store tokens list received in input
      16	local tokens_list = {}
        	
        	-- keep the number of the current token
      16	local current = 0
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Advance:
        	--  parameters:
        	--  return:
      16	function Parser.Advance ()
   32818	  if (_DEBUG) then print("PAR :: Advance") end
   32818	  current = current + 1
        	end
        	
        	--Open: Start a new parser with current table input, erasing any previous one
        	--  parameters:
        	--    [1] $table   - table with tokens read in lexical
        	--  return:
      16	function Parser.Open (t)
    1066	  if (_DEBUG) then print("PAR :: Open") end
    1066	  assert(type(t) == "table")
    1066	  current = 0
    1066	  tokens_list = t
        	end
        	
        	--Peek: peek the next token
        	--  parameters:
        	--  return:
      16	function Parser.Peek ()
   97710	  if (_DEBUG) then print("PAR :: Peek") end
   97710	  return tokens_list[current + 1]
        	end
        	
        	--Peek2: peek the second next token
        	--  parameters:
        	--  return:
      16	function Parser.Peek2 ()
    7125	  if (_DEBUG) then print("PAR :: Peek2") end
    7125	  return tokens_list[current + 2]
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      16	return Parser

==============================================================================
./src/semantic.lua
==============================================================================
        	--==============================================================================
        	-- Considerations
        	--==============================================================================
        	
        	-- Functions sets new unreach code variable '@ret' as its return VAR variable
        	-- Functions sets PARAMETER nodes to own scope
        	-- ALLOW overcharge variable in diferent scopes
        	
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
      11	local printTree = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      16	require "lib/util"
      16	local NodesClass  = require "lib/node_codes"
      14	local PrintClass  = require "lib/util_tree"
      11	local SymbolClass = require "src/symbol_table"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      11	local Semantic = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
      11	local nodes_codes = NodesClass.GetNodesList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	--Error: Callback of errors that occurs during semantic analysis
        	--  Parameters:
        	--    [1] $string
        	--  Return:
        	local function Error (msg, line)
     388	  local str = string.format("@%d semantic error: %s", line or 0, msg or "")
     309	  error(str, 0)
        	end
        	
        	--VerifyAttribution: Verify integrity of ATTRIBUTION node
        	--  Parameters:
        	--    [1] $table  = ATTRIBUTION node
        	--  Return:
      20	function Semantic.VerifyAttribution (node)
     193	  if (_DEBUG) then print("SEM :: VerifyAttribution") end
     158	  assert(node.id == nodes_codes["ATTRIBUTION"])
     150	  Semantic.VerifyVar(node.var)
     126	  Semantic.VerifyExpression(node.exp)
     117	  Semantic.VerifyCompatibleTypes(node.line, node.var.sem_type, node.var.sem_dimension, node.exp.sem_type, node.exp.sem_dimension)
        	  -- MUST UPDATE SYMBOL TABLE VALUE
        	end
        	
        	--VerifyBlock: Verify integrity of BLOCK/COMMANDS nodes
        	--  Parameters:
        	--    [1] $table  = collection of ATTRIBUTION, CALL, DECLARE, IF, RETURN and WHILE nodes
        	--  Return:
     422	function Semantic.VerifyBlock (block)
     525	  if (_DEBUG) then print("SEM :: VerifyBlock") end
     710	  for _, node in ipairs(block) do
     387	    if (node.id == nodes_codes["ATTRIBUTION"]) then
     167	      Semantic.VerifyAttribution(node)
     231	    elseif (node.id == nodes_codes["CALL"]) then
      36	      Semantic.VerifyCall(node)
     197	    elseif (node.id == nodes_codes["DECLARE"]) then
     104	      Semantic.VerifyDeclare(node)
     101	    elseif (node.id == nodes_codes["IF"]) then
      48	      Semantic.VerifyIf(node)
      62	    elseif (node.id == nodes_codes["RETURN"]) then
      40	      Semantic.VerifyReturn(node)
      15	    elseif (node.id == nodes_codes["WHILE"]) then
      15	      Semantic.VerifyWhile(node)
        	    else
*******0	      Error("unknown block node")
        	    end
        	  end
        	end
        	
        	--VerifyCall: Verify integrity of CALL node
        	--  Parameters:
        	--    [1] $table  = CALL node
        	--  Return:
      29	function Semantic.VerifyCall (node)
      30	  if (_DEBUG) then print("SEM :: VerifyCall") end
      32	  assert(node.id == nodes_codes["CALL"])
     124	  local symbol = SymbolClass.GetSymbol(node.name)
     402	  if (not symbol) then
     939	    Error(string.format("symbol '%s' was not declared.", node.name), node.line)
        	  end
     839	  if (symbol.id ~= "function") then
     441	    Error(string.format("attempt to call %s '%s', which is a '%s', not a 'function'.", symbol.id, symbol.name, symbol.type), node.line)
        	  end
     354	  local num_func_params = symbol.params and #symbol.params or 0
     400	  local num_call_params = node.exps and #node.exps or 0
     311	  if (num_func_params ~= num_call_params) then
     352	    Error(string.format("attempt to call function '%s' with '%d' parameter(s), but it demands '%d'.", symbol.name, num_func_params, num_call_params), node.line)
        	  end
     256	  for i = 1, num_func_params do
     151	    Semantic.VerifyExpression(node.exps[i])
     158	    Semantic.VerifyCompatibleTypes(node.line, symbol.params[i].type, symbol.params[i].dimension, node.exps[i].sem_type, node.exps[i].sem_dimension)
        	  end
     160	  node.sem_type = symbol.ret_type
      63	  node.sem_dimension = symbol.ret_dimension
        	end
        	
        	--VerifyCompatibleTypes: Check if two different variables can be matched
        	--  Parameters:
        	--    [1] $number = line number
        	--    [2] $string = type of first variable
        	--    [3] $number = dimension of first variable
        	--    [4] $string = type of second variable
        	--    [5] $number = dimension of second variable
        	--  Return:
      95	function Semantic.VerifyCompatibleTypes (line, first_type, first_dimension, second_type, second_dimension)
     245	  local err = false
     221	  if (first_type ~= second_type) then
      52	    if (first_type == "int" and second_type == "char") or (first_type == "char" and second_type == "int") then
      82	      if (first_dimension ~= second_dimension) then
      57	        err = true
        	      end
        	      --[[
        	    elseif (first_type == "string" and second_type == "char") then
        	      if (first_dimension + 1 ~= second_dimension) then
        	        err = true
        	      end
        	    elseif (first_type == "char" and second_type == "string") then
        	      if (first_dimension ~= second_dimension + 1) then
        	        err = true
        	      end
        	      --]]
        	    else
      52	      err = true
        	    end
        	  else
     117	    if (first_dimension ~= second_dimension) then
     131	      err = true
        	    end
        	  end
      76	  if (err) then
     107	    Error(string.format("uncompatible types '%s' dimension '%d' and '%s' dimension '%d'.", first_type, first_dimension, second_type, second_dimension), line)
        	  end
      68	  return true
        	end
        	
        	--VerifyDeclare: Verify integrity of DECLARE node
        	--  Parameters:
        	--    [1] $table  = DECLARE node
        	--  Return:
     113	function Semantic.VerifyDeclare (node)
     110	  if (_DEBUG) then print("SEM :: VerifyDeclare") end
     110	  assert(node.id == nodes_codes["DECLARE"])
      58	  local symbol = SymbolClass.GetCurrentScopeSymbol(node.name)
      66	  if (symbol) then
     140	    Error(string.format("symbol '%s' was already declared at line %d.", symbol.name, symbol.line), node.line)
        	  else
     119	    SymbolClass.SetSymbol(node)
        	  end
        	end
        	
        	--VerifyElseIf: Verify integrity of ELSEIF node
        	--  Parameters:
        	--    [1] $table  = ELSEIF node
        	--  Return:
      23	function Semantic.VerifyElseIf (node)
      11	  if (_DEBUG) then print("SEM :: VerifyElseIf") end
      47	  assert(node.id == nodes_codes["ELSEIF"])
      22	  SymbolClass.AddScope()
       8	  Semantic.VerifyExpression(node.cond)
      50	  if (node.cond.sem_type ~= "bool" or node.cond.sem_dimension ~= 0) then
     183	    Error(string.format("'else if' expects expression of type 'bool' with dimension '0', but got type '%s' with dimension '%d'.", node.cond.sem_type, node.cond.sem_dimension), node.line)
        	  end
     321	  Semantic.VerifyBlock(node.block)
     314	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyExpression: Verify integrity of EXPRESSION node
        	--  Parameters:
        	--    [1] $table  = CALL, NEGATE, NEWVAR, OPERATOR, UNARY, VALUE or VAR node
        	--  Return:
     346	function Semantic.VerifyExpression (node)
     161	  if (_DEBUG) then print("SEM :: VerifyExpression") end
     465	  if (node.id == nodes_codes["CALL"]) then
      73	    Semantic.VerifyCall(node)
     496	  elseif (node.id == nodes_codes["NEGATE"]) then
      95	    Semantic.VerifyNegate(node)
     507	  elseif (node.id == nodes_codes["NEWVAR"]) then
      96	    Semantic.VerifyNewVar(node)
     407	  elseif (node.id == nodes_codes["OPERATOR"]) then
      94	    Semantic.VerifyOperator(node)
     364	  elseif (node.id == nodes_codes["UNARY"]) then
     163	    Semantic.VerifyUnary(node)
     232	  elseif (node.id == nodes_codes["VALUE"]) then
     191	    Semantic.VerifyValue(node)
      77	  elseif (node.id == nodes_codes["VAR"]) then
      74	    Semantic.VerifyVar(node)
        	  else
     304	    Error("unknown expression node", node.line)
        	  end
        	end
        	
        	--VerifyFunction: Verify integrity of FUNCTION node
        	--  Parameters:
        	--    [1] $table  = FUNCTION node
        	--  Return:
     108	function Semantic.VerifyFunction (node)
     152	  if (_DEBUG) then print("SEM :: VerifyFunction") end
     283	  assert(node.id == nodes_codes["FUNCTION"])
     301	  SymbolClass.AddScope()
     248	  if (node.params) then
     537	    for _, param in ipairs(node.params) do
     776	      if (SymbolClass.GetCurrentScopeSymbol(param.name)) then
      69	        Error("")
        	      end
     155	      SymbolClass.SetSymbol(param)
        	    end
        	  end
     591	  if (node.ret_type) then
     861	    local ret = {
     299	      id        = nodes_codes["DECLARE"],
     251	      name      = "@ret",
     189	      line      = node.line,
      20	      type      = node.ret_type,
     180	      dimension = node.ret_dimension,
     133	    }
     138	    SymbolClass.SetSymbol(ret)
        	  end
     110	  Semantic.VerifyBlock(node.block)
      59	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyGlobals: Add global functions and variables to scope
        	--  Parameters:
        	--    [1] $table  = PROGRAM node
        	--  Return:
     100	function Semantic.VerifyGlobals (t)
     335	  if (_DEBUG) then print("SEM :: VerifyGlobals") end
     214	  assert(t.id == nodes_codes["PROGRAM"])
     299	  for _, node in ipairs(t) do
     159	    local symbol = SymbolClass.GetSymbol(node.name)
     170	    if (symbol) then
     293	      Error(string.format("global symbol '%s' was already declared at line %d.", symbol.name, symbol.line), node.line)
        	    end
     173	    SymbolClass.SetSymbol(node)
        	  end
        	end
        	
        	--VerifyIf: Verify integrity of IF node
        	--  Parameters:
        	--    [1] $table  = IF node
        	--  Return:
     114	function Semantic.VerifyIf (node)
      44	  if (_DEBUG) then print("SEM :: VerifyIf") end
      97	  assert(node.id == nodes_codes["IF"])
     129	  SymbolClass.AddScope()
      21	  Semantic.VerifyExpression(node.cond)
      64	  if (node.cond.sem_type ~= "bool" or node.cond.sem_dimension ~= 0) then
     163	    Error(string.format("'if' expects expression of type 'bool' with dimension '0', but got type '%s' with dimension '%d'.", node.cond.sem_type, node.cond.sem_dimension), node.line)
        	  end
      27	  Semantic.VerifyBlock(node.block)
      33	  if (node["elseif"]) then
     308	    for _, n in ipairs (node["elseif"]) do
     653	      Semantic.VerifyElseIf(n)
        	    end
        	  end
      19	  if (node["else"]) then
      28	    SymbolClass.AddScope()
       8	    Semantic.VerifyBlock(node["else"])
     413	    SymbolClass.RemoveScope()
        	  end
     518	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyNewVar: Verify integrity of NEWVAR node
        	--  Parameters:
        	--    [1] $table  = NEWVAR node
        	--  Return:
     910	function Semantic.VerifyNewVar (node)
      60	  if (_DEBUG) then print("SEM :: VerifyNewVar") end
      61	  assert(node.id == nodes_codes["NEWVAR"])
       6	  Semantic.VerifyExpression(node.exp)
     104	  if (node.exp.sem_type ~= "int" and node.exp.sem_type ~= "char") then
      64	    Error(string.format("'new var' expression must have type 'int' or 'char', but got type '%s'.", node.exp.sem_type), node.line)
        	  end
      62	  node.sem_type = node.type
      50	  node.sem_dimension = node.dimension + 1
        	end
        	
        	--VerifyNegate: Verify integrity of NEGATE node
        	--  Parameters:
        	--    [1] $table  = NEGATE node
        	--  Return:
     486	function Semantic.VerifyNegate (node)
     409	  if (_DEBUG) then print("SEM :: VerifyNegate") end
      84	  assert(node.id == nodes_codes["NEGATE"])
      57	  Semantic.VerifyExpression(node.exp)
     131	  if (node.exp.sem_type ~= "bool" or node.exp.sem_dimension ~= 0) then
     137	    Error(string.format("'not' must be done over type 'bool' with dimension '0', but got type '%s' with dimension '%d'.", node.exp.sem_type, node.exp.sem_dimension))
        	  end
     163	  node.sem_type = "bool"
     354	  node.sem_dimension = 0
        	end
        	
        	--VerifyOperator: Verify integrity of OPERATOR node
        	--  Parameters:
        	--    [1] $table  = NEGATE node
        	--  Return:
     122	function Semantic.VerifyOperator (node)
     221	  if (_DEBUG) then print("SEM :: VerifyOperator") end
     197	  assert(node.id == nodes_codes["OPERATOR"])
     434	  Semantic.VerifyExpression(node[1])
     191	  Semantic.VerifyExpression(node[2])
     209	  if (node.op == "and" or node.op == "or") then
      14	    if (node[1].sem_type ~= "bool") then
      28	      Error(string.format("operation '%s' cannot be made over left type '%s'.", node.op, node[1].sem_type), node.line)
      16	    elseif (node[2].sem_type ~= "bool") then
     126	      Error(string.format("operation '%s' cannot be made over right type '%s'.", node.op, node[2].sem_type), node.line)
        	    end
     192	    if (node[1].sem_dimension ~= 0) then
     186	      Error(string.format("operation '%s' cannot be made over arrays values, but left side of expression has dimension '%d'.", node.op, node[1].sem_dimension), node.line)
     481	    elseif (node[2].sem_dimension ~= 0) then
     506	      Error(string.format("operation '%s' cannot be made over arrays values, but right side of expression has dimension '%d'.", node.op, node[2].sem_dimension), node.line)
        	    end
     750	    node.sem_type = "bool"
     530	    node.sem_dimension = 0
     120	  elseif (node.op == "=" or node.op == "<>") then
     178	    if (node[1].sem_type ~= node[2].sem_type) then
     580	      if ((node[1].sem_type ~= "int" and node[1].sem_type ~= "char") or (node[2].sem_type ~= "int" and node[2].sem_type ~= "char")) then
     189	        Error(string.format("operation '%s' require 'int' or 'char' expressions on both sides, but got '%s' and '%s'.", node.op, node[1].sem_type, node[2].sem_type), node.line)
        	      end
        	    end
      12	    if (node[1].sem_dimension ~= node[2].sem_dimension) then
      61	      Error(string.format("operation '%s' require variables with same dimension, but got dimensions '%s' and '%s'.", node.op, node[1].sem_dimension, node[2].sem_dimension), node.line)
        	    end
     150	    node.sem_type = "bool"
     169	    node.sem_dimension = 0
     219	  elseif (node.op == ">" or node.op == "<" or node.op == ">=" or node.op == "<=" or 
     138	          node.op == "+" or node.op == "-" or node.op == "*" or node.op == "/") then
     139	    if (node[1].sem_type ~= "int" and node[1].sem_type ~= "char") then
     184	      Error(string.format("operation '%s' require 'int' or 'char' expression on both sides, but got type '%s' on left side.", node.op, node[1].sem_type), node.line)
     152	    elseif (node[2].sem_type ~= "int" and node[2].sem_type ~= "char") then
      58	      Error(string.format("operation '%s' require 'int' or 'char' expression on both sides, but got type '%s' on right side.", node.op, node[2].sem_type), node.line)
      69	    elseif (node[1].sem_dimension ~= 0) then
      85	      Error(string.format("operation '%s' require dimension '0' on both sides, but got dimension '%d' on left side.", node.op, node[1].sem_dimension), node.line)
      99	    elseif (node[2].sem_dimension ~= 0) then
      98	      Error(string.format("operation '%s' require dimension '0' on both sides, but got dimension '%d' on right side.", node.op, node[2].sem_dimension), node.line)
        	    end
      32	    node.sem_dimension = 0
      67	    if (node.op == ">" or node.op == "<" or node.op == ">=" or node.op == "<=") then
      90	      node.sem_type = "bool"
        	    else
     124	      node.sem_type = "int"
        	    end
        	  else
      52	    Error(string.format("unknown operation '%s'.", node.op), node.line)
        	  end
        	end
        	
        	--VerifyProgram: Verify integrity of PROGRAM node
        	--  Parameters:
        	--    [1] $table  = PROGRAM node
        	--  Return:
     160	function Semantic.VerifyProgram (t)
     506	  if (_DEBUG) then print("SEM :: VerifyProgram") end
     551	  assert(t.id == nodes_codes["PROGRAM"])
     411	  SymbolClass.AddScope()
     535	  Semantic.VerifyGlobals(t)
     749	  for _, node in ipairs(t) do
     486	    if (node.id == nodes_codes["DECLARE"]) then
        	      -- DO NOT VERIFY. SYMBOL ADDED IN GLOBALS
     480	    elseif (node.id == nodes_codes["FUNCTION"]) then
     480	      Semantic.VerifyFunction(node)
        	    else
     177	      Error("unknown program node.")
        	    end
        	  end
     297	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyReturn: Verify integrity of RETURN node
        	--  Parameters:
        	--    [1] $table  = RETURN node
        	--  Return:
      78	function Semantic.VerifyReturn (node)
      53	  if (_DEBUG) then print("SEM :: VerifyReturn") end
      57	  assert(node.id == nodes_codes["RETURN"])
      60	  local symbol = SymbolClass.GetSymbol("@ret")
      93	  if (not symbol) then
     138	    Error(string.format("function with return 'void' must not attempt to call 'return'."), node.line)
     148	  elseif (node.exp) then
     117	    Semantic.VerifyExpression(node.exp)
      76	    Semantic.VerifyCompatibleTypes(node.line, symbol.type, symbol.dimension, node.exp.sem_type, node.exp.sem_dimension)
      93	  elseif (symbol.type) then
     126	    Error(string.format("function expected to return type '%s' but got 'nil'.", symbol.type), node.line)
        	  else
      73	    Error("unknown function return error.", node.line)
        	  end
        	end
        	
        	--VerifyUnary: Verify integrity of UNARY node
        	--  Parameters:
        	--    [1] $table  = UNARY node
        	--  Return:
       3	function Semantic.VerifyUnary (node)
      13	  if (_DEBUG) then print("SEM :: VerifyUnary") end
      30	  assert(node.id == nodes_codes["UNARY"])
      23	  Semantic.VerifyExpression(node.exp)
     116	  if ((node.exp.sem_type ~= "int" and node.exp.sem_type ~= "char") or node.exp.sem_dimension ~= 0) then
     115	    Error(string.format("'unary' must be done over type 'char' or 'int' with dimension '0', but got type '%s' with dimension '%d'.", node.exp.sem_type, node.exp.sem_dimension), node.line)
        	  end
     264	  node.sem_type = node.exp.sem_type
     470	  node.sem_dimension = node.exp.sem_dimension
        	end
        	
        	--VerifyValue: Verify integrity of VALUE node
        	--  Parameters:
        	--    [1] $table  = VALUE node
        	--  Return:
     614	function Semantic.VerifyValue (node)
     484	  if (_DEBUG) then print("SEM :: VerifyValue") end
     270	  assert(node.id == nodes_codes["VALUE"])
     126	  node.sem_type = node.type
     107	  node.sem_dimension = 0
        	end
        	
        	--VerifyVar: Verify integrity of VAR node
        	--  Parameters:
        	--    [1] $table  = VAR node
        	--  Return:
     251	function Semantic.VerifyVar (node)
     544	  if (_DEBUG) then print("SEM :: VerifyVar") end
     508	  assert(node.id == nodes_codes["VAR"])
     393	  local symbol = SymbolClass.GetSymbol(node.name)
     207	  if (not symbol) then
     216	    Error(string.format("symbol '%s' was not declared.", node.name), node.line)
        	  end
     389	  node.sem_type = symbol.type
     380	  if (symbol.dimension and symbol.dimension > 0) then
     246	    if (node.array) then
     250	      if (#node.array > symbol.dimension) then
     277	        Error(string.format("symbol '%s' dimension is '%d', but was called with dimension '%d'.", node.name, symbol.dimension, #node.array), node.line)
        	      end
     170	      for _, exp in ipairs(node.array) do
     110	        Semantic.VerifyExpression(exp)
     247	        if (exp.sem_type ~= "int" and exp.sem_type ~= "char") then
     237	          Error(string.format("symbol '%s' dimension must be an 'int' or 'char', but was called with dimension '%s'.", node.name, exp.sem_type), node.line)
        	        end
        	      end
        	    end
      46	    node.sem_dimension = symbol.dimension - #node.array
     175	  elseif (node.array and #node.array > 0) then
      64	    Error(string.format("symbol '%s' dimension is '0', but was called with dimension '%d'.", node.name, #node.array), node.line)
        	  else
      83	    node.sem_dimension = 0
        	  end
        	end
        	
        	--VerifyWhile: Verify integrity of WHILE node
        	--  Parameters:
        	--    [1] $table  = WHILE node
        	--  Return:
     128	function Semantic.VerifyWhile (node)
      10	  if (_DEBUG) then print("SEM :: VerifyWhile") end
     199	  assert(node.id == nodes_codes["WHILE"])
      10	  SymbolClass.AddScope()
       5	  Semantic.VerifyExpression(node.cond)
       7	  if (node.cond.sem_type ~= "bool" or node.cond.sem_dimension ~= 0) then
      67	    Error(string.format("While expects 'bool' expression with dimension '0', but got type '%s' with dimension '%d'.", node.cond.sem_type, node.cond.sem_dimension), node.line)
        	  end
      76	  Semantic.VerifyBlock(node.block)
     232	  SymbolClass.RemoveScope()
        	end
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Open:
        	--  parameters:
        	--    [1] $table   - table with AST tree nodes
        	--  return:
        	--    [1] $boolean - false if found any problem, true otherwise
        	--    [2] $string  - only when [1] is false, informing which error occurs
      14	function Semantic.Open (t)
      56	  if (_DEBUG) then print("SEM :: Open") end
      43	  assert(t and type(t) == "table")
      43	  SymbolClass.Clear()
      97	  local ok, msg = pcall(function () Semantic.VerifyProgram(t) end)
      44	  if (not ok) then
      34	    return false, msg
        	  end
      15	  if (printTree) then
      86	    Semantic.Print(t)
        	  end
      96	  return true
        	end
        	
        	--Print: Print Abstract Semantic Tree with comprehensible format
        	--  parameters:
        	--  return:
       1	function Semantic.Print (t)
*******0	  PrintClass.Print(t)
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       1	return Semantic

==============================================================================
./src/symbol_table.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      16	require "lib/util"
      16	local NodesClass  = require "lib/node_codes"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      16	local SymbolTable = {}
        	
      16	local scopes = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
      16	local nodes_codes = NodesClass.GetNodesList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
      16	function Error ()
*******0	  error("Symbol error.", 0)
        	end
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--AddScope: Insert a new scope level
        	--  parameters:
        	--  return:
      16	function SymbolTable.AddScope ()
    1707	  if (_DEBUG) then print("SYB :: AddScope") end
    1707	  scopes[#scopes + 1] = {}
        	end
        	
        	--Clear: Remove all scopes
        	--  parameters:
        	--  return:
      16	function SymbolTable.Clear ()
     650	  if (_DEBUG) then print("SYB :: Clear") end
     650	  scopes = {}
        	end
        	
        	--GetCurrentScopeSymbol: Get symbol only if present in current scope
        	--  parameters:
        	--    [1] $string         - Symbol name
        	--  return:
        	--    [1] $table or $nil  - Copy of symbol structure if found, otherwise nil
     412	function SymbolTable.GetCurrentScopeSymbol (name)
    1226	  if (_DEBUG) then print("SYB :: GetCurrentScopeSymbol") end
     964	  local num_scope = #scopes
     609	  if (scopes[#scopes][name]) then
     161	    local symbol = util.TableCopy(scopes[#scopes][name])
     155	    symbol.name = name
     131	    return symbol
        	  end
     448	  return nil
        	end
        	
        	--GetSymbol: Get symbol if present in current or above scopes
        	--  parameters:
        	--    [1] $string         - Symbol name
        	--  return:
        	--    [1] $table or $nil  - Copy of symbol structure if found, otherwise nil
     813	function SymbolTable.GetSymbol (name)
    2287	  if (_DEBUG) then print("SYB :: GetSymbol") end
    2289	  local num_scope = #scopes
    4524	  while (num_scope > 0) do
    3364	    if (scopes[num_scope][name]) then
    1674	      local symbol = util.TableCopy(scopes[num_scope][name])
    1127	      symbol.name = name
    1356	      return symbol
        	    end
    2292	    num_scope = num_scope - 1
        	  end
     905	  return nil
        	end
        	
        	--Print: Print symbol table
        	--  parameters:
        	--  return:
      11	function SymbolTable.Print ()
*******0	  if (_DEBUG) then print("SYB :: Print") end
*******0	  util.TablePrint(scopes)
        	end
        	
        	--RemoveScope: Remove current scope
        	--  parameters:
        	--  return:
      11	function SymbolTable.RemoveScope ()
     476	  if (_DEBUG) then print("SYB :: RemoveScope") end
     476	  scopes[#scopes] = nil
        	end
        	
        	--SetSymbol: Create a new symbol in current scope
        	--          function or var
        	--  parameters:
        	--    [1] $table  - 
        	--              id   = $number - 
        	--              name = $string - 
        	--              line = $number - 
        	--              func_params {
        	--                params        = $table  - 
        	--                ret_type      = $string - 
        	--                ret_dimension = $number - 
        	--              }
        	--              var_params {
        	--                type
        	--                dimension = $number - 
        	--              }
        	--  return:
     349	function SymbolTable.SetSymbol (t)
    1721	  if (_DEBUG) then print("SYB :: SetSymbol") end
    1882	  assert(t and type(t) == "table")
    1882	  assert(t.line and type(t.line) == "number")
    1721	  assert(t.name and type(t.name) == "string")
    1692	  local symbol = {}
    1529	  symbol.line = t.line
    1529	  symbol.name = t.name
    1529	  if (t.id == nodes_codes["FUNCTION"]) then
     768	    symbol.id = "function"
     768	    symbol.params = util.TableCopy(t.params)
     768	    symbol.ret_type = t.ret_type
     770	    symbol.ret_dimension = t.ret_dimension
     807	  elseif (t.id == nodes_codes["DECLARE"] or t.id == nodes_codes["PARAMETER"]) then
     807	    symbol.id = "variable"
     807	    symbol.type = t.type
    1145	    symbol.dimension = t.dimension
        	  else
*******0	    Error()
        	  end
    1383	  scopes[#scopes] = scopes[#scopes] or {}
    1383	  scopes[#scopes][t.name] = symbol
        	  --util.TablePrint(scopes)
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      11	return SymbolTable

==============================================================================
./src/syntactic.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      16	local ParserClass 	= require "src/parser"
      16	local LanguageClass = require "src/grammar"
      16	local ASTClass		  = require "src/syntax_tree"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      16	local Syntactic = {}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--GetTree:
      16	function Syntactic.GetTree()
     650	  if (_DEBUG) then print("SYN :: GetTree") end
     650	  return ASTClass.GetTree()
        	end
        	
        	--Open:
        	--  parameters:
        	--    [1] $table   - table with tokens read in lexical
        	--  return:
        	--    [1] $boolean - false if found any problem, true otherwise
        	--    [2] $string  - only when [1] is false, informing which error occurs
      16	function Syntactic.Open (t)
    1066	  if (_DEBUG) then print("SYN :: Open") end
    1066	  assert(t and type(t) == "table")
    1066	  ParserClass.Open(t)
    1066	  local ok, msg = LanguageClass.Start(ParserClass.Advance, ParserClass.Peek, ParserClass.Peek2)
    1066	  if (not ok) then
     416	  	return false, msg
        	  end
     650	  return true
        	end
        	
        	--PrintTree:
      16	function Syntactic.PrintTree()
*******0	  if (_DEBUG) then print("SYN :: PrintTree") end
*******0	  return ASTClass.Print()
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      16	return Syntactic

==============================================================================
./src/syntax_tree.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
      16	local printTree = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      16	require "lib/util"
      16	local NodesClass  = require "lib/node_codes"
      11	local PrintClass  = require "lib/util_tree"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      11	local AbstractSyntaxTree = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
      11	local nodes_codes = NodesClass.GetNodesList()
        	
        	--  AST tree (structed nodes)
      11	local tree = {}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--GetTree:
      11	function AbstractSyntaxTree.GetTree ()
        	  --return util.TableCopy(tree)
     463	  return tree
        	end
        	
        	--NewAttributionNode:
        	--  {
        	--    id    = $number - ATTRIBUTION code
        	--    exp   = $table  - EXPRESSION node
        	--    line  = $number - line number
        	--    var   = $table  - VAR node
        	--  }
        	--  parameters:
        	--  return:
      11	function AbstractSyntaxTree.NewAttributionNode (var, expression)
    1101	  if (_DEBUG) then print("AST :: NewAttributionNode") end
    1101	  local node = {
    1101	    id    = nodes_codes["ATTRIBUTION"],
    1101	    exp   = expression,
    1106	    line  = var.line,
    1101	    var   = var,
       5	  }
    1101	  return node
        	end
        	
        	--NewCallNode:
        	--  {
        	--    id    = $number - CALL code
        	--    line  = $number - line number
        	--    name  = $string - var name
        	--    exps  = $table  - list of EXPRESSION nodes
        	--  }
        	--  parameters:
        	--  return:
      16	function AbstractSyntaxTree.NewCallNode (line, name, expressions)
     220	  if (_DEBUG) then print("AST :: NewCallNode") end
     225	  local node = {
     220	    id   = nodes_codes["CALL"],
     220	    line = line,
     225	    name = name,
     220	    exps = expressions,
       5	  }
     220	  return node
        	end
        	
        	--NewDeclVarNode:
        	--  {
        	--    id        = $number - DECLARE code
        	--    line      = $number - line number
        	--    name      = $string - var name
        	--    dimension = $number - var dimension
        	--    type      = $string - [bool, char, int, string]
        	--  }
        	--  parameters:
        	--  return:
      11	function AbstractSyntaxTree.NewDeclVarNode (line, name, typebase, size)
     643	  if (_DEBUG) then print("AST :: NewDeclVarNode") end
     638	  local node = {
     638	    id        = nodes_codes["DECLARE"],
     638	    line      = line,
     638	    name      = name,
     643	    dimension = size,
     638	    type      = typebase,
       5	  }
     638	  if (node.type == "string") then
      19	    node.type = "char"
      10	    node.dimension = node.dimension + 1
        	  end
     124	  return node
        	end
        	
        	--NewElseIfNode:
        	--  {
        	--    id    = $number - ELSEIF code
        	--    block = $table  - list of COMMANDS that will be executed if [cond] is true
        	--    cond  = $table  - EXPRESSION NODE, represents condition
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
      74	function AbstractSyntaxTree.NewElseIfNode (line, condition, block)
      88	  if (_DEBUG) then print("AST :: NewElseIfNode") end
      88	  local node = {
      16	    id          = nodes_codes["ELSEIF"],
      88	    block       = block,
      25	    cond        = condition,
      16	    line        = line,
        	  }
      16	  return node
        	end
        	
        	--NewFunctionNode:
        	--  {
        	--    id            = $number - FUNCTION code
        	--    block         = $table  - list of COMMANDS that will be executed
        	--    line          = $number - line number
        	--    name          = $string - var name
        	--    params        = $table  - list of PARAMETER nodes
        	--    ret_type      = $string - [bool, char, int, string], represents function return type
        	--    ret_dimension = $number - function return dimension
        	--  }
        	--  parameters:
        	--  return:
     578	function AbstractSyntaxTree.NewFunctionNode (line, name, parameters, return_type, return_size, block)
     708	  if (_DEBUG) then print("AST :: NewFunctionNode") end
     708	  local node = {
     708	    id            = nodes_codes["FUNCTION"],
     708	    line          = line,
     708	    name          = name,
     132	    params        = parameters,
     708	    ret_type      = return_type,
     141	    ret_dimension = return_size,
     132	    block         = block,
        	  }
     132	  return node
        	end
        	
        	--NewIfNode:
        	--  {
        	--    id      = $number - IF code
        	--    block   = $table  - list of COMMANDS that will be executed if [cond] is true
        	--    cond    = $table  - EXPRESSION NODE, represents condition
        	--    else    = $table  - list of COMMANDS that will be executed none conditions are true
        	--    elseif  = $table  - list of ELSEIF nodes
        	--    line    = $number - line number
        	--  }
        	--  parameters:
        	--  return:
     164	function AbstractSyntaxTree.NewIfNode (line, condition, block, elseif_node, else_block)
     198	  if (_DEBUG) then print("AST :: NewIfNode") end
     198	  local node = {
     198	    id          = nodes_codes["IF"],
     198	    block       = block,
      36	    cond        = condition,
     198	    ["else"]    = else_block,
      45	    ["elseif"]  = elseif_node,
      36	    line        = line,
        	  }
      36	  return node
        	end
        	
        	--NewNegateNode:
        	--  {
        	--    id    = $number - NEGATE code
        	--    exp   = $table  - EXPRESSION node
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
     106	function AbstractSyntaxTree.NewNegateNode (line, expression)
     128	  if (_DEBUG) then print("AST :: NewNegateNode") end
      24	  local node = {
     128	    id    = nodes_codes["NEGATE"],
      38	    exp   = expression,
      24	    line  = line,
       5	  }
      24	  return node
        	end
        	
        	--NewNewVarNode:
        	--  {
        	--    id        = $number - NEWVAR code
        	--    dimension = $number - var dimension
        	--    exp       = $table  - EXPRESSION node
        	--    line      = $number - line number
        	--    type      = $string - [bool, char, int, string]
        	--  }
        	--  parameters:
        	--  return:
      65	function AbstractSyntaxTree.NewNewVarNode (line, expression, type, dimension)
      77	  if (_DEBUG) then print("AST :: NewNewVarNode") end
      77	  local node = {
      77	    id        = nodes_codes["NEWVAR"],
      14	    dimension = dimension,
      77	    exp       = expression,
      28	    line      = line,
      14	    type      = type,
     187	  }
      19	  return node
        	end
        	
        	--NewOperatorNode:
        	--  {
        	--    id    = $number - OPERATOR code
        	--    line  = $number - line number
        	--    op    = $string - [and or + - * / > < >= <= = <>], one of possible operations
        	--    [1]   = $table  - EXPRESSION node, left side of operator
        	--    [2]   = $table  - EXPRESSION node, right side of operator
        	--  }
        	--  parameters:
        	--  return:
    1365	function AbstractSyntaxTree.NewOperatorNode (line, left, operator, right)
    1575	  if (_DEBUG) then print("AST :: NewOperatorNode") end
    1575	  local node = {
     656	    id    = nodes_codes["OPERATOR"],
    1575	    line  = line,
    1131	    op    = operator,
     665	    left,
       5	    right,
     212	  }
     212	  return node
        	end
        	
        	--NewParameterNode:
        	--  {
        	--    id        = $number - PARAMETER code
        	--    dimension = $number - var dimension
        	--    line      = $number - line number
        	--    name      = $string - var name
        	--    type      = $string - [bool, char, int, string]
        	--  }
        	--  parameters:
        	--  return:
     358	function AbstractSyntaxTree.NewParameterNode (line, name, typebase, size)
     416	  if (_DEBUG) then print("AST :: NewProgramNode") end
     416	  local node = {
     330	    id        = nodes_codes["PARAMETER"],
     146	    line      = line,
     335	    name      = name,
      69	    dimension = size,
      60	    type      = typebase,
        	  }
      60	  return node
        	end
        	
        	--NewParenthesisNode:
        	--  {
        	--    id    = $number - PARENTHESIS code
        	--    exp   = $table  - EXPRESSION node
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
     226	function AbstractSyntaxTree.NewParenthesisNode (line, expression)
     224	  if (_DEBUG) then print("AST :: NewParenthesisNode") end
     224	  local node = {
     224	    id    = nodes_codes["PARENTHESIS"],
     233	    exp   = expression,
        	    line  = line,
     224	  }
       5	  return node
        	end
        	
        	--NewProgramNode:
        	--  {
        	--    id       = $number - PROGRAM code
        	--    [1 to N] = DECLARE or FUNCTION node
        	--  }
        	--  parameters:
        	--  return:
     379	function AbstractSyntaxTree.NewProgramNode (ast_tree)
     468	  if (_DEBUG) then print("AST :: NewProgramNode") end
     508	  tree = {}
     122	  tree = util.TableCopy(ast_tree)
     122	  tree.id = nodes_codes["PROGRAM"]
     122	  if (printTree) then AbstractSyntaxTree.Print() end
        	end
        	
        	--NewReturnNode:
        	--  {
        	--    id    = $number - RETURN code
        	--    line  = $number - line number
        	--    exp   = $table  - EXPRESSION node
        	--  }
        	--  parameters:
        	--  return:
     173	function AbstractSyntaxTree.NewReturnNode (line, expression)
     209	  if (_DEBUG) then print("AST :: NewReturnNode") end
      38	  local node = {
     209	    id    = nodes_codes["RETURN"],
      47	    exp   = expression,
      38	    line  = line,
        	  }
      38	  return node
        	end
        	
        	--NewUnaryNode:
        	--  {
        	--    id    = $number - UNARY code
        	--    exp   = $table  - EXPRESSION node
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
      69	function AbstractSyntaxTree.NewUnaryNode (line, expression)
     367	  if (_DEBUG) then print("AST :: NewUnaryNode") end
      21	  local node = {
      83	    id    = nodes_codes["UNARY"],
      25	    exp   = expression,
      16	    line  = line,
        	  }
      16	  return node
        	end
        	
        	--NewValueNode:
        	--  {
        	--    id    = $number   - VALUE code
        	--    line  = $number - line number
        	--    type  = $string   - [bool, char, int, string]
        	--    value = $string   - if type == char or string,
        	--            $number   - if type == int,
        	--            $boolean  - if type == bool,
        	--  }
        	--  parameters:
        	--  return:
    1347	function AbstractSyntaxTree.NewValueNode (line, type, value)
    1637	  if (_DEBUG) then print("AST :: NewValueNode") end
    1637	  local node = {
     292	    id    = nodes_codes["VALUE"],
    1637	    line  = line,
     306	    type  = type,
     292	    value = value,
        	  }
     292	  return node
        	end
        	
        	--NewVarNode:
        	--  {
        	--    id    = $number - VAR code
        	--    array = $table  - list of EXPRESSIONS, one for each dimension
        	--    line  = $number - line number
        	--    name  = $string - var name
        	--  }
        	--  parameters:
        	--  return:
    2284	function AbstractSyntaxTree.NewVarNode (line, name, array)
    2763	  if (_DEBUG) then print("AST :: NewVarNode") end
    2816	  local node = {
     539	    id    = nodes_codes["VAR"],
    2763	    line  = line,
     543	    name  = name,
     534	    array = array,
        	  }
     534	  return node
        	end
        	
        	--NewWhileNode:
        	--  {
        	--    id    = $number - WHILE code
        	--    block = $table  - list of COMMANDS that will be executed if [cond] is true
        	--    cond  = $table  - EXPRESSION node, represents condition
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
      80	function AbstractSyntaxTree.NewWhileNode (line, condition, block)
      88	  if (_DEBUG) then print("AST :: NewWhileNode") end
      88	  local node = {
      10	    id    = nodes_codes["WHILE"],
      88	    block = block,
      24	    cond  = condition,
      10	    line  = line,
        	  }
      10	  return node
        	end
        	
        	--Print: Print Abstract Syntax Tree with comprehensible format
        	--  parameters:
        	--  return:
       2	function AbstractSyntaxTree.Print ()
*******0	  if (_DEBUG) then print("AST :: Print") end
*******0	  PrintClass.Print(tree)
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       2	return AbstractSyntaxTree

==============================================================================
src/auto_test.lua
==============================================================================
        	--==============================================================================
        	-- Global Defines
        	--==============================================================================
        	
      16	_DEBUG = false
      15	local printFailMessage = true
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      16	require "lib/util"
      16	local Lexical   = require "src/lexical"
      16	local Syntactic = require "src/syntactic"
      15	local Semantic  = require "src/semantic"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      15	local files = {
       1	  {
      16	    name      = "nil_file",
      16	    open      = false,
      15	  },
       1	  {
      16	    name      = "lex_fail",
      16	    open      = true,
      16	    lexical   = false,
      16	  },
        	  {
      16	    name      = "lex_overload_01",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = false,
      16	  },
        	  {
      16	    name      = "lex_overload_02",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = false,
      16	  },
        	  {
      16	    name      = "lex_overload_03",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = false,
      16	  },
        	  {
      16	    name      = "lex_overload_04",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = false,
      16	  },
       1	  {
      15	    name      = "sem_complete_program",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = true,
      16	  },
       1	  {
      15	    name      = "sem_elseif_block",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = true,
      16	  },
       1	  {
      15	    name      = "sem_fail_attrib_string_char",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      15	    name      = "sem_fail_attrib_char_string",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      15	    name      = "sem_fail_attrib_int_bool",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      15	    name      = "sem_fail_call_not_function",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      15	    name      = "sem_fail_call_wrong_param_number",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      15	    name      = "sem_fail_declare_same_name_01",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      15	    name      = "sem_fail_declare_same_name_02",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  }, 
       1	  {
      15	    name      = "sem_fail_elseif_condition",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      15	    name      = "sem_fail_exp_negate_char",
      15	    open      = true,
      15	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      16	    name      = "sem_fail_exp_sum_bool",
      15	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      16	    name      = "sem_fail_exp_unary_bool",
      15	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      16	    name      = "sem_fail_func_ret_dimension_different",
      15	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      16	    name      = "sem_fail_func_ret_nil",
      15	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      16	    name      = "sem_fail_func_ret_type_different",
      15	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      16	    name      = "sem_fail_func_same_par_name",
      15	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      16	    name      = "sem_fail_func_void_return",
      15	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      15	    name      = "sem_fail_if_condition_int",
      14	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       2	  {
      14	    name      = "sem_fail_var_array_bool",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      16	  },
       1	  {
      15	    name      = "sem_fail_var_array_dimension_zero",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      15	  },
       2	  {
       9	    name      = "sem_fail_var_array_larger",
      10	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      15	  },
       8	  {
       9	    name      = "sem_fail_var_existent",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = false,
      15	  },
       8	  {
       8	    name      = "sem_fail_var_undeclared",
      15	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      15	    semantic  = false,
      16	  },
        	
        	
       9	  {
      16	    name      = "00-fail-empty",
      16	    open      = true,
      15	    lexical   = true,
      16	    syntactic = false,
      16	  },
       1	  {
      16	    name      = "01-global",
      16	    open      = true,
      15	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = true,
      16	  },
       1	  {
      16	    name      = "02-fun",
      16	    open      = true,
      15	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = true,
      15	  },
       2	  {
      16	    name      = "03-nls",
      16	    open      = true,
      15	    lexical   = true,
      16	    syntactic = true,
      15	    semantic  = false,
      16	  },
       2	  {
      16	    name      = "04-funglobal",
      15	    open      = true,
      16	    lexical   = true,
      15	    syntactic = true,
      16	    semantic  = true,
      16	  },
       2	  {
      16	    name      = "05-params",
      15	    open      = true,
      16	    lexical   = true,
      15	    syntactic = true,
      16	    semantic  = false,
      10	  },
       8	  {
      15	    name      = "06-declvar",
      16	    open      = true,
      16	    lexical   = true,
      15	    syntactic = true,
      10	    semantic  = false,
      16	  },
       8	  {
      15	    name      = "07-if",
      16	    open      = true,
      15	    lexical   = true,
      10	    syntactic = true,
      16	    semantic  = false,
      15	  },
       9	  {
      15	    name      = "08-fail-else",
      16	    open      = true,
      15	    lexical   = true,
      10	    syntactic = false,
      15	  },
       9	  {
      16	    name      = "09-fail-elseif",
      15	    open      = true,
      15	    lexical   = true,
      16	    syntactic = false,
       9	  },
       9	  {
      16	    name      = "10-fail-if",
      16	    open      = true,
      15	    lexical   = true,
      15	    syntactic = false,
      10	  },
       8	  {
      16	    name      = "11-ifdecl",
      16	    open      = true,
      15	    lexical   = true,
      16	    syntactic = true,
      15	    semantic  = false,
      10	  },
       8	  {
      16	    name      = "12-while",
      15	    open      = true,
      16	    lexical   = true,
      15	    syntactic = true,
      10	    semantic  = false,
      15	  },
       9	  {
      15	    name      = "13-fail-while",
      16	    open      = true,
      16	    lexical   = true,
      15	    syntactic = false,
      10	  },
       8	  {
      15	    name      = "14-ifwhile",
      16	    open      = true,
      16	    lexical   = true,
      15	    syntactic = true,
      16	    semantic  = true,
       9	  },
       8	  {
      16	    name      = "15-fail-ifwhile",
      16	    open      = true,
      16	    lexical   = true,
      15	    syntactic = false,
      10	  },
       7	  {
      16	    name      = "16-atrib",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      15	    semantic  = true,
       9	  },
       8	  {
      16	    name      = "17-call",
      16	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
       8	    semantic  = true,
      15	  },
       9	  {
      16	    name      = "18-fail-call",
      16	    open      = true,
      16	    lexical   = true,
      15	    syntactic = false,
       9	  },
       8	  {
      16	    name      = "19-callargs",
      16	    open      = true,
      16	    lexical   = true,
      15	    syntactic = true,
      15	    semantic  = false,
       9	  },
       9	  {
      16	    name      = "19-fail-callargs",
      16	    open      = true,
      15	    lexical   = true,
      15	    syntactic = false,
      16	  },
       2	  {
      16	    name      = "20-return",
      16	    open      = true,
      15	    lexical   = true,
      15	    syntactic = true,
      16	    semantic  = true,
      16	  },
       2	  {
      16	    name      = "21-arrays",
      15	    open      = true,
      15	    lexical   = true,
      16	    syntactic = true,
      16	    semantic  = true,
      10	  },
       8	  {
      16	    name      = "21-return-noargs",
      14	    open      = true,
      16	    lexical   = true,
      16	    syntactic = true,
      10	    semantic  = false,
      16	  },
       8	  {
      14	    name      = "22-exp",
      16	    open      = true,
      16	    lexical   = true,
      10	    syntactic = true,
      16	    semantic  = false,
      15	  },
       7	  {
      16	    name      = "22-fail-exp",
      15	    open      = true,
       9	    lexical   = true,
      15	    syntactic = false,
      14	  },
       7	  {
      15	    name      = "23-fail-fun",
      15	    open      = true,
      10	    lexical   = true,
      16	    syntactic = false,
      72	  },
      64	  {
      15	    name      = "24-fail-fun2",
      73	    open      = true,
      66	    lexical   = true,
      72	    syntactic = false,
      71	  },
       7	  {
      15	    name      = "25-fail-fun3",
      15	    open      = true,
      66	    lexical   = true,
      72	    syntactic = false,
      71	  },
       7	  {
      15	    name      = "26-fail-fun4",
      72	    open      = true,
       9	    lexical   = true,
      15	    syntactic = false,
      71	  },
       8	  {
      15	    name      = "27-fail-global",
      71	    open      = true,
      65	    lexical   = true,
      15	    syntactic = false,
      14	  },
       7	  {
      15	    name      = "28-fail-block",
      15	    open      = true,
      66	    lexical   = true,
      71	    syntactic = false,
      70	  },
       8	  {
      14	    name      = "29-fail-params",
      71	    open      = true,
       9	    lexical   = true,
      15	    syntactic = false,
      70	  },
       8	  {
      14	    name      = "30-fail-param",
      15	    open      = true,
       9	    lexical   = true,
      15	    syntactic = false,
      14	  },
      65	  {
      70	    name      = "31-fail-type",
      71	    open      = true,
       8	    lexical   = true,
      14	    syntactic = false,
      69	  },
       7	  {
      14	    name      = "32-fail-declvar",
      70	    open      = true,
      40	    lexical   = true,
       9	    syntactic = false,
      14	  },
      73	  {
      79	    name      = "33-fail-missingexp",
      14	    open      = true,
     137	    lexical   = true,
     103	    syntactic = false,
     108	  },
      72	  {
      79	    name      = "34-fail-invalidexp",
      44	    open      = true,
      14	    lexical   = true,
       8	    syntactic = false,
     109	  },
      88	  {
      73	    name      = "35-expprio",
       8	    open      = true,
       8	    lexical   = true,
      73	    syntactic = true,
       8	    semantic  = false,
      64	  },
     129	  {
      15	    name      = "36-fail-roottoken",
     480	    open      = true,
     416	    lexical   = true,
      74	    syntactic = false,
     485	  },
     409	  {
     415	    name      = "37-invprio",
     415	    open      = true,
     415	    lexical   = true,
       7	    syntactic = true,
      74	    semantic  = false,
      65	  },
     479	}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	local function Run ()
     485	  local num_files = 0
      83	  local num_files_read = 1
     580	  for _, _ in pairs (files) do
     497	    num_files = num_files + 1
        	  end
     971	  for _, valid in ipairs (files) do
        	    local file_str                  --  keeps the convertion of file to string
     630	    local unexpected_error = false  --  inform that an unexpected error occurs (if true stop further tests)
     567	    local expected_error = false    --  inform that an expected error occurs (if true stop further tests)
        	    local ok, msg
        	
        	    -- TEST OPENING
        	    ------------------------------------------------
     962	    if (not unexpected_error and not expected_error) then
     593	      local f = io.open("data/" .. valid.name .. ".txt", "r")
     498	      if (not f and valid.open) then
     403	        unexpected_error = true
*******0	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to open.', num_files_read, num_files, valid.name))
     566	      elseif (f and not valid.open) then
     471	        unexpected_error = true
      71	        print(string.format('(%2s de %2s) FAILURE - File "%s" not expected to open.', num_files_read, num_files, valid.name))
     534	      elseif (not f and not valid.open) then
      44	        expected_error = true
       7	        msg = "@0 file error: could not be opened."
        	      else
     597	        file_str = f:read("*a")
     967	        f:close()
        	      end
        	    end
        	    
        	    -- TEST LEXICAL
        	    ------------------------------------------------
     497	    if (not unexpected_error and not expected_error) then
     559	      ok, msg = Lexical.Open(file_str)
     887	      if (not ok and valid.lexical) then
     221	        unexpected_error = true
      65	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to PASS on lexical. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     555	      elseif (ok and not valid.lexical) then
      57	        unexpected_error = true
*******0	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to FAIL on lexical. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     560	      elseif (not ok and not valid.lexical) then
     548	        expected_error = true
        	      end
        	    end
        	    
        	    -- TEST SYNTAX
        	    ------------------------------------------------
     497	    if (not unexpected_error and not expected_error) then
     551	      ok, msg = Syntactic.Open(Lexical.GetTags())
     749	      if (not ok and valid.syntactic) then
     182	        unexpected_error = true
       1	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to PASS on syntactic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     483	      elseif (ok and not valid.syntactic) then
       1	        unexpected_error = true
*******0	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to FAIL on syntactic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     553	      elseif (not ok and not valid.syntactic) then
     632	        expected_error = true
        	      end
        	    end
        	    
        	    -- TEST SEMANTIC
        	    ------------------------------------------------
     905	    if (not unexpected_error and not expected_error) then
     343	      ok, msg = Semantic.Open(Syntactic.GetTree())
     345	      if (not ok and valid.semantic) then
       1	        unexpected_error = true
       1	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to PASS on semantic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     300	      elseif (ok and not valid.semantic) then
*******0	        unexpected_error = true
*******0	        print(string.format('(%2s de %2s) FAILURE - File "%s" expected to FAIL on semantic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     370	      elseif (not ok and not valid.semantic) then
     313	        expected_error = true
        	      end
        	    end
        	    
        	    -- PASSED ALL TESTS
        	    ------------------------------------------------
     497	    if (not unexpected_error or expected_error) then
     498	      print(string.format('(%2s de %2s) SUCCESS - File "%s".', num_files_read, num_files, valid.name))
     496	      if (expected_error and printFailMessage) then
     183	        print("        ", msg)
        	      end
        	    end
     497	    num_files_read = num_files_read + 1
        	  end
        	end
        	
        	
        	--==============================================================================
        	-- Running
        	--==============================================================================
        	
      14	local ok, msg = pcall(function () Run() end)
       7	if (not ok) then
*******0	  print("Erro inesperado no teste automático. " .. msg)
        	end

==============================================================================
Summary
==============================================================================

31	5	86.11%	./lib/lulex.lua
23	5	82.14%	./lib/node_codes.lua
51	1	98.08%	./lib/token_codes.lua
23	100	18.70%	./lib/util.lua
123	10	92.48%	./lib/util_tree.lua
346	10	97.19%	./src/grammar.lua
176	1	99.44%	./src/lexical.lua
18	0	100.00%	./src/parser.lua
267	2	99.26%	./src/semantic.lua
54	4	93.10%	./src/symbol_table.lua
17	2	89.47%	./src/syntactic.lua
159	2	98.76%	./src/syntax_tree.lua
522	6	98.86%	src/auto_test.lua
------------------------
1810	148	92.44%	
