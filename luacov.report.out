
==============================================================================
./lib/lulex.lua
==============================================================================
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      19	local Lulex = {}
        	
        	local rex_ok, rex
        	
      38	for _, flavor in ipairs{"gnu", "pcre", "tre", "posix", "oniguruma"} do
      38	   rex_ok, rex = pcall(require, "rex_"..flavor)
      38	   if rex_ok then
      19	      break
        	   end
        	end
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	local function Lua_match(rule, input, at)
*******0	   if (_DEBUG) then print("LLX :: Lua_match") end
*******0	   local match = string.match(input, "^"..rule[1], at)
*******0	   if match then
*******0	      return at + #match
        	   end
        	end
        	
        	local function Re_match(rule, input, at)
 1598654	   if (_DEBUG) then print("LLX :: Re_match") end
 3742806	   if not rule.pat then
     817	      rule.pat = rex.new("^"..rule[1])
        	   end
 3742806	   local start, finish = rule.pat:find(input:sub(at))
 3742806	   if start then
  192112	      return at+(finish-start)+1
        	   end
        	end
        	
        	local function Run(self, input)
    1143	   if (_DEBUG) then print("LLX :: Run") end
    2224	   local at = 1
   89266	   while at <= #input do
   87042	      local lrule = nil
   87042	      local llen = 0
 3829848	      for _, rule in ipairs(self.rules) do
 3742806	         local found = self.match(rule, input, at)
 3742806	         if found then
  192112	            local len = found - at
  192112	            if len > llen then
   87665	               llen = len
   87665	               lrule = rule
        	            end
        	         end
        	      end
   87042	      if lrule then
   87042	         lrule[2](input:sub(at, at+llen-1))
   87042	         at = at + llen
        	      else
*******0	         io.write(input:sub(at, at))
*******0	         at = at + 1
        	      end
        	   end
        	end
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
      19	function Lulex.New(rules, use_lua)
       3	   if (_DEBUG) then print("LLX :: New") end
      19	   return {
      19	      match = (use_lua or not rex_ok) and Lua_match or Re_match,
      19	      rules = rules,
      19	      run = Run,
      19	   }
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      19	return Lulex

==============================================================================
./lib/node_codes.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      19	local Nodes = {}
        	
        	-- code of each node
        	--  {
        	--    ["node id"] = $number,
        	--  }
      19	local codes = {
      19	  ["ATTRIBUTION"] = 01,
      19	  ["CALL"]        = 02,
      19	  ["DECLARE"]     = 03,
      19	  ["ELSEIF"]      = 04,
      19	  ["FUNCTION"]    = 05,
      19	  ["IF"]          = 06,
      19	  ["LITERAL"]     = 07,
      19	  ["NEGATE"]      = 08,
      19	  ["NEWVAR"]      = 09,
      19	  ["OPERATOR"]    = 10,
      19	  ["PARAMETER"]   = 11,
      19	  ["PROGRAM"]     = 12,
      19	  ["RETURN"]      = 13,
      19	  ["UNARY"]       = 14,
      19	  ["VAR"]         = 15,
      19	  ["WHILE"]       = 16,
      16	}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
       3	function Nodes.GetNodesList ()
      31	  return codes
        	end
        	
       3	function Nodes.GetNodeName (node_code)
      16	  assert(type(node_code) == "number")
*******0	  for name, code in pairs(codes) do
*******0	    if (code == node_code) then
*******0	      return name
        	    end
        	  end
*******0	  return nil
        	end
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       3	return Nodes

==============================================================================
./lib/token_codes.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      19	local Tokens = {}
        	
        	-- code of each token
        	--  {
        	--    ["token id"] = $number,
        	--  }
      19	local codes = {
      19	  COMMENT_LINE  = 610,
      19	  COMMENT_BLOCK = 620,
      19	  K_IF          = 101,
      19	  K_THEN        = 102,
      19	  K_ELSE        = 103,
      19	  K_WHILE       = 104,
      19	  K_LOOP        = 105,
      19	  K_FUN         = 106,
      19	  K_RETURN      = 107,
      19	  K_NEW         = 108,
      19	  K_STRING      = 109,
      19	  K_INT         = 110,
      19	  K_CHAR        = 111,
      19	  K_BOOL        = 112,
      19	  K_TRUE        = 113,
      19	  K_FALSE       = 114,
      19	  K_AND         = 115,
      19	  K_OR          = 116,
      19	  K_NOT         = 117,
      19	  K_END         = 118,
      19	  STRING        = 200,
      19	  NUMBER        = 300,
      19	  ["OP_("]      = 401,
      19	  ["OP_)"]      = 402,
      19	  ["OP_,"]      = 403,
      19	  ["OP_:"]      = 404,
      19	  ["OP_>"]      = 405,
      19	  ["OP_<"]      = 406,
      19	  ["OP_>="]     = 407,
      19	  ["OP_<="]     = 408,
      19	  ["OP_="]      = 409,
      19	  ["OP_<>"]     = 410,
      19	  ["OP_["]      = 411,
      19	  ["OP_]"]      = 412,
      19	  ["OP_+"]      = 413,
      19	  ["OP_-"]      = 414,
      19	  ["OP_*"]      = 415,
      19	  ["OP_/"]      = 416,
      19	  LINE_END      = 500,
      19	  ID            = 800,
      19	  ERROR         = 000,
        	}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
      19	function Tokens.GetTokensList ()
      38	  return codes
        	end
        	
      19	function Tokens.GetTokenName (token_code)
     418	  assert(type(token_code) == "number")
   11020	  for name, code in pairs(codes) do
   11020	    if (code == token_code) then
     418	      return name
        	    end
        	  end
*******0	  return nil
        	end
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      19	return Tokens

==============================================================================
./lib/util.lua
==============================================================================
        	--==============================================================================
        	-- Class Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Class Implementation
        	--==============================================================================
        	
      19	util = {}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--FileExists:
        	--  parameters:
        	--    [1] $string  [file path and name including extension to be evaluated]
        	--  return:
        	--    [1] $boolean [true if file exists, false otherwise]
      38	function util.FileExists (file)
*******0	  if (file == nil or type(file) ~= "string" or file == "") then
*******0	    return false
        	  end
*******0	  local f, msg = io.open(file, "r")
*******0	  if (f == nil) then
*******0	    return false
        	  end
*******0	  f:close()
*******0	  return true
        	end
        	
        	--FileRemoveExtension()
        	--  parameters:
        	--    [1] $string  [file path and name including extension to be evaluated]
        	--  return:
        	--    [1] 
      38	function util.FileRemoveExtension (file)
     360	  assert(file)
     360	  return string.gsub(file, "(.+)%.(.*)","%1")
        	end
        	
        	--FileToTable:
        	--  parameters:
        	--    [1] 
        	--  return:
        	--    [1] 
       6	function util.FileToTable (file)
*******0	  if (file == nil or type(file) ~= "string" or file == "") then
*******0	    return false, "Parameter 'file' is invalid"
        	  end
      16	  local f = io.open(file, "r")
*******0	  if (f == nil) then
*******0	    return false, "Could not open desired file"
        	  end
*******0	  local t = FileToTableAux(f, {})
*******0	  f:close()
*******0	  if (t and type(t) == "table") then
      32	    return true, t
        	  end
      16	  return false, {}
        	end
        	
        	--StringIsNull:
        	--  parameters:
        	--    [1] $string  [string that is going to be evaluated]
        	--  return:
        	--    [1] $boolean [true if string is null]
   22078	function util.StringIsNull (str)
*******0	  return (str == nil or str == "")
        	end
        	
        	--TableCopy:
        	--  parameters:
        	--    [1] $table [table that is going to be duplicated]
        	--  return:
        	--    [1] $table [copy of incoming table]
   66468	function util.TableCopy (t)
   86746	  if (not t or type(t) ~= "table") then
   19079	    return
        	  end
   67667	  local ret = {}
   20284	  local mt = getmetatable(t)
   20284	  if mt then
   22072	    setmetatable(ret, mt)
        	  end
   85069	  for k,v in pairs(t) do
   64785	    v = rawget(t, k)
   64785	    if type(v)== "table" then
   15106	      rawset(ret, k, util.TableCopy(v))
        	    else
   49679	      rawset(ret, k, v)
        	    end
        	  end
   20284	  return ret
        	end
        	
        	--TableGetChanges:
        	--  required:
        	--    [1] $table [old table]
        	--    [2] $table [new table]
        	--  return:
        	--    [1] $table [fields that have been modified from old_table to new_table]
       6	function util.TableGetChanges (old_table, new_table)
*******0	  if not old_table or not new_table then 
*******0	    return 
        	  end
*******0	  local changes = {}
*******0	  for k, v in pairs(old_table) do
*******0	    if type(v) == "table" then
      16	      changes[k] = utils.GetTableChanges(v, new_table[k])
        	    else
*******0	      if new_table[k] ~= nil and new_table[k] ~= v then
*******0	        changes[k] = new_table[k]
        	      end
        	    end
        	  end
      32	  if next(changes) then
*******0	    return changes
        	  end
        	end
        	
        	--TableIsEmpty:
        	--  parameters:
        	--    [1] $table   [table that is going to be valuated]
        	--  return:
        	--    [1] $boolean [true if table is empty, false otherwise]
       6	function util.TableIsEmpty (t)
     139	  assert(type(t) == "table")
     107	  for _, _ in pairs(t) do
      32	    return false
        	  end
      75	  return true
        	end
        	
        	--TablePrint:
        	--  parameters:
        	--    [1] $table [table that is going to be printed]
       6	function util.TablePrint (t)
     174	  if (not t) then
      32	    return
        	  end
     174	  print(TablePrintAux("", t, ""))
        	end
        	
        	--TableToFile:
        	--  parameters:
        	--    [1] $table  [table that is going to be printed]
        	--  return:
        	--    [1] $string [string of copied table]
       6	function util.TableToFile (file, t)
*******0	  if (file == nil or type(file) ~= "string" or file == "") then
*******0	    return false, "Parameter 'file' is invalid"
        	  end
      16	  local f = io.open(file, "w")
*******0	  if (f == nil) then
*******0	    return false, "Could not open desired file"
        	  end
*******0	  if (not t) then
*******0	    return
        	  end
      32	  TableToFileAux(f, "", t, "")
*******0	  f:close()
*******0	  return true
        	end
        	
        	--TableToString:
        	--  parameters:
        	--    [1] $table  [table that is going to be printed]
        	--  return:
        	--    [1] $string [string of copied table]
       6	function util.TableToString (t)
*******0	  if (not t) then
      16	    return
        	  end
*******0	  return TablePrintAux("", t, "")
        	end
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
       3	function FileToTableAux(file, t)
*******0	  local str = file:read()
*******0	  while (str) do
*******0	    if (string.find(str, '%["([^"]+)"%] = {')) then
*******0	      local _, _, field = string.find(str, '%["([^"]+)"%] = {')
*******0	      t[field] = FileToTableAux(file, {})
*******0	    elseif (string.find(str, '%[([^%]]+)%] = {')) then
*******0	      local _, _, n = string.find(str, '%[([^%]]+)%] = {')
*******0	      n = tonumber(n)
*******0	      t[n] = FileToTableAux(file, {})
*******0	    elseif (string.find(str, '%["([^"]+)"%]%s%=%s"([^"]+)"')) then
*******0	      local _, _, field, value = string.find(str, '%["([^"]+)"%]%s%=%s"([^"]+)"')
      16	      t[field] = value
*******0	    elseif (string.find(str, '%[([^%]]+)%]%s%=%s"([^"]+)"')) then
      16	      local _, _, n, value = string.find(str, '%[([^%]]+)%]%s%=%s"([^"]+)"')
*******0	      n = tonumber(n)
*******0	      t[n] = value
*******0	    elseif (string.find(str, "}")) then
*******0	      return t
        	    end
*******0	    str = file:read()
        	  end
        	end
        	
       3	function TablePrintAux (s, t, indent)
    1814	  s = s .. "{\n"
    1814	  local oldindent = indent
    1814	  indent = indent .. "  "
    5824	  for k, v in pairs(t) do
    4010	    if (type(k) == "string") then
    2832	      s = s .. indent .. "[" .. string.format("%q", k) .. "] = "
    1178	    elseif (type(k) == "number") then
    1178	      s = s .. indent .. "[" .. k .. "] = "
        	    end
    4010	    if (type(v) == "table") then
    1656	      s = TablePrintAux(s, v, indent)
    2370	    elseif (type(v) == "string") then
    1482	      s = s .. string.format("%q", v)
        	    else
     904	      s = s .. tostring(v)
        	    end
    4010	    s = s .. ",\n"
        	  end
    1814	  s = s .. oldindent .. "}"
    1814	  return s
        	end
        	
       3	function TableToFileAux (file, s, t, indent)
*******0	  file:write("{\n")
*******0	  local oldindent = indent
*******0	  indent = indent .. "  "
*******0	  for k, v in pairs(t) do
*******0	    if (type(k) == "string") then
*******0	      file:write(indent .. "[" .. string.format("%q", k) .. "] = ")
*******0	    elseif (type(k) == "number") then
*******0	      file:write(indent .. "[" .. k .. "] = ")
        	    end
      32	    if (type(v) == "table") then
*******0	      s = TableToFileAux(file, s, v, indent)
*******0	    elseif (type(v) == "string") then
*******0	      file:write(string.format("%q", v))
        	    else
*******0	      file:write(tostring(v))
        	    end
*******0	    file:write(",\n")
        	  end
*******0	  file:write(oldindent .. "}")
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	

==============================================================================
./lib/util_tree.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      14	local NodesClass  = require "lib/node_codes"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      14	local Print = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
      14	local nodes_codes = NodesClass.GetNodesList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
      14	function Print.Block (indent, t)
      17	  if (t) then
      42	    for _, node in ipairs(t) do
      25	      if (node.id == nodes_codes["ATTRIBUTION"]) then
      11	        Print.ComandAttribution(indent, node)
      14	      elseif (node.id == nodes_codes["IF"]) then
       1	        Print.ComandIf(indent, node)
      13	      elseif (node.id == nodes_codes["RETURN"]) then
       5	        Print.ComandReturn(indent, node)
       8	      elseif (node.id == nodes_codes["WHILE"]) then
       2	        Print.ComandWhile(indent, node)
       6	      elseif (node.id == nodes_codes["DECLARE"]) then
       2	        Print.Declare(indent, node)
       4	      elseif (node.id == nodes_codes["CALL"]) then
       4	        Print.Call(indent, node)
        	      --elseif (node.id == nodes_codes["VAR"]) then
        	        --Print.Variable(indent, node)
        	      else
*******0	        error("block node error")
        	      end
        	    end
        	  end
        	end
        	
      14	function Print.Call (indent, t)
       4	  print(indent .. "CALL [" .. t.name .. "] @" .. t.line .. "  {")
       6	  for _, node in ipairs(t.exps) do
       2	    print(indent .. "  PARAM " .. Print.Expression(node))
        	  end
       4	  local str = indent .. "}"
       4	  if (t.sem_type and t.sem_dimension) then
       3	    str = str .. string.format(" #%s:%d", t.sem_type, t.sem_dimension)
        	  end
       4	  print(str)
        	end
        	
      14	function Print.ComandAttribution (indent, t)
      23	  print(indent .. "ATRIB @" .. t.line .. " {")
      23	  local str = ""
      23	  str = str .. t.var.name
      23	  if (t.var.array) then
      30	    for _, exp in ipairs(t.var.array) do
       7	      str = str .. "[" .. Print.Expression(exp) .. "]"
        	    end
        	  end
      23	  Print.Variable(indent .. "  ", t.var)
        	
      23	  print(indent .. "  =" .. Print.Expression(t.exp))
      23	  print(indent .. "}")
        	end
        	
      14	function Print.ComandElseIf (indent, t)
       2	  print(indent .. "ELSEIF [" .. Print.Expression(t.cond) .. "] @" .. t.line)
       2	  Print.Block(indent .. "  ", t.block)
        	end
        	
      14	function Print.ComandIf (indent, t)
       6	  print(indent .. "IF [" .. Print.Expression(t.cond) .. "] @" .. t.line .. " {")
       6	  Print.Block(indent .. "  ", t.block)
       6	  if (t["elseif"]) then
       8	    for _, elseif_node in ipairs(t["elseif"]) do
       2	      Print.ComandElseIf(indent, elseif_node)
        	    end
        	  end
       6	  if (t["else"]) then
       5	    print(indent .. "ELSE ")
       5	    Print.Block(indent .. "  ", t["else"])
        	  end
       6	  print(indent .. "}")
        	end
        	
      14	function Print.ComandReturn (indent, t)
       8	  print(indent .. "RETURN @" .. t.line .. " {")
       8	  print(indent .. "  " .. Print.Expression(t.exp))
       8	  print(indent .. "}")
        	  -- print(indent .. "RETURN [" .. Print.Expression(t.exp) .. "] @" .. t.line)
        	end
        	
      14	function Print.ComandWhile (indent, t)
       4	  print(indent .. "WHILE [" .. Print.Expression(t.cond) .. "] @" .. t.line .. " {")
       4	  Print.Block(indent .. "  ", t.block)
       4	  print(indent .. "}")
        	end
        	
      14	function Print.Declare (indent, t)
      24	  print(indent .. "DECLARE @" .. t.line .. "{")
      24	  print(indent .. "  ID [" .. t.name .. "] " .. t.type .. string.rep("[]", t.dimension) .. " @" .. t.line)
      24	  print(indent .. "}")
        	  -- print(indent .. "DECLARE [" .. t.name .. "] " .. t.type .. string.rep("[]", t.dimension) .. " @" .. t.line)
        	end
        	
      14	function Print.Expression (t)
     109	  local str = "("
     109	  if (not t) then
       7	    return ""
        	  end
     102	  if (t.id == nodes_codes["PARENTHESIS"]) then
*******0	    str = str .. " (" .. Print.Expression(t.exp) .. ")"
     102	  elseif (t.id == nodes_codes["NEWVAR"]) then
       3	    str = str .. " new [" .. Print.Expression(t.exp) .. "] " .. t.type
      99	  elseif (t.id == nodes_codes["NEGATE"]) then
       1	    str = str .. " not " .. Print.Expression(t.exp)
      98	  elseif (t.id == nodes_codes["UNARY"]) then
*******0	    str = str .. " - " .. Print.Expression(t.exp)
      98	  elseif (t.id == nodes_codes["OPERATOR"]) then
      22	    str = str .. Print.Expression(t[1]) .. " " .. t.op .. " " .. Print.Expression(t[2])
      76	  elseif (t.id == nodes_codes["LITERAL"]) then
      44	    str = str .. " " .. t.value
      32	  elseif (t.id == nodes_codes["CALL"]) then
       2	    str = str .. " " .. t.name .. "("
       2	    if (t.exps) then
       2	      str = str .. Print.Expression(t.exps[1])
       2	      if (t.exps[2]) then
*******0	        for i = 2, #t.exps do
*******0	          str = str .. ", " .. Print.Expression(t.exps[i])
        	        end
        	      end
        	    end
       2	    str = str .. ")"
      30	  elseif (t.id == nodes_codes["VAR"]) then
      30	    str = str .. " " .. t.name
      30	    if (t.array) then
      30	      for _, exp in ipairs(t.array) do
*******0	        str = str .. "["
*******0	        str = str .. Print.Expression(exp)
*******0	        str = str .. "]"
        	      end
        	    end
        	  else
*******0	    error("expression node error")
        	  end
     102	  if (t.sem_type and t.sem_dimension) then
     102	    str = str .. string.format(" #%s:%d", t.sem_type, t.sem_dimension)
        	  end
     102	  return str .. ")"
        	end
        	
      14	function Print.Function (indent, t)
      15	  print(indent .. "FUN [" .. t.name .. "] @" .. t.line .. " {")
      22	  for _, node in ipairs(t.params) do
       7	    print(indent .. "  FUNC_PARAMETER [" .. node.name .. "] " .. node.type .. string.rep("[]", node.dimension))
        	  end
      15	  print(indent .. "  FUNC_RETURN " .. (t.ret_type or "VOID") .. string.rep("[]", t.ret_dimension or 0))
      45	  for _, node in ipairs(t.block) do
      30	    if (node.id == nodes_codes["DECLARE"]) then
       8	      Print.Declare(indent .. "  ", node)
      22	    elseif (node.id == nodes_codes["CALL"]) then
*******0	      Print.Call(indent .. "  ", node)
      22	    elseif (node.id == nodes_codes["ATTRIBUTION"]) then
      12	      Print.ComandAttribution(indent .. "  ", node)
      10	    elseif (node.id == nodes_codes["IF"]) then
       5	      Print.ComandIf(indent .. "  ", node)
       5	    elseif (node.id == nodes_codes["RETURN"]) then
       3	      Print.ComandReturn(indent .. "  ", node)
       2	    elseif (node.id == nodes_codes["WHILE"]) then
       2	      Print.ComandWhile(indent .. "  ", node)
        	    end
        	  end
      15	  print(indent .. "}")
        	end
        	
      14	function Print.Program (indent, t)
      10	  print(indent .. "PROGRAM {")
      39	  for _, node in ipairs(t) do
      29	    if (node.id == nodes_codes["DECLARE"]) then
      14	      Print.Declare(indent .. "  ", node)
      15	    elseif (node.id == nodes_codes["FUNCTION"]) then
      15	      Print.Function(indent .. "  ", node)
        	    end
        	  end
      10	  print(indent .. "}")
        	end
        	
      14	function Print.Variable (indent, t)
      23	  local array_str = ""
      30	  for _, exp in ipairs(t.array) do
       7	    array_str = array_str .. "[" .. Print.Expression() .. "]"
        	  end
      23	  print(indent .. "ID [" .. t.name .. "] " .. array_str .. " @" .. t.line)
        	end
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Print: Print Abstract Syntax or Semantic Tree with comprehensible format
        	--  parameters:
        	--  return:
      14	function Print.Print (tree)
      10	  if (_DEBUG) then print("PRT :: Print") end
      10	  Print.Program("", tree)
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      14	return Print

==============================================================================
./src/grammar.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
      19	local printTokensMatch = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      19	local TokensClass = require "lib/token_codes"
      19	local ASTClass    = require "src/syntax_tree"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      19	local Language = {}
        	
        	-- Stores Parser Functions
        	--  {
        	--    $name = $function
        	--  }
      19	local Parser = {}
        	
        	-- Stores Grammar Functions
        	--  {
        	--    $name = $function
        	--  }
      19	local Grammar = {}
        	
        	--  list of tokens
        	--  {
        	--    [name] = $number,
        	--  }
      19	local tokens = TokensClass.GetTokensList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	--Error: Callback of errors that occurs during syntax analysis
        	--  Parameters:
        	--    [1] $number - line number of grammar syntax error
        	--  Return:
        	local function Error (line)
     284	  error(string.format("@%d syntactic error.", line), 0)
        	end
        	
        	--Match: Receives a token code number and compare with next avaiable token received from lexical
        	--  Parameters:
        	--    [1] $number - Next expected token code number
        	--  Return:
        	--    [1] $string - Token value/name
        	--    [2] $number - Token line number
        	local function Match (code)
   62314	  if (_DEBUG) then print("LAN :: Match") end
   62314	  local token = Parser.Peek()
   62314	  if (token and token.code == code) then
   62105	    if (_DEBUG or printTokensMatch) then
*******0	      print(string.format("    Match code '%10s' %s", TokensClass.GetTokenName(code), token.token))
        	    end
   62105	    Parser.Advance()
   62105	    return token.token, token.line
        	  else
     209	    if (token) then
     209	      error(string.format("@%d syntactic error: expected token '%s' got token '%s'.", token.line, TokensClass.GetTokenName(code), TokensClass.GetTokenName(token.code)), 0)
        	    else
*******0	      error(string.format("@EOF syntactic error: expected token '%s' got 'END_OF_TOKENS'.", TokensClass.GetTokenName(code)), 0)
        	    end
        	  end
        	end
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	--Block:
        	--  syntax:
        	--    bloco     → { declvar nl }
        	--                { comando nl }
        	--  parameters:
        	--  return:
        	--    [1] $table  - List of DECLARE, [...] nodes
      19	function Grammar.Block ()
    3348	  if (_DEBUG) then print("LAN :: Grammar_bloco") end
    3348	  local list = {}
*******0	  while (true) do
    4687	    local token = Parser.Peek()
    4687	    local token2 = Parser.Peek2()
    4687	    if (token and token2 and token.code == tokens.ID and token2.code == tokens["OP_:"]) then
    1358	      table.insert(list, Grammar.DeclareVar())
    1358	      Grammar.LineEnd()
        	    else
        	      break
        	    end
        	  end
*******0	  while (true) do
    7582	    local token = Parser.Peek()
    7582	    if (token and
    7582	        token.code == tokens.ID or
    4803	        token.code == tokens.K_IF or
    4264	        token.code == tokens.K_WHILE or
    4119	        token.code == tokens.K_RETURN) then
    4500	      table.insert(list, Grammar.Command() or {}) -- RETIRAR OPCAO {}
    4253	      Grammar.LineEnd()
        	    else
        	      break
        	    end
        	  end
    3082	  return list
        	end
        	
        	--Call:
        	--  syntax:
        	--    chamada   → ID '(' listaexp ')'
        	--  parameters:
        	--  return:
        	--    [1] $table  - CALL node
      19	function Grammar.Call ()
     434	  if (_DEBUG) then print("LAN :: Grammar_chamada") end
        	  local name, line, exps
     434	  name, line = Match(tokens.ID)
     434	  Match(tokens["OP_("])
     434	  exps = Grammar.ListExpressions()
     415	  Match(tokens["OP_)"])
     415	  return ASTClass.NewCallNode(line, name, exps)
        	end
        	
        	--CmdAttrib:
        	--  syntax:
        	--    cmdatrib  → var '=' exp
        	--  parameters:
        	--  return:
        	--    [1] $table  - ATTRIBUTION node
      19	function Grammar.CmdAttrib ()
    2418	  if (_DEBUG) then print("LAN :: Grammar_cmdatrib") end
        	  local var, expression
    2418	  var = Grammar.Var()
    2418	  Match(tokens["OP_="])
    2399	  expression = Grammar.Expression()
    2399	  return ASTClass.NewAttributionNode(var, expression)
        	end
        	
        	--CmdIf:
        	--  syntax:
        	--    cmdif     → 'if' exp nl
        	--                    bloco
        	--                { 'else' 'if' exp nl
        	--                    bloco
        	--                }
        	--                [ 'else' nl
        	--                    bloco
        	--                ]
        	--                'end'
      19	function Grammar.CmdIf ()
     539	  if (_DEBUG) then print("LAN :: Grammar_cmdif") end
        	  local line, condition, block, else_block
     539	  local elseif_nodes = {}
     539	  _, line = Match(tokens.K_IF)
     539	  condition = Grammar.Expression()
     463	  Grammar.LineEnd()
     444	  block = Grammar.Block()
*******0	  while (true) do
     599	    local token = Parser.Peek()
     599	    local token2 = Parser.Peek2()
     599	    if (token and token2 and token.code == tokens.K_ELSE and token2.code == tokens.K_IF) then
        	      local line, condition, block
     212	      _, line = Match(tokens.K_ELSE)
     212	      Match(tokens.K_IF)
     212	      condition = Grammar.Expression()
     174	      Grammar.LineEnd()
     174	      block = Grammar.Block()
     174	      table.insert(elseif_nodes, ASTClass.NewElseIfNode(line, condition, block))
        	    else
        	      break
        	    end
        	  end
     387	  local token = Parser.Peek()
     387	  if (token and token.code == tokens.K_ELSE) then
     174	    Match(tokens.K_ELSE)
     174	    Grammar.LineEnd()
     174	    else_block = Grammar.Block()
        	  end
     387	  Match(tokens.K_END)
     387	  return ASTClass.NewIfNode(line, condition, block, elseif_nodes, else_block)
        	end
        	
        	--CmdReturn:
        	--  syntax:
        	--    cmdreturn → 'return' exp | 'return'
        	--  parameters:
        	--  return:
        	--    [1] $table  - RETURN node
      19	function Grammar.CmdReturn ()
    1037	  if (_DEBUG) then print("LAN :: Grammar_cmdreturn") end
        	  local line, exp
    1037	  _, line = Match(tokens.K_RETURN)
    1037	  local token = Parser.Peek()
    1037	  if (token and token.code ~= tokens.LINE_END) then
     967	    exp = Grammar.Expression()
        	  end
    1037	  return ASTClass.NewReturnNode(line, exp)
        	end
        	
        	--CmdWhile:
        	--  syntax:
        	--    cmdwhile  → 'while' exp nl
        	--                    bloco
        	--                'loop'
        	--  parameters:
        	--  return:
        	--    [1] $table  - WHILE node
      19	function Grammar.CmdWhile ()
     145	  if (_DEBUG) then print("LAN :: Grammar_cmdwhile") end
        	  local line, exp, block
     145	  _, line = Match(tokens.K_WHILE)
     145	  exp = Grammar.Expression()
     145	  Grammar.LineEnd()
     145	  block = Grammar.Block()
     126	  Match(tokens.K_LOOP)
     107	  return ASTClass.NewWhileNode(line, exp, block)
        	end
        	
        	--Command:
        	--  syntax:
        	--    comando   → cmdif | cmdwhile | cmdatrib | cmdreturn | chamada
        	--  parameters:
        	--  return:
        	--    [1] $table - List of DECLARE, CMDATRIB, CMDIF, CMDRETURN, CMDWHILE, [...] nodes
      19	function Grammar.Command ()
    4500	  if (_DEBUG) then print("LAN :: Grammar_comando") end
    4500	  local token = Parser.Peek()
    4500	  if (token and token.code == tokens.K_IF) then
     539	    return Grammar.CmdIf()
    3961	  elseif (token and token.code == tokens.K_WHILE) then
     145	    return Grammar.CmdWhile()
    3816	  elseif (token and token.code == tokens.K_RETURN) then
    1037	    return Grammar.CmdReturn()
    2779	  elseif (token and token.code == tokens.ID) then
    2779	    local token2 = Parser.Peek2()
    2779	    if (token2 and token2.code == tokens["OP_("]) then
     342	      return Grammar.Call()
    2437	    elseif (token2 and 
    2437	            token2.code == tokens["OP_="] or
     195	            token2.code == tokens["OP_["]) then
    2418	      return Grammar.CmdAttrib()
        	    else
      19	      Error(token and token.line or 0)
        	    end
        	  else
*******0	    Error(token and token.line or 0)
        	  end
        	end
        	
        	--Declare:
        	--  syntax:
        	--    decl      → funcao | global
        	--  parameters:
        	--  return:
        	--    [1] $table  - DECLARE or FUNCTION node
      19	function Grammar.Declare ()
    3135	  if (_DEBUG) then print("LAN :: Grammar_decl") end
        	  local decl
    3135	  local token = Parser.Peek()
    3135	  if (token and token.code == tokens.K_FUN) then
    2506	    decl = Grammar.Function(parent_node)
     629	  elseif (token and token.code == tokens.ID) then
     629	    decl = Grammar.Global(parent_node)
        	  else
*******0	    Error(token and token.line or 0)
        	  end
    2736	  return decl
        	end
        	
        	--DeclareVar:
        	--  syntax:
        	--    declvar   → ID ':' tipo
        	--  parameters:
        	--  return:
        	--    [1] $table  - DECLARE node
      19	function Grammar.DeclareVar ()
    1987	  if (_DEBUG) then print("LAN :: Grammar_declvar") end
        	  local name, line, typebase, array
    1987	  name, line = Match(tokens.ID)
    1987	  Match(tokens["OP_:"])
    1968	  typebase, array = Grammar.Type()
    1930	  return ASTClass.NewDeclVarNode(line, name, typebase, array)
        	end
        	
        	--Expression:
        	--  syntax:
        	--    exp       → LITNUMERAL
        	--              | LITSTRING
        	--              | TRUE
        	--              | FALSE
        	--              | var
        	--              | 'new' '[' exp ']' tipo
        	--              | '(' exp ')'
        	--              | chamada
        	--              | exp '+' exp
        	--              | exp '-' exp
        	--              | exp '*' exp
        	--              | exp '/' exp
        	--              | exp '>' exp
        	--              | exp '<' exp
        	--              | exp '>=' exp
        	--              | exp '<=' exp
        	--              | exp '=' exp
        	--              | exp '<>' exp
        	--              | exp 'and' exp
        	--              | exp 'or' exp
        	--              | 'not' exp
        	--              | '-' exp
      19	function Grammar.Expression ()
    5803	  if (_DEBUG) then print("LAN :: Grammar_exp") end
    5803	  local exp = Grammar.ExpressionLevel1()
    5651	  if (not exp) then
     166	    Error(0)
        	  end
    5485	  return exp
        	end
        	
      19	function Grammar.ExpressionLevel1 ()
    5975	  local left = Grammar.ExpressionLevel2()
    5823	  local token = Parser.Peek()
    5823	  if (token and token.code == tokens.K_OR) then
     172	    Match(tokens.K_OR)
     172	    return ASTClass.NewOperatorNode(token.line, left, "or", Grammar.ExpressionLevel1())
        	  end
    5651	  return left
        	end
        	
      19	function Grammar.ExpressionLevel2 ()
    6185	  local left = Grammar.ExpressionLevel3()
    6033	  local token = Parser.Peek()
    6033	  if (token and token.code == tokens.K_AND) then
     210	    Match(tokens.K_AND)
     210	    return ASTClass.NewOperatorNode(token.line, left, "and", Grammar.ExpressionLevel2())
        	  end
    5823	  return left
        	end
        	
      19	function Grammar.ExpressionLevel3 ()
    6759	  local left = Grammar.ExpressionLevel4()
    6607	  local token = Parser.Peek()
    6607	  if (token and token.code == tokens["OP_="]) then
     440	    Match(tokens["OP_="])
     440	    return ASTClass.NewOperatorNode(token.line, left, "=", Grammar.ExpressionLevel3())
    6167	  elseif (token and token.code == tokens["OP_<>"]) then
     134	    Match(tokens["OP_<>"])
     134	    return ASTClass.NewOperatorNode(token.line, left, "<>", Grammar.ExpressionLevel3())
        	  end
    6033	  return left
        	end
        	
      19	function Grammar.ExpressionLevel4 ()
    7289	  local left = Grammar.ExpressionLevel5()
    7137	  local token = Parser.Peek()
    7137	  if (token and token.code == tokens["OP_>"]) then
     171	    Match(tokens["OP_>"])
     171	    return ASTClass.NewOperatorNode(token.line, left, ">", Grammar.ExpressionLevel4())
    6966	  elseif (token and token.code == tokens["OP_<"]) then
     258	    Match(tokens["OP_<"])
     258	    return ASTClass.NewOperatorNode(token.line, left, "<", Grammar.ExpressionLevel4())
    6708	  elseif (token and token.code == tokens["OP_>="]) then
      22	    Match(tokens["OP_>="])
      22	    return ASTClass.NewOperatorNode(token.line, left, ">=", Grammar.ExpressionLevel4())
    6686	  elseif (token and token.code == tokens["OP_<="]) then
      79	    Match(tokens["OP_<="])
      79	    return ASTClass.NewOperatorNode(token.line, left, "<=", Grammar.ExpressionLevel4())
        	  end
    6607	  return left
        	end
        	
      19	function Grammar.ExpressionLevel5 ()
    7855	  local left = Grammar.ExpressionLevel6()
    7703	  local token = Parser.Peek()
    7703	  if (token and token.code == tokens["OP_+"]) then
     407	    Match(tokens["OP_+"])
     407	    return ASTClass.NewOperatorNode(token.line, left, "+", Grammar.ExpressionLevel5())
    7296	  elseif (token and token.code == tokens["OP_-"]) then
     159	    Match(tokens["OP_-"])
     159	    return ASTClass.NewOperatorNode(token.line, left, "-", Grammar.ExpressionLevel5())
        	  end
    7137	  return left
        	end
        	
      19	function Grammar.ExpressionLevel6 ()
    8169	  local left = Grammar.ExpressionLevel7()
    8017	  local token = Parser.Peek()
    8017	  if (token and token.code == tokens["OP_*"]) then
     206	    Match(tokens["OP_*"])
     206	    return ASTClass.NewOperatorNode(token.line, left, "*", Grammar.ExpressionLevel6())
    7811	  elseif (token and token.code == tokens["OP_/"]) then
     108	    Match(tokens["OP_/"])
     108	    return ASTClass.NewOperatorNode(token.line, left, "/", Grammar.ExpressionLevel6())
        	  end
    7703	  return left
        	end
        	
      19	function Grammar.ExpressionLevel7 ()
    8577	  local token = Parser.Peek()
    8577	  if (token and token.code == tokens.NUMBER) then
    2625	    return ASTClass.NewLiteralNode(token.line, "int", Match(tokens.NUMBER))
    5952	  elseif (token and token.code == tokens.STRING) then
     150	    return ASTClass.NewLiteralNode(token.line, "string", Match(tokens.STRING))
    5802	  elseif (token and token.code == tokens.K_TRUE) then
     267	    return ASTClass.NewLiteralNode(token.line, "bool", Match(tokens.K_TRUE))
    5535	  elseif (token and token.code == tokens.K_FALSE) then
     171	    return ASTClass.NewLiteralNode(token.line, "bool", Match(tokens.K_FALSE))
    5364	  elseif (token and token.code == tokens.K_NEW) then
     166	    Match(tokens.K_NEW)
     166	    Match(tokens["OP_["])
     166	    local exp = Grammar.Expression()
     166	    Match(tokens["OP_]"])
     166	    local typebase, dimension = Grammar.Type()
     166	    return ASTClass.NewNewVarNode(token.line, exp, typebase, dimension)
    5198	  elseif (token and token.code == tokens.K_NOT) then
     253	    Match(tokens.K_NOT)
     253	    local exp = Grammar.ExpressionLevel7()
     253	    return ASTClass.NewNegateNode(token.line, exp)
    4945	  elseif (token and token.code == tokens.ID) then
        	    local node
    4293	    local token2 = Parser.Peek2()
    4293	    if (token2 and token2.code == tokens["OP_("]) then
      92	      return Grammar.Call()
        	    else
    4201	      return Grammar.Var()
        	    end
     652	  elseif (token and token.code == tokens["OP_("]) then
     364	    Match(tokens["OP_("])
     364	    local exp = Grammar.Expression()
     345	    Match(tokens["OP_)"])
     345	    return exp
     288	  elseif (token and token.code == tokens["OP_-"]) then
     155	    Match(tokens["OP_-"])
     155	    return ASTClass.NewUnaryNode(token.line, Grammar.ExpressionLevel7())
        	  else
     133	    Error(token and token.line or 0)
        	  end
        	end
        	
        	--Function:
        	--  syntax:
        	--    funcao    → 'fun' ID '(' params ')' [ ':' tipo ] nl
        	--                    bloco
        	--                'end' nl
        	--  parameters:
        	--  return:
        	--    [1] $table  - FUNCTION node
      19	function Grammar.Function ()
    2506	  if (_DEBUG) then print("LAN :: Grammar_funcao") end
        	  local name, line, params, ret_type, array_size, block
    2506	  Match(tokens.K_FUN)
    2506	  name, line = Match(tokens.ID)
    2468	  Match(tokens["OP_("])
    2468	  params = Grammar.Parameters()
    2411	  Match(tokens["OP_)"])
    2411	  local token = Parser.Peek()
    2411	  if (token and token.code == tokens["OP_:"]) then
    1232	    Match(tokens["OP_:"])
    1232	    ret_type, array_size = Grammar.Type()
        	  end
    2411	  Grammar.LineEnd()
    2411	  block = Grammar.Block()
    2183	  Match(tokens.K_END)
    2183	  Grammar.LineEnd()
    2183	  return ASTClass.NewFunctionNode(line, name, params, ret_type, array_size, block)
        	end
        	
        	--Global:
        	--  syntax:
        	--    global    → declvar nl
        	--  parameters:
        	--  return:
        	--    [1] $table  - DECLARE node
      19	function Grammar.Global ()
     629	  if (_DEBUG) then print("LAN :: Grammar_global") end
     629	  local node = Grammar.DeclareVar()
     572	  Grammar.LineEnd()
     553	  return node
        	end
        	
        	--ListExpressions:
        	--  syntax:
        	--    listaexp  → /*vazio*/ | exp { ',' exp }
        	--  parameters:
        	--  return:
        	--    [1] $table  - List of EXPRESSION nodes
      19	function Grammar.ListExpressions ()
     434	  if (_DEBUG) then print("LAN :: Grammar_listaexp") end
     434	  local list = {}
     434	  local token = Parser.Peek()
     434	  if (token and token.code ~= tokens["OP_)"]) then
     325	    table.insert(list, Grammar.Expression())
*******0	    while (true) do
     472	      token = Parser.Peek()
     472	      if (token and token.code == tokens["OP_,"]) then
     166	        Match(tokens["OP_,"])
     166	        table.insert(list, Grammar.Expression())
        	      else
        	        break
        	      end
        	    end
        	  end
     415	  return list
        	end
        	
        	--LineEnd:
        	--  syntax:
        	--    nl        → NL { NL }
      19	function Grammar.LineEnd()
   12930	  if (_DEBUG) then print("LAN :: Grammar_nl") end
   12930	  Match(tokens.LINE_END)
*******0	  while (true) do
   12984	    local token = Parser.Peek()
   12984	    if (token and token.code == tokens.LINE_END) then
     111	      Match(tokens.LINE_END)
        	    else
        	      break
        	    end
        	  end
        	end
        	
        	--Parameter:
        	--  syntax:
        	--    parametro → ID ':' tipo
        	--  parameters:
        	--  return:
        	--    [1] $table  - PARAMETER node
      19	function Grammar.Parameter ()
    1083	  if (_DEBUG) then print("LAN :: Grammar_parametro") end
        	  local name, line, typebase, array_size
    1083	  name, line = Match(tokens.ID)
    1045	  Match(tokens["OP_:"])
    1026	  typebase, array_size = Grammar.Type()
    1026	  return ASTClass.NewParameterNode(line, name, typebase, array_size)
        	end
        	
        	--Parameters:
        	--  syntax:
        	--    params    → /*vazio*/ | parametro { ',' parametro }
        	--  parameters:
        	--  return:
        	--    [1] $table  - List of PARAMETER nodes
      19	function Grammar.Parameters ()
    2468	  if (_DEBUG) then print("LAN :: Grammar_params") end
    2468	  local list = {}
    2468	  local token = Parser.Peek()
    2468	  if (token and token.code ~= tokens["OP_)"]) then
     870	    table.insert(list, Grammar.Parameter())
*******0	    while (true) do
    1026	      token = Parser.Peek()
    1026	      if (token and token.code == tokens["OP_,"]) then
     213	        Match(tokens["OP_,"])
     213	        table.insert(list, Grammar.Parameter())
        	      else
        	        break
        	      end
        	    end
        	  end
    2411	  return list
        	end
        	
        	--Program:
        	--  syntax:
        	--    programa  → { NL } decl { decl }
      19	function Grammar.Program ()
    2206	  if (_DEBUG) then print("LAN :: Grammar_programa") end
    2206	  local node = {}
    2206	  local token = Parser.Peek()
    2206	  if (token and token.code == tokens.LINE_END) then
    1197	    Grammar.LineEnd()
        	  end
    2206	  token = Parser.Peek()
    2206	  if (token and (token.code == tokens.K_FUN or token.code == tokens.ID)) then
    2115	    table.insert(node, Grammar.Declare())
      14	    while (true) do
    2734	      token = Parser.Peek()
    2683	      if (token) then
    1054	        table.insert(node, Grammar.Declare())
        	      else
      23	        break
        	      end
        	    end
        	  else
      90	    Error(token and token.line or 0)
        	  end
    1686	  ASTClass.NewProgramNode(node)
        	end
        	
        	--Type:
        	--  syntax:
        	--    tipo      → tipobase | '[' ']' tipo
        	--  parameters:
        	--  return:
        	--    [1] $typebase
        	--    [2] $array_size
      18	function Grammar.Type (array_size)
    6163	  if (_DEBUG) then print("LAN :: Grammar_tipo") end
    6164	  array_size = array_size or 0
        	  local typebase
    6265	  local token = Parser.Peek()
    6265	  if (token and
    6265	      token.code == tokens.K_INT or
    3888	      token.code == tokens.K_BOOL or
    2941	      token.code == tokens.K_CHAR or
    2219	      token.code == tokens.K_STRING) then
    4290	    typebase = Grammar.Typebase()
    1912	  elseif (token and token.code == tokens["OP_["]) then
    1943	    Match(tokens["OP_["])
    1875	    Match(tokens["OP_]"])
    1873	    array_size = array_size + 1
    1873	    typebase, array_size = Grammar.Type(array_size)
        	  else
      51	    Error(token and token.line or 0)
        	  end
    6129	  return typebase, array_size
        	end
        	
        	--Typebase:
        	--  syntax:
        	--    tipobase  → 'int' | 'bool' | 'char' | 'string'
        	--  parameters:
        	--  return:
        	--    [1] $typebase
      18	function Grammar.Typebase ()
    4269	  if (_DEBUG) then print("LAN :: Grammar_tipobase") end
    4270	  local token = Parser.Peek()
    4354	  if (token and token.code == tokens.K_INT) then
    2462	    Match(tokens.K_INT)
    2462	    return "int"
    1960	  elseif (token and token.code == tokens.K_BOOL) then
    1015	    Match(tokens.K_BOOL)
     964	    return "bool"
     958	  elseif (token and token.code == tokens.K_CHAR) then
     667	    Match(tokens.K_CHAR)
     658	    return "char"
     294	  elseif (token and token.code == tokens.K_STRING) then
     294	    Match(tokens.K_STRING)
     292	    return "string"
        	  else
       1	    Error(token and token.line or 0)
        	  end
        	end
        	
        	--Var:
        	--  syntax:
        	--    var       → ID | var '[' exp ']'
        	--  parameters:
        	--  return:
        	--    [1] $table - VAR node
      18	function Grammar.Var ()
    6403	  if (_DEBUG) then print("LAN :: Grammar_var") end
        	  local name, line
    6619	  local array = {}
    6619	  name, line = Match(tokens.ID)
     216	  while (true) do
    7131	    local token = Parser.Peek()
    6915	    if (token and token.code == tokens["OP_["]) then
     736	      Match(tokens["OP_["])
     736	      table.insert(array, Grammar.Expression())
     520	      Match(tokens["OP_]"])
        	    else
       8	      break
        	    end
        	  end
    6403	  return ASTClass.NewVarNode(line, name, array)
        	end
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
      18	function Language.Start (func_advance, func_peek, func_peek2)
    2150	  if (_DEBUG) then print("LAN :: Start") end
    2151	  assert(type(func_advance) == "function")
    2206	  assert(type(func_peek) == "function")
    2206	  assert(type(func_peek2) == "function")
    2206	  Parser.Advance = func_advance
    2206	  Parser.Peek = func_peek
    2206	  Parser.Peek2 = func_peek2
    4356	  local ok, msg = pcall(function () Grammar.Program() end)
    2206	  if (not ok) then
     580	    return false, msg
        	  end
    1708	  return true
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      18	return Language
        	
        	
        	--==============================================================================
        	-- Grammar
        	--==============================================================================
        	
        	-- programa  → { NL } decl { decl }
        	--
        	-- decl      → funcao | global
        	--
        	-- nl        → NL { NL }
        	--
        	-- global    → declvar nl
        	--
        	-- funcao    → 'fun' ID '(' params ')' [ ':' tipo ] nl
        	--                bloco
        	--             'end' nl
        	--
        	-- bloco     → { declvar nl }
        	--             { comando nl }
        	--
        	-- params    → /*vazio*/ | parametro { ',' parametro }
        	--
        	-- parametro → ID ':' tipo
        	--
        	-- tipo      → tipobase | '[' ']' tipo
        	--
        	-- tipobase  → 'int' | 'bool' | 'char' | 'string'
        	--
        	-- declvar   → ID ':' tipo
        	--
        	-- comando   → cmdif | cmdwhile | cmdatrib | cmdreturn | chamada 
        	--
        	-- cmdif     → 'if' exp nl
        	--                bloco
        	--             { 'else' 'if' exp nl
        	--                bloco
        	--             }
        	--             [ 'else' nl
        	--                bloco
        	--             ]
        	--             'end'
        	--
        	-- cmdwhile  → 'while' exp nl
        	--                bloco
        	--             'loop'
        	--
        	-- cmdatrib  → var '=' exp
        	--
        	-- chamada   → ID '(' listaexp ')'
        	--
        	-- listaexp  → /*vazio*/ | exp { ',' exp }
        	--
        	-- cmdreturn → 'return' exp | 'return'
        	--
        	-- var       → ID | var '[' exp ']'
        	--
        	-- exp       → LITNUMERAL
        	--           | LITSTRING
        	--           | TRUE
        	--           | FALSE
        	--           | var
        	--           | 'new' '[' exp ']' tipo
        	--           | '(' exp ')'
        	--           | chamada
        	--           | exp '+' exp
        	--           | exp '-' exp
        	--           | exp '*' exp
        	--           | exp '/' exp
        	--           | exp '>' exp
        	--           | exp '<' exp
        	--           | exp '>=' exp
        	--           | exp '<=' exp
        	--           | exp '=' exp
        	--           | exp '<>' exp
        	--           | exp 'and' exp
        	--           | exp 'or' exp
        	--           | 'not' exp
        	--           | '-' exp

==============================================================================
./src/intermediate_code.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
       3	local printStruct = false
       3	local _DEBUG = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
       3	require "lib/util"
       1	local NodesClass = require "lib/node_codes"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
       1	local InterCodeGen = {}
        	
        	-- avaiable operator codes of intermediate language
        	--  {
        	--    [name] = $number,
        	--  }
       1	local enum_opcodes = {
       1	  ["CALLID"]            = 01,
       3	  ["GOTO"]              = 02,
       1	  ["IFFALSEGOTO"]       = 03,
       3	  ["IFGOTO"]            = 04,
       1	  ["LABEL"]             = 05,
       1	  ["PARAM"]             = 06,
       1	  ["RETURN"]            = 07,
        	  
        	  
       3	  ["ID=rval"]           = 10,
       1	  ["ID=BYTErval"]       = 11,
       1	  ["ID=ID[rval]"]       = 12,
       3	  ["ID=BYTEID[rval]"]   = 13,
       3	  ["ID=unoprval"]       = 14,
       3	  ["ID=rvalEQrval"]     = 15,
       3	  ["ID=rvalNErval"]     = 16,
       3	  ["ID=rvalGErval"]     = 17,
       3	  ["ID=rvalLErval"]     = 18,
       3	  ["ID=rval<rval"]      = 19,
       3	  ["ID=rval>rval"]      = 20,
       3	  ["ID=rval+rval"]      = 21,
       1	  ["ID=rval-rval"]      = 22,
       1	  ["ID=rval*rval"]      = 23,
       1	  ["ID=rval/rval"]      = 24,
       1	  ["ID[rval]=rval"]     = 25,
       1	  ["ID[rval]=BYTErval"] = 26,
        	}
        	
        	--  store file path
        	local file
        	
        	--  count number of generated labels
       1	local label_counter = 0
        	
        	--  count number of generated variables
       1	local var_counter = 0
        	
        	--  count number of functions
       1	local function_counter = 0
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
       1	local nodes_codes = NodesClass.GetNodesList()
        	
        	--  three address codes
        	--  {
        	--    strings   = {
        	--      [1 to N] = {
        	--        var = $string   - variable name
        	--        str = $string   - literal string
        	--      }
        	--    }
        	--    globals   = {
        	--      [1 to N] = "name"
        	--    }
        	--    functions = {
        	--      [1 to N] = {      - list of functions
        	--        [1 to N] = {    - list of instructions
        	--          label = 
        	--          code  = 
        	--          op1   = 
        	--          op2   = 
        	--          op3   = 
        	--        }
        	--      }
        	--    }
        	--  }
     175	local struct = {}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	--AddInstruction: Add a new instruction node to current function
        	--  Parameters:
        	--    [1] $table  - Table created by 'NewInstruction' function
        	--  Return:
     181	function InterCodeGen.AddInstruction (inst)
    1029	  if (_DEBUG) then print("ICG :: AddInstruction") end
    1023	  assert (inst and type(inst) == "table")
    1257	  table.insert(struct.functions[function_counter], inst)
        	end
        	
        	--Clear: Set class condition to it's initial state
        	--  Parameters:
        	--  Return:
     489	function InterCodeGen.Clear ()
      93	  if (_DEBUG) then print("ICG :: Clear") end
      93	  struct = {
     207	    strings   = {},
      93	    globals   = {},
      93	    functions = {},
      93	  }
      93	  function_counter  = 0
      93	  label_counter     = 0
      93	  var_counter       = 0
        	end
        	
        	--Dump: Write class struct to file
        	--  Parameters:
        	--    [1] $string   - complete file path
        	--  Return:
     183	function InterCodeGen.Dump (output)
     269	  if (_DEBUG) then print("ICG :: Dump") end
     231	  for _, str_node in ipairs(struct.strings) do
      50	    output:write(string.format('%8s string  %s = "%s"\n', "", str_node.var, str_node.str))
        	  end
     167	  for _, name in ipairs(struct.globals) do
      34	    output:write(string.format('%8s global %s\n', "", name))
        	  end
     232	  for _, func in ipairs(struct.functions) do
     127	    output:write(func.header)
    1150	    for _, inst in ipairs(func) do
    1023	      InterCodeGen.DumpInstruction(output, inst)
        	    end
        	  end
        	end
        	
        	--DumpInstruction: Write instruction to file
        	--  Parameters:
        	--    [1] $       - Desired output
        	--    [2] $table  - Table created by 'AddInstruction' function
        	--  Return:
       3	function InterCodeGen.DumpInstruction (output, inst)
    1023	  if ((inst.code == enum_opcodes["CALLID"])) then
      14	    output:write(string.format('%14s   call %s\n', inst.label or "", inst.op1))
    1009	  elseif (inst.code == enum_opcodes["GOTO"]) then
      50	    output:write(string.format('%14s   goto %s\n', inst.label or "", inst.op1))
     959	  elseif (inst.code == enum_opcodes["IFFALSEGOTO"]) then
      57	    output:write(string.format('%14s   ifFalse %s goto %s\n', inst.label or "", inst.op1, inst.op2))
    1166	  elseif (inst.code == enum_opcodes["IFGOTO"]) then
     306	    output:write(string.format('%14s   if %s goto %s\n', inst.label or "", inst.op1, inst.op2))
    1122	  elseif ((inst.code == enum_opcodes["LABEL"])) then
     226	    output:write(string.format('%14s\n', inst.label .. ":" or ""))
     752	  elseif (inst.code == enum_opcodes["PARAM"]) then
     161	    output:write(string.format('%14s   param %s\n', inst.label or "", inst.op1))
     735	  elseif (inst.code == enum_opcodes["RETURN"]) then
     447	    output:write(string.format('%14s   ret %s\n', inst.label or "", inst.op1 or ""))
     552	  elseif (inst.code == enum_opcodes["ID=rval"]) then
     128	    output:write(string.format('%14s   %s = %s\n', inst.label or "", inst.op1, inst.op2))
     424	  elseif (inst.code == enum_opcodes["ID=BYTErval"]) then
     219	    output:write(string.format('%14s   %s = byte %s\n', inst.label or "", inst.op1, inst.op2))
     205	  elseif (inst.code == enum_opcodes["ID=ID[rval]"]) then
      19	    output:write(string.format('%14s   %s = %s[%s]\n', inst.label or "", inst.op1, inst.op2, inst.op3))
     480	  elseif (inst.code == enum_opcodes["ID=BYTEID[rval]"]) then
     981	    output:write(string.format('%14s   %s = byte %s[%s]\n', inst.label or "", inst.op1, inst.op2, inst.op3))
     815	  elseif (inst.code == enum_opcodes["ID=unoprval"]) then
     284	    output:write(string.format('%14s   %s = %s %s\n', inst.label or "", inst.op1, inst.op2, inst.op3))
     531	  elseif (inst.code == enum_opcodes["ID=rvalEQrval"]) then
      49	    output:write(string.format('%14s   %s = %s == %s\n', inst.label or "", inst.op1, inst.op2, inst.op3))
     482	  elseif (inst.code == enum_opcodes["ID=rvalNErval"]) then
     190	    output:write(string.format('%14s   %s = %s != %s\n', inst.label or "", inst.op1, inst.op2, inst.op3))
     292	  elseif (inst.code == enum_opcodes["ID=rvalGErval"]) then
      35	    output:write(string.format('%14s   %s = %s >= %s\n', inst.label or "", inst.op1, inst.op2, inst.op3))
     257	  elseif (inst.code == enum_opcodes["ID=rvalLErval"]) then
     142	    output:write(string.format('%14s   %s = %s <= %s\n', inst.label or "", inst.op1, inst.op2, inst.op3))
     115	  elseif (inst.code == enum_opcodes["ID=rval<rval"]) then
      26	    output:write(string.format('%14s   %s = %s < %s\n', inst.label or "", inst.op1, inst.op2, inst.op3))
      89	  elseif (inst.code == enum_opcodes["ID=rval>rval"]) then
      14	    output:write(string.format('%14s   %s = %s > %s\n', inst.label or "", inst.op1, inst.op2, inst.op3))
     369	  elseif (inst.code == enum_opcodes["ID=rval+rval"]) then
      19	    output:write(string.format('%14s   %s = %s + %s\n', inst.label or "", inst.op1, inst.op2, inst.op3))
      56	  elseif (inst.code == enum_opcodes["ID=rval-rval"]) then
      17	    output:write(string.format('%14s   %s = %s - %s\n', inst.label or "", inst.op1, inst.op2, inst.op3))
      39	  elseif (inst.code == enum_opcodes["ID=rval*rval"]) then
      17	    output:write(string.format('%14s   %s = %s * %s\n', inst.label or "", inst.op1, inst.op2, inst.op3))
      24	  elseif (inst.code == enum_opcodes["ID=rval/rval"]) then
      31	    output:write(string.format('%14s   %s = %s / %s\n', inst.label or "", inst.op1, inst.op2, inst.op3))
      27	  elseif (inst.code == enum_opcodes["ID[rval]=rval"]) then
       5	    output:write(string.format('%14s   %s[%s] = %s\n', inst.label or "", inst.op1, inst.op2, inst.op3))
      24	  elseif (inst.code == enum_opcodes["ID[rval]=BYTErval"]) then
       4	    output:write(string.format('%14s   %s[%s] = byte %s\n', inst.label or "", inst.op1, inst.op2, inst.op3))
        	  else
*******0	    InterCodeGen.Error("unknown instruction node.")
        	  end
        	end
        	
        	--Error:
        	--  Parameters:
        	--    [1] $string - 
        	--  Return:
      65	function InterCodeGen.Error (msg)
*******0	  local str = string.format("intermediate code generator error: %s", msg or "")
     124	  error(str, 0)
        	end
        	
        	--GenAttribution: Add instructions of node to it's function structure
        	--  Parameters:
        	--    [1] $table  - ATTRIBUTION node
        	--  Return:
       1	function InterCodeGen.GenAttribution (node)
     142	  if (_DEBUG) then print("ICG :: GenAttribution") end
     142	  assert(node.id == nodes_codes["ATTRIBUTION"])
     144	  if (#node.var.array > 0) then
        	    local op
      24	    for i = 1, #node.var.array do
     501	      local last_op = op
     123	      if (i == #node.var.array) then
        	        local op_inst
      23	        if (node.var.sem_type == "bool" or node.var.sem_type == "char") then
     368	          op_inst = "ID[rval]=BYTErval"
        	        else
     343	          op_inst = "ID[rval]=rval"
        	        end
     181	        local op_array  = InterCodeGen.GenExpression(node.var.array[i])
      23	        local op_exp    = InterCodeGen.GenExpression(node.exp)
     167	        InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, op_inst, op or node.var.name, op_array, op_exp))
        	      else
       4	        local op_array = InterCodeGen.GenExpression(node.var.array[i])
       6	        op = InterCodeGen.GetVariable()
       4	        InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=ID[rval]", op, last_op or node.var.name, op_array))
        	      end
        	    end
        	  else
        	    local op
     135	    if (node.var.sem_type == "char" or node.var.sem_type == "bool") then
      78	      op = "ID=BYTErval"
        	    else
      61	      op = "ID=rval"
        	    end
     139	    local op_exp = InterCodeGen.GenExpression(node.exp)
     139	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, op, node.var.name, op_exp))
        	  end
        	end
        	
        	--GenBlock: Add instructions of node to it's function structure
        	--  Parameters:
        	--    [1] $table  - List of ATTRIBUTION, CALL, DECLARE, IF, RETURN and WHILE nodes
        	--  Return:
     111	function InterCodeGen.GenBlock (block)
     162	  if (_DEBUG) then print("ICG :: GenBlock") end
     519	  for _, node in ipairs(block) do
     361	    if (node.id == nodes_codes["ATTRIBUTION"]) then
     156	      InterCodeGen.GenAttribution(node)
     231	    elseif (node.id == nodes_codes["CALL"]) then
      23	      InterCodeGen.GenCall(node)
     210	    elseif (node.id == nodes_codes["DECLARE"]) then
     110	      InterCodeGen.GenDeclare(node)
     100	    elseif (node.id == nodes_codes["IF"]) then
      19	      InterCodeGen.GenIf(node)
     107	    elseif (node.id == nodes_codes["RETURN"]) then
      70	      InterCodeGen.GenReturn(node)
      11	    elseif (node.id == nodes_codes["WHILE"]) then
       9	      InterCodeGen.GenWhile(node)
        	    end
        	  end
        	end
        	
        	--GenCall: Add instructions of node to it's function structure
        	--  Parameters:
        	--    [1] $table  - CALL node
        	--  Return:
       1	function InterCodeGen.GenCall (node)
      16	  if (_DEBUG) then print("ICG :: GenCall") end
      14	  assert(node.id == nodes_codes["CALL"])
      14	  if (node.exps) then
     174	    local params_list = {}
      31	    for i=#node.exps, 1, -1 do
      17	      table.insert(params_list, InterCodeGen.GenExpression(node.exps[i]))
        	    end
      31	    for i=#node.exps, 1, -1 do
      17	      InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "PARAM", params_list[i]))
        	    end
        	  end
     222	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "CALLID", node.name))
        	end
        	
        	--GenDeclare: Add instructions of node to it's function structure
        	--  Parameters:
        	--    [1] $table  - DECLARE node
        	--  Return:
      31	function InterCodeGen.GenDeclare (node)
     128	  if (_DEBUG) then print("ICG :: GenDeclare") end
     110	  assert(node.id == nodes_codes["DECLARE"])
        	  local op
     318	  if ((node.type == "bool" or node.type == "char") and node.dimension == 0) then
     250	    op = "ID=BYTErval"
        	  else
     276	    op = "ID=rval"
        	  end
     320	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, op, node.name, "0"))
        	end
        	
        	--GenExpression:
        	--  Parameters:
        	--    [1] $table  - CALL, NEGATE, NEWVAR, OPERATOR, UNARY, VALUE or VAR node
        	--  Return:
        	--    [1] $string - Variable or value where expression return is saved
      61	function InterCodeGen.GenExpression (node)
     702	  if (node.id == nodes_codes["CALL"]) then
      67	    return InterCodeGen.GenExpressionCall(node)
     637	  elseif (node.id == nodes_codes["LITERAL"]) then
     170	    return InterCodeGen.GenExpressionLiteral(node)
     467	  elseif (node.id == nodes_codes["NEGATE"]) then
      13	    return InterCodeGen.GenExpressionNegate(node)
     454	  elseif (node.id == nodes_codes["NEWVAR"]) then
      17	    return InterCodeGen.GenExpressionNewVar(node)
     473	  elseif (node.id == nodes_codes["OPERATOR"]) then
     177	    return InterCodeGen.GenExpressionOperator(node)
     330	  elseif (node.id == nodes_codes["UNARY"]) then
      41	    return InterCodeGen.GenExpressionUnary(node)
     323	  elseif (node.id == nodes_codes["VAR"]) then
     323	    return InterCodeGen.GenExpressionVar(node)
        	  end
        	end
        	
      25	function InterCodeGen.GenExpressionCall (node)
      29	  assert(node.id == nodes_codes["CALL"])
      29	  InterCodeGen.GenCall(node)
      35	  local op = InterCodeGen.GetVariable()
      23	  local ret = "$ret"
      23	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=rval", op, ret))
      23	  return op
        	end
        	
       7	function InterCodeGen.GenExpressionLiteral (node)
     176	  assert(node.id == nodes_codes["LITERAL"])
        	  local op
     176	  if (node.type == "char") then
       6	    op = InterCodeGen.GetVariable()
      18	    local t = {
      10	      var = op,
      10	      str = node.value,
       4	    }
      10	    table.insert(struct.strings, t)
     164	  elseif (node.type == "bool") then
      46	    op = (node.value == "true" and "1") or "0"
        	  else
     126	    op = node.value
        	  end
     170	  return op
        	end
        	
      17	function InterCodeGen.GenExpressionNegate (node)
      29	  assert(node.id == nodes_codes["NEGATE"])
      29	  local op = InterCodeGen.GetVariable()
      13	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=rvalEQrval", op, InterCodeGen.GenExpression(node.exp), "0"))
      23	  return op
        	end
        	
      35	function InterCodeGen.GenExpressionNewVar (node)
      51	  assert(node.id == nodes_codes["NEWVAR"])
      15	  local op = InterCodeGen.GetVariable()
      15	  if ((node.sem_type == "bool" or node.sem_type == "char") and node.exp.sem_dimension == 0) then
       6	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=unoprval", op, "new byte", InterCodeGen.GenExpression(node.exp)))
        	  else
       9	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=unoprval", op, "new", InterCodeGen.GenExpression(node.exp)))
        	  end
     155	  return op
        	end
        	
     141	function InterCodeGen.GenExpressionOperator (node)
        	  local op
     143	  if (node.op == "and") then
     148	    op = InterCodeGen.GetVariable()
     148	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=BYTErval", op, 0))
     150	    local lbl_end  = InterCodeGen.GetLabel()
       8	    local op_left  = InterCodeGen.GenExpression(node[1])
       8	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFFALSEGOTO", op_left, lbl_end))
       8	    local op_right = InterCodeGen.GenExpression(node[2])
       8	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFFALSEGOTO", op_right, lbl_end))
       8	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=BYTErval", op, 1))    
      10	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(lbl_end, "LABEL"))
     151	  elseif (node.op == "or") then
      38	    op = InterCodeGen.GetVariable()
      38	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=BYTErval", op, 0))
      38	    local lbl_true  = InterCodeGen.GetLabel()
      38	    local lbl_end   = InterCodeGen.GetLabel()
      38	    local op_left   = InterCodeGen.GenExpression(node[1])
      38	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFGOTO", op_left, lbl_true))
      38	    local op_right  = InterCodeGen.GenExpression(node[2])  
      38	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFGOTO", op_right, lbl_true))
      38	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "GOTO", lbl_end))
      38	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(lbl_true, "LABEL"))
      38	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=BYTErval", op, 1))
      40	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(lbl_end, "LABEL"))
     113	  elseif (node.op == "=") then
      18	    local left  = InterCodeGen.GenExpression(node[1])
      18	    local right = InterCodeGen.GenExpression(node[2])
      18	    op = InterCodeGen.GetVariable()
      18	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=rvalEQrval", op, left, right))
      97	  elseif (node.op == "<>") then
     102	    local left  = InterCodeGen.GenExpression(node[1])
     102	    local right = InterCodeGen.GenExpression(node[2])
     102	    op = InterCodeGen.GetVariable()
       4	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=rvalNErval", op, left, right))
      93	  elseif (node.op == ">=") then
       1	    local left  = InterCodeGen.GenExpression(node[1])
       1	    local right = InterCodeGen.GenExpression(node[2])
       1	    op = InterCodeGen.GetVariable()
       1	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=rvalGErval", op, left, right))
      94	  elseif (node.op == "<=") then
     104	    local left  = InterCodeGen.GenExpression(node[1])
     104	    local right = InterCodeGen.GenExpression(node[2])
     104	    op = InterCodeGen.GetVariable()
       4	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=rvalLErval", op, left, right))
      90	  elseif (node.op == "+") then
      19	    local left  = InterCodeGen.GenExpression(node[1])
      19	    local right = InterCodeGen.GenExpression(node[2])
      19	    op = InterCodeGen.GetVariable()
      19	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=rval+rval", op, left, right))
      71	  elseif (node.op == "-") then
      17	    local left  = InterCodeGen.GenExpression(node[1])
      17	    local right = InterCodeGen.GenExpression(node[2])
      17	    op = InterCodeGen.GetVariable()
      19	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=rval-rval", op, left, right))
     958	  elseif (node.op == "*") then
     921	    local left  = InterCodeGen.GenExpression(node[1])
     921	    local right = InterCodeGen.GenExpression(node[2])
     921	    op = InterCodeGen.GetVariable()
     921	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=rval*rval", op, left, right))
     941	  elseif (node.op == "/") then
     917	    local left  = InterCodeGen.GenExpression(node[1])
     917	    local right = InterCodeGen.GenExpression(node[2])
      13	    op = InterCodeGen.GetVariable()
     917	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=rval/rval", op, left, right))
      26	  elseif (node.op == ">") then
      14	    local left  = InterCodeGen.GenExpression(node[1])
      14	    local right = InterCodeGen.GenExpression(node[2])
      14	    op = InterCodeGen.GetVariable()
      14	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=rval>rval", op, left, right))
      10	  elseif (node.op == "<") then
      10	    local left  = InterCodeGen.GenExpression(node[1])
      10	    local right = InterCodeGen.GenExpression(node[2])
      10	    op = InterCodeGen.GetVariable()
      10	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=rval<rval", op, left, right))
        	  end
     143	  assert(op)
     143	  return op
        	end
        	
     175	function InterCodeGen.GenExpressionUnary (node)
     181	  assert(node.id == nodes_codes["UNARY"])
     181	  local op = InterCodeGen.GetVariable()
     181	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=unoprval", op, "-", InterCodeGen.GenExpression(node.exp)))
     355	  return op
        	end
        	
      61	function InterCodeGen.GenExpressionVar (node)
     497	  assert(node.id == nodes_codes["VAR"])
     497	  if (#node.array > 0) then
        	    local op
      88	    for i = 1, #node.array do
      44	      local op_array = InterCodeGen.GenExpression(node.array[i])
      44	      local last_op = op
     218	      op = InterCodeGen.GetVariable()
     218	      if (i == #node.array) then
      44	        if (node.sem_type == "bool" or node.sem_type == "char") then
      31	          InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=BYTEID[rval]", op, last_op or node.name, op_array))
        	        else
     125	          InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=ID[rval]", op, last_op or node.name, op_array))
        	        end
        	      else
*******0	        InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=ID[rval]", op, last_op or node.name, op_array))
        	      end
        	    end
     106	    return op
        	  else
     357	    return node.name
        	  end
        	end
        	
        	--GenFunction: 
        	--  Parameters:
        	--    [1] $table  - FUNCTION node
        	--  Return:
       3	function InterCodeGen.GenFunction (node)
     113	  if (_DEBUG) then print("ICG :: GenFunction") end
     113	  assert(node.id == nodes_codes["FUNCTION"])
     113	  function_counter = function_counter + 1
     113	  local header = string.format("%8s fun %s (", "", node.name)
     113	  if (node.params and node.params[1]) then
      36	    header = header .. node.params[1].name
        	  end
     113	  if (node.params and #node.params > 1) then
      17	    for i = 2, #node.params do
      10	      header = header .. "," .. node.params[i].name
        	    end
        	  end
     113	  header = header .. ")\n"
     113	  struct.functions[function_counter] = {
     113	    header = header,
     113	  }
     113	  InterCodeGen.GenBlock(node.block)
     113	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "RETURN"))
        	end
        	
        	--GenGlobal: 
        	--  Parameters:
        	--    [1] $table  - DECLARE or FUNCTION node
        	--  Return:
       1	function InterCodeGen.GenGlobal (node)
      32	  if (_DEBUG) then print("ICG :: GenGlobal") end
      32	  assert(node.id == nodes_codes["DECLARE"])
      32	  table.insert(struct.globals, node.name)
        	end
        	
        	--GenIf: Add instructions of node to it's function structure
        	--  Parameters:
        	--    [1] $table  - IF node
        	--  Return:
       1	function InterCodeGen.GenIf(node)
      19	  if (_DEBUG) then print("ICG :: GenIf") end
      19	  assert(node.id == nodes_codes["IF"])
      19	  local lbl_end       = InterCodeGen.GetLabel()
      19	  local var_condition = InterCodeGen.GetVariable()
      19	  local op = InterCodeGen.GenExpression(node.cond)
      19	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=BYTErval", var_condition, op))
      19	  if (node["elseif"] or node["else"]) then
      14	    local lbl_next = InterCodeGen.GetLabel()
      14	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFFALSEGOTO", var_condition, lbl_next))
      14	    InterCodeGen.GenBlock(node.block)
      14	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "GOTO", lbl_end))
      14	    if (node["elseif"]) then
      19	      for i = 1, #node["elseif"] do
      11	        InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(lbl_next, "LABEL"))
      11	        var_condition = InterCodeGen.GetVariable()
      11	        op = InterCodeGen.GenExpression(node["elseif"][i].cond)
      11	        InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=BYTErval", var_condition, op))
      11	        if ((#node["elseif"] - i) > 0) then
       3	          lbl_next = InterCodeGen.GetLabel()
       3	          InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFFALSEGOTO", var_condition, lbl_next))
       3	          InterCodeGen.GenBlock(node["elseif"][i].block)
       3	          InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "GOTO", lbl_end))
        	        else
       8	          if (node["else"]) then
       2	            lbl_next = InterCodeGen.GetLabel()
       2	            InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFFALSEGOTO", var_condition, lbl_next))
       2	            InterCodeGen.GenBlock(node["elseif"][i].block)
       2	            InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "GOTO", lbl_end))
        	          else
       6	            InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFFALSEGOTO", var_condition, lbl_end))
       6	            InterCodeGen.GenBlock(node["elseif"][i].block)
        	          end
        	        end
        	      end
        	    end
      14	    if (node["else"]) then
       8	      InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(lbl_next, "LABEL"))
       8	      InterCodeGen.GenBlock(node["else"])
        	    end
        	  else
       5	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFFALSEGOTO", var_condition, lbl_end))
       5	    InterCodeGen.GenBlock(node.block)
        	  end
      19	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(lbl_end, "LABEL"))
        	end
        	
        	--GenReturn: Add instructions of node to it's function structure
        	--  Parameters:
        	--    [1] $table  - RETURN node
        	--  Return:
       1	function InterCodeGen.GenReturn (node)
      70	  if (_DEBUG) then print("ICG :: GenReturn") end
      70	  assert(node.id == nodes_codes["RETURN"])
        	  local op
      70	  if (node.exp) then
      66	    op = InterCodeGen.GenExpression(node.exp)
        	  end
      70	  local t = InterCodeGen.NewInstruction(nil, "RETURN", op)
      70	  InterCodeGen.AddInstruction(t)
        	end
        	
        	--GenWhile: Add instructions of node to it's function structure
        	--  Parameters:
        	--    [1] $table  - WHILE node
        	--  Return:
       1	function InterCodeGen.GenWhile (node)
       9	  if (_DEBUG) then print("ICG :: GenWhile") end
       9	  assert(node.id == nodes_codes["WHILE"])
       9	  local lbl_before    = InterCodeGen.GetLabel()
       9	  local lbl_after     = InterCodeGen.GetLabel()
       9	  local var_condition = InterCodeGen.GetVariable()
       9	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(lbl_before, "LABEL"))
       9	  local op = InterCodeGen.GenExpression(node.cond)
       9	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=BYTErval", var_condition, op))
       9	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFFALSEGOTO", var_condition, lbl_after))
       9	  InterCodeGen.GenBlock(node.block)
       9	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "GOTO", lbl_before))
       9	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(lbl_after, "LABEL"))
        	end
        	
        	--GetLabel: Get a new string to use as a label
        	--  Parameters:
        	--  Return:
        	--    [1] $string   - New unique label
       1	function InterCodeGen.GetLabel ()
     108	  if (_DEBUG) then print("ICG :: GetLabel") end
     108	  label_counter = label_counter + 1
     108	  return ".L" .. label_counter
        	end
        	
        	--GetVariable: Get a new string to use as a variable
        	--  Parameters:
        	--  Return:
        	--    [1] $string   - New unique variable
       1	function InterCodeGen.GetVariable ()
     276	  if (_DEBUG) then print("ICG :: GetVariable") end
     276	  var_counter = var_counter + 1
     276	  return "$t" .. var_counter
        	end
        	
        	--NewInstruction: Create a new instruction node
        	--  Parameters:
        	--    [1] $string - 
        	--    [2] $string - 
        	--    [3] $string - 
        	--    [4] $string - 
        	--    [5] $string - 
        	--  Return:
        	--    [1] $table  - Table containing a instruction node, of one 'enum_opcodes'
       1	function InterCodeGen.NewInstruction (label, code, operator1, operator2, operator3)
    1023	  if (_DEBUG) then print("ICG :: NewInstruction") end
    1023	  assert (enum_opcodes[code])
    1023	  local t = {
    1023	    label = label,
    1023	    code  = enum_opcodes[code],
    1023	    op1   = operator1,
    1023	    op2   = operator2,
    1023	    op3   = operator3,
        	  }
    1023	  return t
        	end
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Open: Write a 'path'.icg file with intermediate code. After writing it, calls
        	--      a binary created by Hisham Muhammed to validate the created file.
        	--  Parameters:
        	--    [1] $string   - Path of exit file. Extension will be converted to '.icg'
        	--    [2] $table    - Struct of program builded by semantic.
        	--  Return:
        	--    [1] $boolean  - false if found any problem, true otherwise
        	--    [2] $string   - only when [1] is false, informing which error occurs
       1	function InterCodeGen.Open (path, tree)
      93	  if (_DEBUG) then print("ICG :: Open") end
      93	  assert(path)
      93	  assert(tree and type(tree) == "table")
      93	  InterCodeGen.Clear()
     186	  local ok, msg = pcall(function ()
     238	    for _, node in ipairs(tree) do
     145	      if (node.id == nodes_codes["DECLARE"]) then
      32	        InterCodeGen.GenGlobal(node)
     113	      elseif (node.id == nodes_codes["FUNCTION"]) then
     113	        InterCodeGen.GenFunction(node)
        	      else
*******0	        InterCodeGen.Error("unknown program node.")
        	      end
        	    end
      93	    if (printStruct) then
*******0	      util.TablePrint(struct)
        	    end
      93	    local f = io.open(util.FileRemoveExtension(path) .. ".icg", "w")
      93	    if (not f) then
*******0	      InterCodeGen.Error(string.format("output file '%s' could not be opened"), path)
        	    end
      93	    InterCodeGen.Dump(f)
      93	    f:close()
      93	    os.execute("./cte/cte " .. util.FileRemoveExtension(path) .. ".icg")
     186	  end)
      93	  if (not ok) then
*******0	    return false, msg
        	  end
      93	  return true
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       1	return InterCodeGen
        	
        	
        	--[[
        	program   : strings globals functions
        	          ;
        	
        	strings   : string strings
        	          |;
        	
        	globals   : global globals
        	          |;              
        	    
        	functions : function functions
        	          |;  
        	
        	nl        : NL opt_nl ;
        	
        	opt_nl    : NL opt_nl
        	          |;
        	
        	string    : STRING ID '=' LITSTRING nl
        	
        	global    : GLOBAL ID nl
        	
        	function  : FUN ID '(' args ')' nl
        	          commands
        	          ;
        	
        	args      : arg more_args
        	          |;
        	
        	more_args : ',' args
        	          |;
        	
        	arg       : ID
        	          ;
        	
        	commands  : label command nl commands
        	          |;
        	
        	label     : LABEL ':' opt_nl label
        	          |;
        	
        	rval      : LITNUM
        	          | ID
        	          ;
        	
        	command   : ID '=' rval
        	          | ID '=' BYTE rval
        	          | ID '=' rval binop rval
        	          | ID '=' unop rval
        	          | ID '=' ID '[' rval ']'
        	          | ID '=' BYTE ID '[' rval ']'
        	          | ID '[' rval ']' '=' rval
        	          | ID '[' rval ']' '=' BYTE rval
        	          | IF ID GOTO LABEL
        	          | IFFALSE ID GOTO LABEL
        	          | GOTO LABEL
        	          | call
        	          | RET rval
        	          | RET
        	          ;
        	
        	binop     : EQ
        	          | NE
        	          | '<'
        	          | '>'
        	          | GE
        	          | LE
        	          | '+'
        	          | '-'
        	          | '*'
        	          | '/'
        	          ;
        	
        	unop      : '-'
        	          | NEW
        	          | NEW BYTE
        	          ;
        	
        	call      : params
        	          CALL ID
        	          ;
        	
        	params    : param nl params
        	          |;
        	
        	param     : PARAM rval
        	          ;
        	--]]

==============================================================================
./src/lexical.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
      19	local printTokensCapture  = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      19	local lulex       = require "lib/lulex"
      19	local TokensClass = require "lib/token_codes"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      19	local Lexical = {}
        	
        	-- number of current line
        	local line_number
        	
        	-- lexer instructions and callbacks
        	--  {
        	--    [#] = {
        	--      [1] = pattern,
        	--      [2] = function,
        	--    }
        	--  }
      19	local lexer = {}
        	
        	-- tags read in input
        	--  {
        	--    [#] = {
        	--      code  = $number,
        	--      line  = $number,
        	--      token = $string,
        	--    }
        	--  }
      19	local tags = {}
        	
        	--  list of tokens
        	--  {
        	--    [name] = $number,
        	--  }
      19	local tokens = TokensClass.GetTokensList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	local function StoreToken (code, token, line)
   69023	  if (_DEBUG) then print("LEX :: StoreToken") end
   69023	  assert(code and type(code) == "number")
   69023	  assert(token)
   69023	  assert(line and type(line) == "number")
   69023	  if (_DEBUG or printTokensCapture) then
*******0	    print(string.format("codigo: '%10s' linha: %4d token: %s", TokensClass.GetTokenName(code), line, tostring(token)))
        	  end
   69023	  local t = {
   69023	    code = code,
   69023	    line = line,
   69023	    token = token,
        	  }
   69023	  table.insert(tags, t)
        	end
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
      38	lexer = lulex.New{
      19	  { '[ \t]+',
        	    function (token)
        	    end
      19	  },
      19	  { '//[^\n]+',
        	    function (token)
        	      --StoreToken(tokens.COMMENT_LINE, token, line_number)
        	    end
      19	  },
      19	  { '/\\*([^\\*]|\\*[^/])*\\*/',
        	    function (token)
        	      --StoreToken(tokens.COMMENT_BLOCK, token, line_number)
      63	      local init = 0
     198	      while (string.find(token, "\n", init)) do
     135	        _, init = string.find(token, "\n", init)
     135	        init = init + 1
     135	        line_number = line_number + 1
        	      end
        	    end
      19	  },
      19	  { 'if',
        	    function (token)
     884	      StoreToken(tokens.K_IF, token, line_number)
        	    end
      19	  },
      19	  { 'then',
        	    function (token)
      19	      StoreToken(tokens.K_THEN, token, line_number)
        	    end
      19	  },
      19	  { 'else',
        	    function (token)
     557	      StoreToken(tokens.K_ELSE, token, line_number)
        	    end
      19	  },
      19	  { 'while',
        	    function (token)
     145	      StoreToken(tokens.K_WHILE, token, line_number)
        	    end
      19	  },
      19	  { 'loop',
        	    function (token)
     145	      StoreToken(tokens.K_LOOP, token, line_number)
        	    end
      19	  },
      19	  { 'fun',
        	    function (token)
    2525	      StoreToken(tokens.K_FUN, token, line_number)
        	    end
      19	  },
      19	  { 'return',
        	    function (token)
    1132	      StoreToken(tokens.K_RETURN, token, line_number)
        	    end
      19	  },
      19	  { 'new',
        	    function (token)
     185	      StoreToken(tokens.K_NEW, token, line_number)
        	    end
      19	  },
      19	  { 'string',
        	    function (token)
     311	      StoreToken(tokens.K_STRING, token, line_number)
        	    end
      19	  },
      19	  { 'int',
        	    function (token)
    2502	      StoreToken(tokens.K_INT, token, line_number)
        	    end
      19	  },
      19	  { 'char',
        	    function (token)
     676	      StoreToken(tokens.K_CHAR, token, line_number)
        	    end
      19	  },
      19	  { 'bool',
        	    function (token)
     998	      StoreToken(tokens.K_BOOL, token, line_number)
        	    end
      19	  },
      19	  { 'true',
        	    function (token)
     343	      StoreToken(tokens.K_TRUE, token, line_number)
        	    end
      19	  },
      19	  { 'false',
        	    function (token)
     247	      StoreToken(tokens.K_FALSE, token, line_number)
        	    end
      19	  },
      19	  { 'and',
        	    function (token)
     229	      StoreToken(tokens.K_AND, token, line_number)
        	    end
      19	  },
      19	  { 'or',
        	    function (token)
     210	      StoreToken(tokens.K_OR, token, line_number)
        	    end
      19	  },
      19	  { 'not',
        	    function (token)
     272	      StoreToken(tokens.K_NOT, token, line_number)
        	    end
      19	  },
      19	  { 'end',
        	    function (token)
    3140	      StoreToken(tokens.K_END, token, line_number)
        	    end
      19	  },
      19	  { '\\"([^\\"\\\\]|\\\\[nt\\\\"])*\\"',
        	    function (token)
     283	      local str = token
     283	      str = string.gsub(str, '^"', '')
     283	      str = string.gsub(str, '"$', '')
     283	      str = string.gsub(str, '\\"', '"')
     283	      str = string.gsub(str, '\\n', '\n')
     283	      str = string.gsub(str, '\\t', '\t')
     283	      str = string.gsub(str, '\\\\', '\\')
     283	      StoreToken(tokens.STRING, str, line_number)
        	    end
      19	  },
      19	  { '[0-9]+',
        	    function (token)
    3214	      StoreToken(tokens.NUMBER, token, line_number)
        	    end
      19	  },
      19	  { '0x[0-9a-fA-F]+',
        	    function (token)
      38	      StoreToken(tokens.NUMBER, tonumber(token), line_number)
        	    end
      19	  },
      19	  { '\\(',
        	    function (token)
    3437	      StoreToken(tokens["OP_("], token, line_number)
        	    end
      19	  },
      19	  { '\\)',
        	    function (token)
    3437	      StoreToken(tokens["OP_)"], token, line_number)
        	    end
      19	  },
      19	  { ',',
        	    function (token)
     436	      StoreToken(tokens["OP_,"], token, line_number)
        	    end
      19	  },
      19	  { ':',
        	    function (token)
    4302	      StoreToken(tokens["OP_:"], token, line_number)
        	    end
      19	  },
      19	  { '>',
        	    function (token)
     190	      StoreToken(tokens["OP_>"], token, line_number)
        	    end
      19	  },
      19	  { '<',
        	    function (token)
     296	      StoreToken(tokens["OP_<"], token, line_number)
        	    end
      19	  },
      19	  { '>=',
        	    function (token)
      41	      StoreToken(tokens["OP_>="], token, line_number)
        	    end
      19	  },
      19	  { '<=',
        	    function (token)
     117	      StoreToken(tokens["OP_<="], token, line_number)
        	    end
      19	  },
      19	  { '=',
        	    function (token)
    3466	      StoreToken(tokens["OP_="], token, line_number)
        	    end
      19	  },
      19	  { '<>',
        	    function (token)
     172	      StoreToken(tokens["OP_<>"], token, line_number)
        	    end
      19	  },
      19	  { '\\[',
        	    function (token)
    2597	      StoreToken(tokens["OP_["], token, line_number)
        	    end
      19	  },
      19	  { '\\]',
        	    function (token)
    2597	      StoreToken(tokens["OP_]"], token, line_number)
        	    end
      19	  },
      19	  { '\\+',
        	    function (token)
     464	      StoreToken(tokens["OP_+"], token, line_number)
        	    end
      19	  },
      19	  { '-',
        	    function (token)
     352	      StoreToken(tokens["OP_-"], token, line_number)
        	    end
      19	  },
      19	  { '\\*',
        	    function (token)
     225	      StoreToken(tokens["OP_*"], token, line_number)
        	    end
      19	  },
      19	  { '/',
        	    function (token)
     127	      StoreToken(tokens["OP_/"], token, line_number)
        	    end
      19	  },
      19	  { '[ \n]+',
        	    function (token)
   15074	      StoreToken(tokens.LINE_END, token, line_number)
   15074	      local init = 0
   31808	      while (string.find(token, "\n", init)) do
   16734	        _, init = string.find(token, "\n", init)
   16734	        init = init + 1
   16734	        line_number = line_number + 1
        	      end
        	    end
      19	  },
      19	  { '[a-zA-Z_][a-zA-Z0-9_]*',
        	    function (token)
   13566	      StoreToken(tokens.ID, token, line_number)
        	    end
      19	  },
      19	  { '.',
        	    function (token)
      72	      StoreToken(tokens.ERROR, token, line_number)
        	    end
      19	  },
      38	}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Open:
        	--  parameters:
        	--    [1] $string  - path of file to be analysed
        	--  return:
        	--    [1] $boolean - false if found any problem, true otherwise
        	--    [2] $string  - only when [1] is false, informing which error occurs
      19	function Lexical.Open (txt)
    2224	  if (_DEBUG) then print("LEX :: Open") end
    2224	  assert(txt and type(txt) == "string")
    2224	  tags = {}
    2224	  line_number = 1
    2224	  lexer:run(txt, true)
   70995	  for _, tab in ipairs(tags) do
   68789	    if (tab.code == tokens.ERROR) then
      18	      return false, string.format("@%d lexical error: could not recognize tags.", tab.line)
        	    end
        	  end
    2206	  return true
        	end
        	
      19	function Lexical.GetTags()
    2206	  if (_DEBUG) then print("LEX :: GetTags") end
    2206	  return tags
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      19	return Lexical

==============================================================================
./src/parser.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      19	local Parser = {}
        	
        	-- store tokens list received in input
      19	local tokens_list = {}
        	
        	-- keep the number of the current token
      19	local current = 0
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Advance:
        	--  parameters:
        	--  return:
      19	function Parser.Advance ()
   62105	  if (_DEBUG) then print("PAR :: Advance") end
   62105	  current = current + 1
        	end
        	
        	--Open: Start a new parser with current table input, erasing any previous one
        	--  parameters:
        	--    [1] $table   - table with tokens read in lexical
        	--  return:
      19	function Parser.Open (t)
    2206	  if (_DEBUG) then print("PAR :: Open") end
    2206	  assert(type(t) == "table")
    2206	  current = 0
    2206	  tokens_list = t
        	end
        	
        	--Peek: peek the next token
        	--  parameters:
        	--  return:
      19	function Parser.Peek ()
  178839	  if (_DEBUG) then print("PAR :: Peek") end
  178839	  return tokens_list[current + 1]
        	end
        	
        	--Peek2: peek the second next token
        	--  parameters:
        	--  return:
      19	function Parser.Peek2 ()
   12358	  if (_DEBUG) then print("PAR :: Peek2") end
   12358	  return tokens_list[current + 2]
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      19	return Parser

==============================================================================
./src/semantic.lua
==============================================================================
        	--==============================================================================
        	-- Considerations
        	--==============================================================================
        	
        	-- Functions sets new unreach code variable '@ret' as its return VAR variable
        	-- Functions sets PARAMETER nodes to own scope
        	-- ALLOW overcharge variable in diferent scopes
        	
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
      14	local printTree = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      19	require "lib/util"
      19	local NodesClass  = require "lib/node_codes"
      17	local PrintClass  = require "lib/util_tree"
      14	local SymbolClass = require "src/symbol_table"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      14	local Semantic = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
      14	local nodes_codes = NodesClass.GetNodesList()
        	
        	--  AST tree (structed nodes)
       3	local tree = {}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	--Error: Callback of errors that occurs during semantic analysis
        	--  Parameters:
        	--    [1] $string
        	--  Return:
        	local function Error (msg, line)
     793	  local str = string.format("@%d semantic error: %s", line or 0, msg or "")
     793	  error(str, 0)
        	end
        	
        	--VerifyAttribution: Verify integrity of ATTRIBUTION node
        	--  Parameters:
        	--    [1] $table  = ATTRIBUTION node
        	--  Return:
     153	function Semantic.VerifyAttribution (node)
     782	  if (_DEBUG) then print("SEM :: VerifyAttribution") end
     773	  assert(node.id == nodes_codes["ATTRIBUTION"])
     656	  Semantic.VerifyVar(node.var)
     740	  Semantic.VerifyExpression(node.exp)
     616	  Semantic.VerifyCompatibleTypes(node.line, node.var.sem_type, node.var.sem_dimension, node.exp.sem_type, node.exp.sem_dimension)
        	end
        	
        	--VerifyBlock: Verify integrity of BLOCK/COMMANDS nodes
        	--  Parameters:
        	--    [1] $table  = collection of ATTRIBUTION, CALL, DECLARE, IF, RETURN and WHILE nodes
        	--  Return:
     711	function Semantic.VerifyBlock (block)
     833	  if (_DEBUG) then print("SEM :: VerifyBlock") end
    1986	  for _, node in ipairs(block or {}) do
    2846	    if (node.id == nodes_codes["ATTRIBUTION"]) then
    1764	      Semantic.VerifyAttribution(node)
    1182	    elseif (node.id == nodes_codes["CALL"]) then
    1191	      Semantic.VerifyCall(node)
     671	    elseif (node.id == nodes_codes["DECLARE"]) then
    1354	      Semantic.VerifyDeclare(node)
     834	    elseif (node.id == nodes_codes["IF"]) then
     617	      Semantic.VerifyIf(node)
     318	    elseif (node.id == nodes_codes["RETURN"]) then
     737	      Semantic.VerifyReturn(node)
     479	    elseif (node.id == nodes_codes["WHILE"]) then
      31	      Semantic.VerifyWhile(node)
        	    else
      69	      Error("unknown block node")
        	    end
        	  end
        	end
        	
        	--VerifyCall: Verify integrity of CALL node
        	--  Parameters:
        	--    [1] $table  = CALL node
        	--  Return:
      33	function Semantic.VerifyCall (node)
     149	  if (_DEBUG) then print("SEM :: VerifyCall") end
     469	  assert(node.id == nodes_codes["CALL"])
    1006	  local symbol = SymbolClass.GetSymbol(node.name)
    1227	  if (not symbol) then
     886	    Error(string.format("symbol '%s' was not declared.", node.name), node.line)
        	  end
     618	  if (symbol.id ~= "function") then
     393	    Error(string.format("attempt to call %s '%s', which is a '%s', not a 'function'.", symbol.id, symbol.name, symbol.type), node.line)
        	  end
     330	  local num_func_params = symbol.params and #symbol.params or 0
     407	  local num_call_params = node.exps and #node.exps or 0
     225	  if (num_func_params ~= num_call_params) then
     294	    Error(string.format("attempt to call function '%s' with '%d' parameter(s), but it demands '%d'.", symbol.name, num_func_params, num_call_params), node.line)
        	  end
     194	  for i = 1, num_func_params do
     269	    Semantic.VerifyExpression(node.exps[i])
     213	    Semantic.VerifyCompatibleTypes(node.line, symbol.params[i].type, symbol.params[i].dimension, node.exps[i].sem_type, node.exps[i].sem_dimension)
        	  end
     178	  node.sem_type = symbol.ret_type
     201	  node.sem_dimension = symbol.ret_dimension
        	end
        	
        	--VerifyCompatibleTypes: Check if two different variables can be matched
        	--  Parameters:
        	--    [1] $number = line number
        	--    [2] $string = type of first variable
        	--    [3] $number = dimension of first variable
        	--    [4] $string = type of second variable
        	--    [5] $number = dimension of second variable
        	--  Return:
     222	function Semantic.VerifyCompatibleTypes (line, first_type, first_dimension, second_type, second_dimension)
     511	  local err = false
    1427	  if (first_type ~= second_type) then
    1141	    if (first_type == "int" and second_type == "char") or (first_type == "char" and second_type == "int") then
     505	      if (first_dimension ~= 0 or second_dimension ~= 0) then
     291	        err = true
        	      end
        	    else
     145	      err = true
        	    end
        	  else
     342	    if (first_dimension ~= second_dimension) then
     602	      err = true
        	    end
        	  end
     522	  if (err) then
    1159	    Error(string.format("uncompatible types '%s' dimension '%d' and '%s' dimension '%d'.", first_type, first_dimension, second_type or "void", second_dimension or 0), line)
        	  end
     276	  return true
        	end
        	
        	--VerifyDeclare: Verify integrity of DECLARE node
        	--  Parameters:
        	--    [1] $table  = DECLARE node
        	--  Return:
      11	function Semantic.VerifyDeclare (node)
     334	  if (_DEBUG) then print("SEM :: VerifyDeclare") end
     781	  assert(node.id == nodes_codes["DECLARE"])
        	  --local symbol = SymbolClass.GetCurrentScopeSymbol(node.name)
     275	  local symbol = SymbolClass.GetSymbol(node.name)
     766	  if (symbol) then
     505	    Error(string.format("symbol '%s' was already declared at line %d.", symbol.name, symbol.line), node.line)
        	  else
     371	    SymbolClass.SetSymbol(node)
        	  end
        	end
        	
        	--VerifyElseIf: Verify integrity of ELSEIF node
        	--  Parameters:
        	--    [1] $table  = ELSEIF node
        	--  Return:
      44	function Semantic.VerifyElseIf (node)
     138	  if (_DEBUG) then print("SEM :: VerifyElseIf") end
      64	  assert(node.id == nodes_codes["ELSEIF"])
      81	  SymbolClass.AddScope()
     108	  Semantic.VerifyExpression(node.cond)
      43	  if (node.cond.sem_type ~= "bool" or node.cond.sem_dimension ~= 0) then
      32	    Error(string.format("'else if' expects expression of type 'bool' with dimension '0', but got type '%s' with dimension '%d'.", node.cond.sem_type, node.cond.sem_dimension), node.line)
        	  end
      22	  Semantic.VerifyBlock(node.block)
      76	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyExpression: Verify integrity of EXPRESSION node
        	--  Parameters:
        	--    [1] $table  = CALL, NEGATE, NEWVAR, OPERATOR, UNARY, VALUE or VAR node
        	--  Return:
     315	function Semantic.VerifyExpression (node)
    1166	  if (_DEBUG) then print("SEM :: VerifyExpression") end
    2874	  if (node.id == nodes_codes["CALL"]) then
    1946	    Semantic.VerifyCall(node)
    1232	  elseif (node.id == nodes_codes["NEGATE"]) then
    1975	    Semantic.VerifyNegate(node)
    1508	  elseif (node.id == nodes_codes["NEWVAR"]) then
    2178	    Semantic.VerifyNewVar(node)
    1125	  elseif (node.id == nodes_codes["OPERATOR"]) then
    2399	    Semantic.VerifyOperator(node)
    1137	  elseif (node.id == nodes_codes["UNARY"]) then
    2002	    Semantic.VerifyUnary(node)
     883	  elseif (node.id == nodes_codes["LITERAL"]) then
    2238	    Semantic.VerifyLiteral(node)
    1085	  elseif (node.id == nodes_codes["VAR"]) then
    1946	    Semantic.VerifyVar(node)
        	  else
     364	    Error("unknown expression node", node.line)
        	  end
        	end
        	
        	--VerifyFunction: Verify integrity of FUNCTION node
        	--  Parameters:
        	--    [1] $table  = FUNCTION node
        	--  Return:
       6	function Semantic.VerifyFunction (node)
     714	  if (_DEBUG) then print("SEM :: VerifyFunction") end
    1646	  assert(node.id == nodes_codes["FUNCTION"])
    2233	  SymbolClass.AddScope()
    2227	  for _, param in ipairs(node.params) do
    1586	    if (SymbolClass.GetSymbol(param.name)) then
        	    --if (SymbolClass.GetCurrentScopeSymbol(param.name)) then
     112	      Error(string.format("function parameter '%s' already declared.", param.name), node.line)
        	    end
     448	    SymbolClass.SetSymbol(param)
        	  end
     625	  if (node.ret_type) then
    1511	    local ret = {
    1488	      id        = nodes_codes["DECLARE"],
     781	      name      = "@ret",
     880	      line      = node.line,
     867	      type      = node.ret_type,
     830	      dimension = node.ret_dimension,
     843	    }
     829	    SymbolClass.SetSymbol(ret)
        	  end
     676	  Semantic.VerifyBlock(node.block)
    1109	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyGlobals: Add global functions and variables to scope
        	--  Parameters:
        	--    [1] $table  = PROGRAM node
        	--  Return:
     111	function Semantic.VerifyGlobals (t)
     419	  if (_DEBUG) then print("SEM :: VerifyGlobals") end
    1155	  assert(t.id == nodes_codes["PROGRAM"])
    1836	  for _, node in ipairs(t) do
    2201	    local symbol = SymbolClass.GetSymbol(node.name)
    1483	    if (symbol) then
     994	      Error(string.format("global symbol '%s' was already declared at line %d.", symbol.name, symbol.line), node.line)
        	    end
     585	    SymbolClass.SetSymbol(node)
        	  end
        	end
        	
        	--VerifyIf: Verify integrity of IF node
        	--  Parameters:
        	--    [1] $table  = IF node
        	--  Return:
     174	function Semantic.VerifyIf (node)
      53	  if (_DEBUG) then print("SEM :: VerifyIf") end
     175	  assert(node.id == nodes_codes["IF"])
     106	  SymbolClass.AddScope()
     141	  Semantic.VerifyExpression(node.cond)
     177	  if (node.cond.sem_type ~= "bool" or node.cond.sem_dimension ~= 0) then
     148	    Error(string.format("'if' expects expression of type 'bool' with dimension '0', but got type '%s' with dimension '%d'.", node.cond.sem_type, node.cond.sem_dimension), node.line)
        	  end
     141	  Semantic.VerifyBlock(node.block)
     115	  if (node["elseif"]) then
     156	    for _, n in ipairs (node["elseif"]) do
     176	      Semantic.VerifyElseIf(n)
        	    end
        	  end
     182	  SymbolClass.AddScope()
     151	  Semantic.VerifyBlock(node["else"])
      80	  SymbolClass.RemoveScope()
      86	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyLiteral: Verify integrity of LITERAL node
        	--  Parameters:
        	--    [1] $table  = LITERAL node
        	--  Return:
       9	function Semantic.VerifyLiteral (node)
     664	  if (_DEBUG) then print("SEM :: VerifyLiteral") end
    1526	  assert(node.id == nodes_codes["LITERAL"])
    1233	  node.sem_type = node.type
    1208	  node.sem_dimension = node.dimension
        	end
        	
        	--VerifyNewVar: Verify integrity of NEWVAR node
        	--  Parameters:
        	--    [1] $table  = NEWVAR node
        	--  Return:
      61	function Semantic.VerifyNewVar (node)
      81	  if (_DEBUG) then print("SEM :: VerifyNewVar") end
      56	  assert(node.id == nodes_codes["NEWVAR"])
     154	  Semantic.VerifyExpression(node.exp)
     114	  if (node.exp.sem_type ~= "int" and node.exp.sem_type ~= "char") then
     229	    Error(string.format("'new var' expression must have type 'int' or 'char', but got type '%s'.", node.exp.sem_type), node.line)
        	  end
      67	  node.sem_type = node.type
      53	  node.sem_dimension = node.dimension + 1
        	end
        	
        	--VerifyNegate: Verify integrity of NEGATE node
        	--  Parameters:
        	--    [1] $table  = NEGATE node
        	--  Return:
     410	function Semantic.VerifyNegate (node)
     100	  if (_DEBUG) then print("SEM :: VerifyNegate") end
      99	  assert(node.id == nodes_codes["NEGATE"])
     173	  Semantic.VerifyExpression(node.exp)
     179	  if (node.exp.sem_type ~= "bool" or node.exp.sem_dimension ~= 0) then
      97	    Error(string.format("'not' must be done over type 'bool' with dimension '0', but got type '%s' with dimension '%d'.", node.exp.sem_type, node.exp.sem_dimension))
        	  end
     367	  node.sem_type = "bool"
     224	  node.sem_dimension = 0
        	end
        	
        	--VerifyOperator: Verify integrity of OPERATOR node
        	--  Parameters:
        	--    [1] $table  = NEGATE node
        	--  Return:
     222	function Semantic.VerifyOperator (node)
     351	  if (_DEBUG) then print("SEM :: VerifyOperator") end
     870	  assert(node.id == nodes_codes["OPERATOR"])
     627	  Semantic.VerifyExpression(node[1])
     644	  Semantic.VerifyExpression(node[2])
     447	  if (node.op == "and" or node.op == "or") then
     340	    if (node[1].sem_type ~= "bool") then
      64	      Error(string.format("operation '%s' cannot be made over left type '%s'.", node.op, node[1].sem_type), node.line)
     156	    elseif (node[2].sem_type ~= "bool") then
     146	      Error(string.format("operation '%s' cannot be made over right type '%s'.", node.op, node[2].sem_type), node.line)
        	    end
     216	    if (node[1].sem_dimension ~= 0) then
     529	      Error(string.format("operation '%s' cannot be made over arrays values, but left side of expression has dimension '%d'.", node.op, node[1].sem_dimension), node.line)
     536	    elseif (node[2].sem_dimension ~= 0) then
     995	      Error(string.format("operation '%s' cannot be made over arrays values, but right side of expression has dimension '%d'.", node.op, node[2].sem_dimension), node.line)
        	    end
     560	    node.sem_type = "bool"
     198	    node.sem_dimension = 0
     347	  elseif (node.op == "=" or node.op == "<>") then
     835	    if (node[1].sem_type ~= node[2].sem_type) then
     232	      if ((node[1].sem_type ~= "int" and node[1].sem_type ~= "char") or (node[2].sem_type ~= "int" and node[2].sem_type ~= "char")) then
     355	        Error(string.format("operation '%s' require 'int' or 'char' expressions on both sides, but got '%s' and '%s'.", node.op, node[1].sem_type, node[2].sem_type), node.line)
        	      end
        	    end
      82	    if (node[1].sem_dimension ~= node[2].sem_dimension) then
     175	      Error(string.format("operation '%s' require variables with same dimension, but got dimensions '%s' and '%s'.", node.op, node[1].sem_dimension, node[2].sem_dimension), node.line)
        	    end
     190	    node.sem_type = "bool"
     282	    node.sem_dimension = 0
     280	  elseif (node.op == ">" or node.op == "<" or node.op == ">=" or node.op == "<=" or 
     398	          node.op == "+" or node.op == "-" or node.op == "*" or node.op == "/") then
     410	    if (node[1].sem_type ~= "int" and node[1].sem_type ~= "char") then
     345	      Error(string.format("operation '%s' require 'int' or 'char' expression on both sides, but got type '%s' on left side.", node.op, node[1].sem_type), node.line)
     159	    elseif (node[2].sem_type ~= "int" and node[2].sem_type ~= "char") then
     261	      Error(string.format("operation '%s' require 'int' or 'char' expression on both sides, but got type '%s' on right side.", node.op, node[2].sem_type), node.line)
     186	    elseif (node[1].sem_dimension ~= 0) then
     285	      Error(string.format("operation '%s' require dimension '0' on both sides, but got dimension '%d' on left side.", node.op, node[1].sem_dimension), node.line)
     195	    elseif (node[2].sem_dimension ~= 0) then
     222	      Error(string.format("operation '%s' require dimension '0' on both sides, but got dimension '%d' on right side.", node.op, node[2].sem_dimension), node.line)
        	    end
     164	    node.sem_dimension = 0
     373	    if (node.op == ">" or node.op == "<" or node.op == ">=" or node.op == "<=") then
     284	      node.sem_type = "bool"
        	    else
     164	      node.sem_type = "int"
        	    end
        	  else
      95	    Error(string.format("unknown operation '%s'.", node.op), node.line)
        	  end
        	end
        	
        	--VerifyProgram: Verify integrity of PROGRAM node
        	--  Parameters:
        	--    [1] $table  = PROGRAM node
        	--  Return:
     507	function Semantic.VerifyProgram (t)
     911	  if (_DEBUG) then print("SEM :: VerifyProgram") end
    1473	  assert(t.id == nodes_codes["PROGRAM"])
    1597	  SymbolClass.AddScope()
    1811	  Semantic.VerifyGlobals(t)
    1757	  for _, node in ipairs(t) do
    1701	    if (node.id == nodes_codes["DECLARE"]) then
        	      -- node already saved in symbol table while verifying globals
     861	    elseif (node.id == nodes_codes["FUNCTION"]) then
    1269	      Semantic.VerifyFunction(node)
        	    else
     151	      Error("unknown program node.")
        	    end
        	  end
     266	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyReturn: Verify integrity of RETURN node
        	--  Parameters:
        	--    [1] $table  = RETURN node
        	--  Return:
      54	function Semantic.VerifyReturn (node)
     293	  if (_DEBUG) then print("SEM :: VerifyReturn") end
     762	  assert(node.id == nodes_codes["RETURN"])
     795	  local symbol = SymbolClass.GetSymbol("@ret")
     840	  if (not symbol) then
     621	    if (node.exp) then
     128	      Error(string.format("function with return 'void' must not attempt to call 'return'."), node.line)
        	    end
     322	  elseif (node.exp) then
     812	    Semantic.VerifyExpression(node.exp)
     789	    Semantic.VerifyCompatibleTypes(node.line, symbol.type, symbol.dimension, node.exp.sem_type, node.exp.sem_dimension)
     526	  elseif (symbol.type) then
      41	    Error(string.format("function expected to return type '%s' but got 'nil'.", symbol.type), node.line)
        	  else
      32	    Error("unknown function return error.", node.line)
        	  end
        	end
        	
        	--VerifyUnary: Verify integrity of UNARY node
        	--  Parameters:
        	--    [1] $table  = UNARY node
        	--  Return:
      24	function Semantic.VerifyUnary (node)
     126	  if (_DEBUG) then print("SEM :: VerifyUnary") end
     139	  assert(node.id == nodes_codes["UNARY"])
     139	  Semantic.VerifyExpression(node.exp)
     288	  if ((node.exp.sem_type ~= "int" and node.exp.sem_type ~= "char") or node.exp.sem_dimension ~= 0) then
     487	    Error(string.format("'unary' must be done over type 'char' or 'int' with dimension '0', but got type '%s' with dimension '%d'.", node.exp.sem_type, node.exp.sem_dimension), node.line)
        	  end
     799	  node.sem_type = node.exp.sem_type
     681	  node.sem_dimension = node.exp.sem_dimension
        	end
        	
        	--VerifyVar: Verify integrity of VAR node
        	--  Parameters:
        	--    [1] $table  = VAR node
        	--  Return:
     127	function Semantic.VerifyVar (node)
     858	  if (_DEBUG) then print("SEM :: VerifyVar") end
    2520	  assert(node.id == nodes_codes["VAR"])
    2466	  local symbol = SymbolClass.GetSymbol(node.name)
    2352	  if (not symbol) then
    1601	    Error(string.format("symbol '%s' was not declared.", node.name), node.line)
        	  end
     863	  node.sem_type = symbol.type
    2422	  if (symbol.dimension and symbol.dimension > 0) then
    2281	    if (#node.array > symbol.dimension) then
    1113	      Error(string.format("symbol '%s' dimension is '%d', but was called with dimension '%d'.", node.name, symbol.dimension, #node.array), node.line)
        	    end
     622	    for _, exp in ipairs(node.array) do
    1138	      Semantic.VerifyExpression(exp)
     642	      if (exp.sem_type ~= "int" and exp.sem_type ~= "char") then
     602	        Error(string.format("symbol '%s' dimension must be an 'int' or 'char', but was called with dimension '%s'.", node.name, exp.sem_type), node.line)
        	      end
        	    end
     555	    node.sem_dimension = symbol.dimension - #node.array
    1311	  elseif (node.array and #node.array > 0) then
    1045	    Error(string.format("symbol '%s' dimension is '0', but was called with dimension '%d'.", node.name, #node.array), node.line)
        	  else
     543	    node.sem_dimension = 0
        	  end
        	end
        	
        	--VerifyWhile: Verify integrity of WHILE node
        	--  Parameters:
        	--    [1] $table  = WHILE node
        	--  Return:
      65	function Semantic.VerifyWhile (node)
      68	  if (_DEBUG) then print("SEM :: VerifyWhile") end
     114	  assert(node.id == nodes_codes["WHILE"])
      32	  SymbolClass.AddScope()
     131	  Semantic.VerifyExpression(node.cond)
      41	  if (node.cond.sem_type ~= "bool" or node.cond.sem_dimension ~= 0) then
      91	    Error(string.format("while expects 'bool' expression with dimension '0', but got type '%s' with dimension '%d'.", node.cond.sem_type, node.cond.sem_dimension), node.line)
        	  end
      17	  Semantic.VerifyBlock(node.block)
      27	  SymbolClass.RemoveScope()
        	end
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--GetTree:
        	--  parameters:
        	--  return:
        	--    [1] $boolean - false if found any problem, true otherwise
     173	function Semantic.GetTree ()
     188	  return tree
        	end
        	
        	--Open:
        	--  parameters:
        	--    [1] $table   - table with AST tree nodes
        	--  return:
        	--    [1] $boolean - false if found any problem, true otherwise
        	--    [2] $string  - only when [1] is false, informing which error occurs
      57	function Semantic.Open (t)
     407	  if (_DEBUG) then print("SEM :: Open") end
    1076	  assert(t and type(t) == "table")
    1118	  SymbolClass.Clear()
    1463	  local ok, msg = pcall(function () Semantic.VerifyProgram(t) end)
    1809	  if (not ok) then
    1066	    return false, msg
        	  end
     127	  tree = t
     270	  if (printTree) then
     189	    Semantic.Print(t)
        	  end
     180	  return true
        	end
        	
        	--Print: Print Abstract Semantic Tree with comprehensible format
        	--  parameters:
        	--  return:
      21	function Semantic.Print (t)
       3	  PrintClass.Print(t)
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       3	return Semantic

==============================================================================
./src/symbol_table.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      19	require "lib/util"
      19	local NodesClass  = require "lib/node_codes"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      19	local SymbolTable = {}
        	
      19	local scopes = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
      19	local nodes_codes = NodesClass.GetNodesList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
      19	function Error ()
*******0	  error("Symbol error.", 0)
        	end
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--AddScope: Insert a new scope level
        	--  parameters:
        	--  return:
      19	function SymbolTable.AddScope ()
    4102	  if (_DEBUG) then print("SYB :: AddScope") end
    4102	  scopes[#scopes + 1] = {}
        	end
        	
        	--Clear: Remove all scopes
        	--  parameters:
        	--  return:
      19	function SymbolTable.Clear ()
    1712	  if (_DEBUG) then print("SYB :: Clear") end
    1712	  scopes = {}
        	end
        	
        	--GetCurrentScopeSymbol: Get symbol only if present in current scope
        	--  parameters:
        	--    [1] $string         - Symbol name
        	--  return:
        	--    [1] $table or $nil  - Copy of symbol structure if found, otherwise nil
     415	function SymbolTable.GetCurrentScopeSymbol (name)
    1226	  if (_DEBUG) then print("SYB :: GetCurrentScopeSymbol") end
     964	  local num_scope = #scopes
     609	  if (scopes[#scopes][name]) then
     161	    local symbol = util.TableCopy(scopes[#scopes][name])
     155	    symbol.name = name
     131	    return symbol
        	  end
     448	  return nil
        	end
        	
        	--GetSymbol: Get symbol if present in current or above scopes
        	--  parameters:
        	--    [1] $string         - Symbol name
        	--  return:
        	--    [1] $table or $nil  - Copy of symbol structure if found, otherwise nil
     816	function SymbolTable.GetSymbol (name)
    7965	  if (_DEBUG) then print("SYB :: GetSymbol") end
    7967	  local num_scope = #scopes
   15064	  while (num_scope > 0) do
   11190	    if (scopes[num_scope][name]) then
    4638	      local symbol = util.TableCopy(scopes[num_scope][name])
    4091	      symbol.name = name
    4320	      return symbol
        	    end
    7154	    num_scope = num_scope - 1
        	  end
    3619	  return nil
        	end
        	
        	--Print: Print symbol table
        	--  parameters:
        	--  return:
      14	function SymbolTable.Print ()
*******0	  if (_DEBUG) then print("SYB :: Print") end
*******0	  util.TablePrint(scopes)
        	end
        	
        	--RemoveScope: Remove current scope
        	--  parameters:
        	--  return:
      14	function SymbolTable.RemoveScope ()
    1251	  if (_DEBUG) then print("SYB :: RemoveScope") end
    1251	  scopes[#scopes] = nil
        	end
        	
        	--SetSymbol: Create a new symbol in current scope
        	--          function or var
        	--  parameters:
        	--    [1] $table  - 
        	--              id   = $number - 
        	--              name = $string - 
        	--              line = $number - 
        	--              func_params {
        	--                params        = $table  - 
        	--                ret_type      = $string - 
        	--                ret_dimension = $number - 
        	--              }
        	--              var_params {
        	--                type
        	--                dimension = $number - 
        	--              }
        	--  return:
     352	function SymbolTable.SetSymbol (t)
    5099	  if (_DEBUG) then print("SYB :: SetSymbol") end
    5260	  assert(t and type(t) == "table")
    5260	  assert(t.line and type(t.line) == "number")
    5099	  assert(t.name and type(t.name) == "string")
    5070	  local symbol = {}
    4907	  symbol.line = t.line
    4907	  symbol.name = t.name
    4907	  if (t.id == nodes_codes["FUNCTION"]) then
    1920	    symbol.id = "function"
    1920	    symbol.params = util.TableCopy(t.params)
    1920	    symbol.ret_type = t.ret_type
    1922	    symbol.ret_dimension = t.ret_dimension
    3033	  elseif (t.id == nodes_codes["DECLARE"] or t.id == nodes_codes["PARAMETER"]) then
    3033	    symbol.id = "variable"
    3033	    symbol.type = t.type
    3371	    symbol.dimension = t.dimension
        	  else
*******0	    Error()
        	  end
    4761	  scopes[#scopes] = scopes[#scopes] or {}
    4761	  scopes[#scopes][t.name] = symbol
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       1	return SymbolTable

==============================================================================
./src/syntactic.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      19	local ParserClass 	= require "src/parser"
      19	local LanguageClass = require "src/grammar"
      19	local ASTClass		  = require "src/syntax_tree"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      19	local Syntactic = {}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--GetTree:
        	--  parameters:
        	--  return:
     653	function Syntactic.GetTree()
    1078	  if (_DEBUG) then print("SYN :: GetTree") end
    1062	  return ASTClass.GetTree()
        	end
        	
        	--Open:
        	--  parameters:
        	--    [1] $table   - table with tokens read in lexical
        	--  return:
        	--    [1] $boolean - false if found any problem, true otherwise
        	--    [2] $string  - only when [1] is false, informing which error occurs
    1069	function Syntactic.Open (t)
    2206	  if (_DEBUG) then print("SYN :: Open") end
    2206	  assert(t and type(t) == "table")
    2206	  ParserClass.Open(t)
    1556	  local ok, msg = LanguageClass.Start(ParserClass.Advance, ParserClass.Peek, ParserClass.Peek2)
    1140	  if (not ok) then
     728	  	return false, msg
        	  end
    1062	  return true
        	end
        	
        	--PrintTree:
       3	function Syntactic.PrintTree()
      16	  if (_DEBUG) then print("SYN :: PrintTree") end
*******0	  return ASTClass.Print()
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       3	return Syntactic

==============================================================================
./src/syntax_tree.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
      19	local printTree = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      19	require "lib/util"
      19	local NodesClass  = require "lib/node_codes"
      14	local PrintClass  = require "lib/util_tree"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      14	local AbstractSyntaxTree = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
      14	local nodes_codes = NodesClass.GetNodesList()
        	
        	--  AST tree (structed nodes)
      14	local tree = {}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--GetTree:
        	--  parameters:
        	--  return:
     466	function AbstractSyntaxTree.GetTree ()
        	  --return util.TableCopy(tree)
    1062	  return tree
        	end
        	
        	--NewAttributionNode:
        	--  {
        	--    id    = $number - ATTRIBUTION code
        	--    exp   = $table  - EXPRESSION node
        	--    line  = $number - line number
        	--    var   = $table  - VAR node
        	--  }
        	--  parameters:
        	--  return:
    1104	function AbstractSyntaxTree.NewAttributionNode (var, expression)
    1955	  if (_DEBUG) then print("AST :: NewAttributionNode") end
    1955	  local node = {
    1960	    id    = nodes_codes["ATTRIBUTION"],
    1955	    exp   = expression,
     859	    line  = var.line,
    1955	    var   = var,
      11	  }
     854	  return node
        	end
        	
        	--NewCallNode:
        	--  {
        	--    id    = $number - CALL code
        	--    line  = $number - line number
        	--    name  = $string - var name
        	--    exps  = $table  - list of EXPRESSION nodes
        	--  }
        	--  parameters:
        	--  return:
     228	function AbstractSyntaxTree.NewCallNode (line, name, expressions)
     329	  if (_DEBUG) then print("AST :: NewCallNode") end
     329	  local node = {
     334	    id   = nodes_codes["CALL"],
     329	    line = line,
     114	    name = name,
     329	    exps = expressions,
      11	  }
     109	  return node
        	end
        	
        	--NewDeclVarNode:
        	--  {
        	--    id        = $number - DECLARE code
        	--    line      = $number - line number
        	--    name      = $string - var name
        	--    dimension = $number - var dimension
        	--    type      = $string - [bool, char, int]
        	--  }
        	--  parameters:
        	--  return:
     641	function AbstractSyntaxTree.NewDeclVarNode (line, name, typebase, size)
    1706	  if (_DEBUG) then print("AST :: NewDeclVarNode") end
    1706	  local node = {
    1706	    id        = nodes_codes["DECLARE"],
    1711	    line      = line,
    1706	    name      = name,
    1073	    dimension = size,
    1706	    type      = typebase,
      19	  }
    1078	  if (node.type == "string") then
      98	    node.type = "char"
     217	    node.dimension = node.dimension + 1
        	  end
    1068	  return node
        	end
        	
        	--NewElseIfNode:
        	--  {
        	--    id    = $number - ELSEIF code
        	--    block = $table  - list of COMMANDS that will be executed if [cond] is true
        	--    cond  = $table  - EXPRESSION NODE, represents condition
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
      91	function AbstractSyntaxTree.NewElseIfNode (line, condition, block)
      66	  if (_DEBUG) then print("AST :: NewElseIfNode") end
     138	  local node = {
      75	    id          = nodes_codes["ELSEIF"],
      66	    block       = block,
      50	    cond        = condition,
      66	    line        = line,
       2	  }
      50	  return node
        	end
        	
        	--NewFunctionNode:
        	--  {
        	--    id            = $number - FUNCTION code
        	--    block         = $table  - list of COMMANDS that will be executed
        	--    line          = $number - line number
        	--    name          = $string - var name
        	--    params        = $table  - list of PARAMETER nodes
        	--    ret_type      = $string - [bool, char, int], represents function return type
        	--    ret_dimension = $number - function return dimension
        	--  }
        	--  parameters:
        	--  return:
     711	function AbstractSyntaxTree.NewFunctionNode (line, name, parameters, return_type, return_size, block)
    1899	  if (_DEBUG) then print("AST :: NewFunctionNode") end
    1899	  local node = {
    1899	    id            = nodes_codes["FUNCTION"],
    1323	    line          = line,
    1899	    name          = name,
    1332	    params        = parameters,
    1323	    ret_type      = return_type,
    1191	    ret_dimension = return_size,
    1323	    block         = block,
       2	  }
    1191	  if (node.ret_type == "string") then
      89	    node.ret_type = "char"
      84	    node.ret_dimension = node.ret_dimension + 1
        	  end
    1191	  return node
        	end
        	
        	--NewIfNode:
        	--  {
        	--    id      = $number - IF code
        	--    block   = $table  - list of COMMANDS that will be executed if [cond] is true
        	--    cond    = $table  - EXPRESSION NODE, represents condition
        	--    else    = $table  - list of COMMANDS that will be executed none conditions are true
        	--    elseif  = $table  - list of ELSEIF nodes
        	--    line    = $number - line number
        	--  }
        	--  parameters:
        	--  return:
     201	function AbstractSyntaxTree.NewIfNode (line, condition, block, elseif_node, else_block)
     152	  if (_DEBUG) then print("AST :: NewIfNode") end
     143	  if (elseif_node and util.TableIsEmpty(elseif_node)) then
      75	    elseif_node = nil
        	  end
     109	  local node = {
     107	    id          = nodes_codes["IF"],
     112	    block       = block,
     107	    cond        = condition,
     112	    ["else"]    = else_block,
     107	    ["elseif"]  = elseif_node,
     116	    line        = line,
     104	  }
     211	  return node
        	end
        	
        	--NewLiteralNode:
        	--  {
        	--    id        = $number   - LITERAL code
        	--    dimension = $number   - var dimension
        	--    line      = $number   - line number
        	--    type      = $string   - [bool, char, int, string]
        	--    value     = $string   - if type == char or string, -- Value cannot be 'char' type.
        	--                $number   - if type == int,
        	--                $boolean  - if type == bool,
        	--  }
        	--  parameters:
        	--  return:
       3	function AbstractSyntaxTree.NewLiteralNode (line, type, value)
    1033	  if (_DEBUG) then print("AST :: NewLiteralNode") end
    1033	  local node = {
    1042	    id        = nodes_codes["LITERAL"],
    1096	    dimension = 0,
    1096	    line      = line,
    1096	    type      = type,
    1098	    value     = value,
      77	  }
    1110	  if (node.type == "string") then
     131	    node.type = "char"
      68	    node.dimension = 1
        	  end
    1061	  return node
        	end
        	
        	--NewNegateNode:
        	--  {
        	--    id    = $number - NEGATE code
        	--    exp   = $table  - EXPRESSION node
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
       3	function AbstractSyntaxTree.NewNegateNode (line, expression)
      81	  if (_DEBUG) then print("AST :: NewNegateNode") end
     991	  local node = {
     996	    id    = nodes_codes["NEGATE"],
    1435	    exp   = expression,
    1437	    line  = line,
    1575	  }
    1647	  return node
        	end
        	
        	--NewNewVarNode:
        	--  {
        	--    id        = $number - NEWVAR code
        	--    dimension = $number - var dimension
        	--    exp       = $table  - EXPRESSION node
        	--    line      = $number - line number
        	--    type      = $string - [bool, char, int]
        	--  }
        	--  parameters:
        	--  return:
       3	function AbstractSyntaxTree.NewNewVarNode (line, expression, type, dimension)
      56	  if (_DEBUG) then print("AST :: NewNewVarNode") end
      56	  local node = {
      70	    id        = nodes_codes["NEWVAR"],
     412	    dimension = dimension,
     412	    exp       = expression,
     412	    line      = line,
     414	    type      = type,
     416	  }
     472	  if (node.type == "string") then
     330	    node.type = "char"
     146	    node.dimension = node.dimension + 1
        	  end
     125	  return node
        	end
        	
        	--NewOperatorNode:
        	--  {
        	--    id    = $number - OPERATOR code
        	--    line  = $number - line number
        	--    op    = $string - [and or + - * / > < >= <= = <>], one of possible operations
        	--    [1]   = $table  - EXPRESSION node, left side of operator
        	--    [2]   = $table  - EXPRESSION node, right side of operator
        	--  }
        	--  parameters:
        	--  return:
     227	function AbstractSyntaxTree.NewOperatorNode (line, left, operator, right)
     887	  if (_DEBUG) then print("AST :: NewOperatorNode") end
     885	  local node = {
     885	    id    = nodes_codes["OPERATOR"],
     885	    line  = line,
     894	    op    = operator,
     661	    left,
     224	    right,
     666	  }
     663	  return node
        	end
        	
        	--NewParameterNode:
        	--  {
        	--    id        = $number - PARAMETER code
        	--    dimension = $number - var dimension
        	--    line      = $number - line number
        	--    name      = $string - var name
        	--    type      = $string - [bool, char, int]
        	--  }
        	--  parameters:
        	--  return:
     125	function AbstractSyntaxTree.NewParameterNode (line, name, typebase, size)
     682	  if (_DEBUG) then print("AST :: NewProgramNode") end
     684	  local node = {
     596	    id        = nodes_codes["PARAMETER"],
     560	    line      = line,
     596	    name      = name,
     565	    dimension = size,
     560	    type      = typebase,
       9	  }
     731	  if (node.type == "string") then
     231	    node.type = "char"
     231	    node.dimension = node.dimension + 1
        	  end
     769	  return node
        	end
        	
        	--NewProgramNode:
        	--  {
        	--    id       = $number - PROGRAM code
        	--    [1 to N] = DECLARE or FUNCTION node
        	--  }
        	--  parameters:
        	--  return:
     287	function AbstractSyntaxTree.NewProgramNode (ast_tree)
    1346	  if (_DEBUG) then print("AST :: NewProgramNode") end
    1346	  tree = {}
    1355	  tree = util.TableCopy(ast_tree)
    1413	  tree.id = nodes_codes["PROGRAM"]
    1413	  if (printTree) then AbstractSyntaxTree.Print() end
        	end
        	
        	--NewReturnNode:
        	--  {
        	--    id    = $number - RETURN code
        	--    line  = $number - line number
        	--    exp   = $table  - EXPRESSION node
        	--  }
        	--  parameters:
        	--  return:
       3	function AbstractSyntaxTree.NewReturnNode (line, expression)
     744	  if (_DEBUG) then print("AST :: NewReturnNode") end
     744	  local node = {
     744	    id    = nodes_codes["RETURN"],
     744	    exp   = expression,
     744	    line  = line,
       5	  }
     826	  return node
        	end
        	
        	--NewUnaryNode:
        	--  {
        	--    id    = $number - UNARY code
        	--    exp   = $table  - EXPRESSION node
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
     295	function AbstractSyntaxTree.NewUnaryNode (line, expression)
      42	  if (_DEBUG) then print("AST :: NewUnaryNode") end
     334	  local node = {
      44	    id    = nodes_codes["UNARY"],
      42	    exp   = expression,
      42	    line  = line,
        	  }
      42	  return node
        	end
        	
        	--NewVarNode:
        	--  {
        	--    id    = $number - VAR code
        	--    array = $table  - list of EXPRESSIONS, one for each dimension
        	--    line  = $number - line number
        	--    name  = $string - var name
        	--  }
        	--  parameters:
        	--  return:
     546	function AbstractSyntaxTree.NewVarNode (line, name, array)
    3245	  if (_DEBUG) then print("AST :: NewVarNode") end
    2711	  local node = {
    3245	    id    = nodes_codes["VAR"],
    2713	    line  = line,
    2711	    name  = name,
    2711	    array = array,
        	  }
    2711	  return node
        	end
        	
        	--NewWhileNode:
        	--  {
        	--    id    = $number - WHILE code
        	--    block = $table  - list of COMMANDS that will be executed if [cond] is true
        	--    cond  = $table  - EXPRESSION node, represents condition
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
      27	function AbstractSyntaxTree.NewWhileNode (line, condition, block)
      41	  if (_DEBUG) then print("AST :: NewWhileNode") end
      31	  local node = {
      41	    id    = nodes_codes["WHILE"],
      33	    block = block,
      40	    cond  = condition,
      31	    line  = line,
        	  }
      40	  return node
        	end
        	
        	--Print: Print Abstract Syntax Tree with comprehensible format
        	--  parameters:
        	--  return:
     482	function AbstractSyntaxTree.Print ()
     488	  if (_DEBUG) then print("AST :: Print") end
     479	  PrintClass.Print(tree)
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       3	return AbstractSyntaxTree

==============================================================================
src/auto_test.lua
==============================================================================
        	--==============================================================================
        	-- Global Defines
        	--==============================================================================
        	
      19	_DEBUG = false
      18	local printFailMessage = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      19	require "lib/util"
      19	local Lexical       = require "src/lexical"
      19	local Syntactic     = require "src/syntactic"
      18	local Semantic      = require "src/semantic"
       3	local InterCodeGen  = require "src/intermediate_code"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
       4	local files = {
      16	  {
      19	    name      = "nil_file",
      18	    open      = false,
       4	  },
      16	  {
      19	    name      = "lex_fail",
      19	    open      = true,
      19	    lexical   = false,
       3	  },
      16	  {
      19	    name      = "lex_overload_01",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = false,
       3	  },
      16	  {
      19	    name      = "lex_overload_02",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = false,
       3	  },
      16	  {
      19	    name      = "lex_overload_03",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = false,
       3	  },
      16	  {
      19	    name      = "lex_overload_04",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = false,
       4	  },
      15	  {
      19	    name      = "sem_complete_program",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = true,
       4	  },
      15	  {
      19	    name      = "sem_elseif_block",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = true,
       4	  },
      15	  {
      19	    name      = "sem_fail_attrib_string_char",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  },
      15	  {
      19	    name      = "sem_fail_attrib_char_string",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  },
      15	  {
      19	    name      = "sem_fail_attrib_int_bool",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  },
      15	  {
      19	    name      = "sem_fail_call_not_function",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  },
      15	  {
      19	    name      = "sem_fail_call_wrong_param_number",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  },
      15	  {
      19	    name      = "sem_fail_declare_same_name_01",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  },
      15	  {
      19	    name      = "sem_fail_declare_same_name_02",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  }, 
      15	  {
      19	    name      = "sem_fail_elseif_condition",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  },
      15	  {
      18	    name      = "sem_fail_exp_negate_char",
      18	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  },
      16	  {
      18	    name      = "sem_fail_exp_sum_bool",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  },
      16	  {
      18	    name      = "sem_fail_exp_unary_bool",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  },
      16	  {
      18	    name      = "sem_fail_func_ret_dimension_different",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  },
      16	  {
      18	    name      = "sem_fail_func_ret_nil",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  },
      16	  {
      18	    name      = "sem_fail_func_ret_type_different",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  },
      16	  {
      18	    name      = "sem_fail_func_same_par_name",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  },
      16	  {
      18	    name      = "sem_fail_func_void_return",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = true,
       4	  },
      15	  {
      17	    name      = "sem_fail_if_condition_int",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       5	  },
      14	  {
      19	    name      = "sem_fail_var_array_bool",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = false,
       4	  },
      15	  {
      19	    name      = "sem_fail_var_array_dimension_zero",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      18	    semantic  = false,
       5	  },
       9	  {
      13	    name      = "sem_fail_var_array_larger",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      18	    semantic  = false,
      11	  },
       9	  {
      19	    name      = "sem_fail_var_existent",
      19	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      18	    semantic  = false,
      11	  },
       8	  {
      18	    name      = "sem_fail_var_undeclared",
      19	    open      = true,
      19	    lexical   = true,
      18	    syntactic = true,
      19	    semantic  = false,
      12	  },
        	
        	  -- ITERATION 3
      16	  {
      19	    name      = "00-fail-empty",
      18	    open      = true,
      19	    lexical   = true,
      19	    syntactic = false,
       4	  },
      16	  {
      19	    name      = "01-global",
      18	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = true,
       4	  },
      16	  {
      19	    name      = "02-fun",
      18	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      18	    semantic  = true,
       5	  },
      16	  {
      19	    name      = "03-nls",
      18	    open      = true,
      19	    lexical   = true,
      18	    syntactic = true,
      19	    semantic  = false,
       5	  },
      16	  {
      18	    name      = "04-funglobal",
      19	    open      = true,
      18	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = true,
       5	  },
      16	  {
      18	    name      = "05-params",
      19	    open      = true,
      18	    lexical   = true,
      19	    syntactic = true,
      13	    semantic  = false,
      11	  },
      15	  {
      19	    name      = "06-declvar",
      19	    open      = true,
      18	    lexical   = true,
      13	    syntactic = true,
      19	    semantic  = false,
      11	  },
      15	  {
      19	    name      = "07-if",
      18	    open      = true,
      13	    lexical   = true,
      19	    syntactic = true,
      18	    semantic  = false,
      12	  },
      15	  {
      19	    name      = "08-fail-else",
      18	    open      = true,
      13	    lexical   = true,
      18	    syntactic = false,
      12	  },
      16	  {
      18	    name      = "09-fail-elseif",
      18	    open      = true,
      19	    lexical   = true,
      12	    syntactic = false,
      12	  },
      16	  {
      19	    name      = "10-fail-if",
      18	    open      = true,
      18	    lexical   = true,
      13	    syntactic = false,
      11	  },
      16	  {
      19	    name      = "11-ifdecl",
      18	    open      = true,
      19	    lexical   = true,
      18	    syntactic = true,
      13	    semantic  = false,
      11	  },
      16	  {
      18	    name      = "12-while",
      19	    open      = true,
      18	    lexical   = true,
      13	    syntactic = true,
      18	    semantic  = false,
      12	  },
      15	  {
      19	    name      = "13-fail-while",
      19	    open      = true,
      18	    lexical   = true,
      13	    syntactic = false,
      11	  },
      15	  {
      19	    name      = "14-ifwhile",
      19	    open      = true,
      18	    lexical   = true,
      19	    syntactic = true,
      12	    semantic  = true,
      11	  },
      16	  {
      19	    name      = "15-fail-ifwhile",
      19	    open      = true,
      18	    lexical   = true,
      13	    syntactic = false,
      10	  },
      16	  {
      19	    name      = "16-atrib",
      19	    open      = true,
      19	    lexical   = true,
      18	    syntactic = true,
      12	    semantic  = false,
      11	  },
      16	  {
      19	    name      = "17-call",
      19	    open      = true,
      19	    lexical   = true,
      11	    syntactic = true,
      18	    semantic  = true,
      12	  },
      16	  {
      19	    name      = "18-fail-call",
      19	    open      = true,
      18	    lexical   = true,
      12	    syntactic = false,
      11	  },
      16	  {
      19	    name      = "19-callargs",
      19	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      12	    semantic  = false,
      12	  },
      16	  {
      19	    name      = "19-fail-callargs",
      18	    open      = true,
      18	    lexical   = true,
      19	    syntactic = false,
       5	  },
      16	  {
      19	    name      = "20-return",
      18	    open      = true,
      18	    lexical   = true,
      19	    syntactic = true,
      19	    semantic  = true,
       5	  },
      16	  {
      18	    name      = "21-arrays",
      18	    open      = true,
      19	    lexical   = true,
      19	    syntactic = true,
      13	    semantic  = true,
      11	  },
      16	  {
      17	    name      = "21-return-noargs",
      19	    open      = true,
      19	    lexical   = true,
      13	    syntactic = true,
      19	    semantic  = true,
      11	  },
      14	  {
      19	    name      = "22-exp",
      19	    open      = true,
      13	    lexical   = true,
      19	    syntactic = true,
      18	    semantic  = false,
      10	  },
      16	  {
      18	    name      = "22-fail-exp",
      12	    open      = true,
      18	    lexical   = true,
      17	    syntactic = false,
      10	  },
      15	  {
      18	    name      = "23-fail-fun",
      13	    open      = true,
      19	    lexical   = true,
      75	    syntactic = false,
      67	  },
      15	  {
      76	    name      = "24-fail-fun2",
      69	    open      = true,
      75	    lexical   = true,
      74	    syntactic = false,
      10	  },
      15	  {
      18	    name      = "25-fail-fun3",
      69	    open      = true,
      75	    lexical   = true,
      74	    syntactic = false,
      10	  },
      15	  {
      75	    name      = "26-fail-fun4",
      12	    open      = true,
      18	    lexical   = true,
      74	    syntactic = false,
      11	  },
      15	  {
      74	    name      = "27-fail-global",
      68	    open      = true,
      18	    lexical   = true,
      17	    syntactic = false,
      10	  },
      15	  {
      18	    name      = "28-fail-block",
      69	    open      = true,
      74	    lexical   = true,
      73	    syntactic = false,
      11	  },
      14	  {
      74	    name      = "29-fail-params",
      12	    open      = true,
      18	    lexical   = true,
      73	    syntactic = false,
      11	  },
      14	  {
      18	    name      = "30-fail-param",
      12	    open      = true,
      18	    lexical   = true,
      17	    syntactic = false,
      68	  },
      70	  {
      74	    name      = "31-fail-type",
      11	    open      = true,
      17	    lexical   = true,
      72	    syntactic = false,
      10	  },
      14	  {
      73	    name      = "32-fail-declvar",
      43	    open      = true,
      12	    lexical   = true,
      17	    syntactic = false,
      76	  },
      79	  {
      17	    name      = "33-fail-missingexp",
     140	    open      = true,
     106	    lexical   = true,
     111	    syntactic = false,
      75	  },
      79	  {
      47	    name      = "34-fail-invalidexp",
      17	    open      = true,
      11	    lexical   = true,
     112	    syntactic = false,
      91	  },
      73	  {
      11	    name      = "35-expprio",
      11	    open      = true,
      76	    lexical   = true,
      11	    syntactic = true,
      67	    semantic  = false,
     132	  },
      15	  {
     483	    name      = "36-fail-roottoken",
     419	    open      = true,
      77	    lexical   = true,
     488	    syntactic = false,
     412	  },
     415	  {
     418	    name      = "37-invprio",
     418	    open      = true,
      10	    lexical   = true,
      77	    syntactic = true,
      68	    semantic  = false,
     482	  },
        	
        	  -- ITERATION 4
     135	  {
      73	    name      = "01-fail-fun",
     411	    open      = true,
     138	    lexical   = true,
      74	    syntactic = true,
     488	    semantic  = false,
      86	  },
     580	  {
     500	    name      = "02-fail-argtype",
     405	    open      = true,
     974	    lexical   = true,
     633	    syntactic = true,
     633	    semantic  = false,
     570	  },
     497	  {
      66	    name      = "03-fail-argcount",
     481	    open      = true,
     405	    lexical   = true,
     965	    syntactic = true,
     596	    semantic  = false,
     501	  },
     403	  {
       3	    name      = "04-fail-void",
     569	    open      = true,
     474	    lexical   = true,
      74	    syntactic = true,
     537	    semantic  = false,
      47	  },
       7	  {
       3	    name      = "05-void2",
     600	    open      = true,
     970	    lexical   = true,
     468	    syntactic = true,
     436	    semantic  = true,
      32	  },
      69	  {
     399	    name      = "06-fail-global",
     500	    open      = true,
     562	    lexical   = true,
     890	    syntactic = true,
     224	    semantic  = false,
      68	  },
     555	  {
      60	    name      = "07-globalok",
       3	    open      = true,
     563	    lexical   = true,
     551	    syntactic = true,
     311	    semantic  = true,
     245	  },
        	  {
      71	    name      = "08-global-as-arg",
     243	    open      = true,
     500	    lexical   = true,
     554	    syntactic = true,
     752	    semantic  = true,
     185	  },
       1	  {
     486	    name      = "09-fail-undecl",
       4	    open      = true,
       3	    lexical   = true,
     556	    syntactic = true,
     635	    semantic  = false,
     453	  },
     408	  {
       3	    name      = "10-fail-undecl-fn",
      45	    open      = true,
       3	    lexical   = true,
     908	    syntactic = true,
     346	    semantic  = false,
     348	  },
       1	  {
       4	    name      = "11-fail-redecl-arg",
     303	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
     373	    semantic  = false,
     316	  },
      76	  {
       3	    name      = "12-fail-redecl-arg2",
       9	    open      = true,
       3	    lexical   = true,
      73	    syntactic = true,
     500	    semantic  = false,
     501	  },
     496	  {
     186	    name      = "13-fail-redecl-arg3",
       3	    open      = true,
       3	    lexical   = true,
     500	    syntactic = true,
       3	    semantic  = false,
      19	  },
       1	  {
       3	    name      = "14-fail-redecl-arg4",
       4	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
      17	  },
       7	  {
       3	    name      = "15-assign",
      10	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "16-return-var",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "17-if",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "18-fail-if",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "19-fail-elseif",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "20-fail-while",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "21-while",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "22-exp-int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "23-exp-char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "24-call",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "25-eqvect",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "26-exp-boolidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "27-exp-bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "28-expcall",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "29-exp-intchar2",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "30-exp-intcharidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "31-exp-intchar",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "32-fail-litbool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "33-fail-litnum",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "34-fail-litstring",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "35-fail-new",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "36-fail-rel2",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "37-fail-rel",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "38-new",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "39-rel",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "40-return",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "41-scope-argvsglobal",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "42-scope-localvsglobal",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "43-scope-localvslocal",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "44-fail-global-redec",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "45-fail-fun-redec",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "100-int-int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "101-int-int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "102-int-int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "103-int-int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "104-int-char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "105-int-char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "106-int-char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "107-int-char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "108-fail-int-bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "109-fail-int-bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "110-fail-int-bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "111-fail-int-bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "112-fail-int-string",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "113-fail-int-string-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "114-fail-int-string-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "115-fail-int-string-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "116-fail-int-v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "117-fail-int-v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "118-fail-int-v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "119-fail-int-v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "120-fail-int-v_char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "121-fail-int-v_char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "122-fail-int-v_char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "123-fail-int-v_char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "124-fail-int-v_bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "125-fail-int-v_bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "126-fail-int-v_bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "127-fail-int-v_bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "128-fail-int-v_v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "129-fail-int-v_v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "130-fail-int-v_v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "131-fail-int-v_v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "132-char-int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "133-char-int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "134-char-int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "135-char-int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "136-char-char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "137-char-char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "138-char-char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "139-char-char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "140-fail-char-bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "141-fail-char-bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "142-fail-char-bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "143-fail-char-bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "144-fail-char-string",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "145-fail-char-string-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "146-fail-char-string-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "147-fail-char-string-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "148-fail-char-v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "149-fail-char-v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "150-fail-char-v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "151-fail-char-v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "152-fail-char-v_char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "153-fail-char-v_char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "154-fail-char-v_char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "155-fail-char-v_char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "156-fail-char-v_bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "157-fail-char-v_bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "158-fail-char-v_bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "159-fail-char-v_bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "160-fail-char-v_v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "161-fail-char-v_v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "162-fail-char-v_v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "163-fail-char-v_v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "164-fail-bool-int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "165-fail-bool-int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "166-fail-bool-int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "167-fail-bool-int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "168-fail-bool-char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "169-fail-bool-char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "170-fail-bool-char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "171-fail-bool-char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "172-bool-bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "173-bool-bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "174-bool-bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "175-bool-bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "176-fail-bool-string",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "177-fail-bool-string-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "178-fail-bool-string-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "179-fail-bool-string-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "180-fail-bool-v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "181-fail-bool-v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "182-fail-bool-v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "183-fail-bool-v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "184-fail-bool-v_char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "185-fail-bool-v_char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "186-fail-bool-v_char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "187-fail-bool-v_char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "188-fail-bool-v_bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "189-fail-bool-v_bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "190-fail-bool-v_bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "191-fail-bool-v_bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "192-fail-bool-v_v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "193-fail-bool-v_v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "194-fail-bool-v_v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "195-fail-bool-v_v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "196-fail-string-int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "197-fail-string-int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "198-fail-string-int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "199-fail-string-int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "200-fail-string-char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "201-fail-string-char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "202-fail-string-char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "203-fail-string-char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "204-fail-string-bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "205-fail-string-bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "206-fail-string-bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "207-fail-string-bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "208-string-string",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "209-string-string-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "210-string-string-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "211-string-string-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "212-fail-string-v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "213-fail-string-v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "214-fail-string-v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "215-fail-string-v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "216-string-v_char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "217-string-v_char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "218-string-v_char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "219-string-v_char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "220-fail-string-v_bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "221-fail-string-v_bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "222-fail-string-v_bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "223-fail-string-v_bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "224-fail-string-v_v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "225-fail-string-v_v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "226-fail-string-v_v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "227-fail-string-v_v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "228-fail-v_int-int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "229-fail-v_int-int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "230-fail-v_int-int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "231-fail-v_int-int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "232-fail-v_int-char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "233-fail-v_int-char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "234-fail-v_int-char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "235-fail-v_int-char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "236-fail-v_int-bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "237-fail-v_int-bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "238-fail-v_int-bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "239-fail-v_int-bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "240-fail-v_int-string",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "241-fail-v_int-string-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "242-fail-v_int-string-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "243-fail-v_int-string-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "244-v_int-v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "245-v_int-v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "246-v_int-v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "247-v_int-v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "248-fail-v_int-v_char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "249-fail-v_int-v_char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "250-fail-v_int-v_char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "251-fail-v_int-v_char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "252-fail-v_int-v_bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "253-fail-v_int-v_bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "254-fail-v_int-v_bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "255-fail-v_int-v_bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "256-fail-v_int-v_v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "257-fail-v_int-v_v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "258-fail-v_int-v_v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "259-fail-v_int-v_v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "260-fail-v_char-int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "261-fail-v_char-int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "262-fail-v_char-int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "263-fail-v_char-int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "264-fail-v_char-char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "265-fail-v_char-char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "266-fail-v_char-char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "267-fail-v_char-char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "268-fail-v_char-bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "269-fail-v_char-bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "270-fail-v_char-bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "271-fail-v_char-bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "272-v_char-string",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "273-v_char-string-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "274-v_char-string-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "275-v_char-string-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "276-fail-v_char-v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "277-fail-v_char-v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "278-fail-v_char-v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "279-fail-v_char-v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "280-v_char-v_char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "281-v_char-v_char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "282-v_char-v_char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "283-v_char-v_char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "284-fail-v_char-v_bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "285-fail-v_char-v_bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "286-fail-v_char-v_bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "287-fail-v_char-v_bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "288-fail-v_char-v_v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "289-fail-v_char-v_v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "290-fail-v_char-v_v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "291-fail-v_char-v_v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "292-fail-v_bool-int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "293-fail-v_bool-int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "294-fail-v_bool-int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "295-fail-v_bool-int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "296-fail-v_bool-char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "297-fail-v_bool-char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "298-fail-v_bool-char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "299-fail-v_bool-char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "300-fail-v_bool-bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "301-fail-v_bool-bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "302-fail-v_bool-bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "303-fail-v_bool-bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "304-fail-v_bool-string",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "305-fail-v_bool-string-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "306-fail-v_bool-string-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "307-fail-v_bool-string-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "308-fail-v_bool-v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "309-fail-v_bool-v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "310-fail-v_bool-v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "311-fail-v_bool-v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "312-fail-v_bool-v_char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "313-fail-v_bool-v_char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "314-fail-v_bool-v_char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "315-fail-v_bool-v_char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "316-v_bool-v_bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "317-v_bool-v_bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "318-v_bool-v_bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "319-v_bool-v_bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "320-fail-v_bool-v_v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "321-fail-v_bool-v_v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "322-fail-v_bool-v_v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "323-fail-v_bool-v_v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "324-fail-v_v_int-int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "325-fail-v_v_int-int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "326-fail-v_v_int-int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "327-fail-v_v_int-int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "328-fail-v_v_int-char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "329-fail-v_v_int-char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "330-fail-v_v_int-char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "331-fail-v_v_int-char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "332-fail-v_v_int-bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "333-fail-v_v_int-bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "334-fail-v_v_int-bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "335-fail-v_v_int-bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "336-fail-v_v_int-string",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "337-fail-v_v_int-string-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "338-fail-v_v_int-string-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "339-fail-v_v_int-string-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "340-fail-v_v_int-v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "341-fail-v_v_int-v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "342-fail-v_v_int-v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "343-fail-v_v_int-v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "344-fail-v_v_int-v_char",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "345-fail-v_v_int-v_char-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "346-fail-v_v_int-v_char-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "347-fail-v_v_int-v_char-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "348-fail-v_v_int-v_bool",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "349-fail-v_v_int-v_bool-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "350-fail-v_v_int-v_bool-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "351-fail-v_v_int-v_bool-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = false,
       3	  },
        	  {
       3	    name      = "352-v_v_int-v_v_int",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "353-v_v_int-v_v_int-ret",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "354-v_v_int-v_v_int-retglob",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "355-v_v_int-v_v_int-retidx",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	
        	
        	  -- ITERATION 5  
        	  {
       3	    name      = "icg_expression_and",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "icg_expression_negate",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "icg_expression_new",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "icg_expression_new_byte",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "icg_expression_or",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "icg_expression_unary",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "icg_function_call",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       3	  },
        	  {
       3	    name      = "icg_if",
       3	    open      = true,
       3	    lexical   = true,
       3	    syntactic = true,
       3	    semantic  = true,
       1	  },
       2	  {
       1	    name      = "icg_if_else",
       1	    open      = true,
       1	    lexical   = true,
       1	    syntactic = true,
       1	    semantic  = true,
       1	  },
        	  {
       3	    name      = "icg_if_elseif",
       3	    open      = true,
     763	    lexical   = true,
     761	    syntactic = true,
       1	    semantic  = true,
     763	  },
     760	  {
     761	    name      = "icg_if_elseif_else",
     761	    open      = true,
     761	    lexical   = true,
       1	    syntactic = true,
       1	    semantic  = true,
       1	  },
     760	  {
     761	    name      = "icg_return",
     761	    open      = true,
       1	    lexical   = true,
       1	    syntactic = true,
     761	    semantic  = true,
       1	  },
        	  {
     761	    name      = "icg_return_nil",
       3	    open      = true,
       3	    lexical   = true,
       1	    syntactic = true,
     759	    semantic  = true,
     759	  },
        	  {
       1	    name      = "icg_while",
       1	    open      = true,
       1	    lexical   = true,
       1	    syntactic = true,
     761	    semantic  = true,
     758	  },
     759	}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	local function Run ()
       1	  local num_files = 0
       1	  local num_files_read = 1
     387	  for _, _ in pairs (files) do
     386	    num_files = num_files + 1
        	  end
    1147	  for _, valid in ipairs (files) do
        	    local file_str                  --  keeps the convertion of file to string
    1142	    local unexpected_error = false  --  inform that an unexpected error occurs (if true stop further tests)
     386	    local expected_error = false    --  inform that an expected error occurs (if true stop further tests)
        	    local ok, msg
        	
        	    -- TEST OPENING
        	    ------------------------------------------------
    1142	    if (not unexpected_error and not expected_error) then
     438	      local f = io.open("data/" .. valid.name .. ".txt", "r")
     386	      if (not f and valid.open) then
*******0	        unexpected_error = true
*******0	        print(string.format('(%3s de %3s) FAILURE - File "%s" expected to open.', num_files_read, num_files, valid.name))
     386	      elseif (f and not valid.open) then
*******0	        unexpected_error = true
     760	        print(string.format('(%3s de %3s) FAILURE - File "%s" not expected to open.', num_files_read, num_files, valid.name))
    1090	      elseif (not f and not valid.open) then
     705	        expected_error = true
       1	        msg = "@0 file error: could not be opened."
        	      else
    1089	        file_str = f:read("*a")
     385	        f:close()
        	      end
        	    end
        	    
        	    -- TEST LEXICAL
        	    ------------------------------------------------
     386	    if (not unexpected_error and not expected_error) then
     385	      ok, msg = Lexical.Open(file_str)
     385	      if (not ok and valid.lexical) then
     760	        unexpected_error = true
     174	        print(string.format('(%3s de %3s) FAILURE - File "%s" expected to PASS on lexical. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     559	      elseif (ok and not valid.lexical) then
      62	        unexpected_error = true
*******0	        print(string.format('(%3s de %3s) FAILURE - File "%s" expected to FAIL on lexical. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     385	      elseif (not ok and not valid.lexical) then
       1	        expected_error = true
        	      end
        	    end
        	    
        	    -- TEST SYNTAX
        	    ------------------------------------------------
     386	    if (not unexpected_error and not expected_error) then
     384	      ok, msg = Syntactic.Open(Lexical.GetTags())
     384	      if (not ok and valid.syntactic) then
     760	        unexpected_error = true
*******0	        print(string.format('(%3s de %3s) FAILURE - File "%s" expected to PASS on syntactic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     388	      elseif (ok and not valid.syntactic) then
*******0	        unexpected_error = true
*******0	        print(string.format('(%3s de %3s) FAILURE - File "%s" expected to FAIL on syntactic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     384	      elseif (not ok and not valid.syntactic) then
      26	        expected_error = true
        	      end
        	    end
        	    
        	    -- TEST SEMANTIC
        	    ------------------------------------------------
     388	    if (not unexpected_error and not expected_error) then
     358	      ok, msg = Semantic.Open(Syntactic.GetTree())
     358	      if (not ok and valid.semantic) then
*******0	        unexpected_error = true
*******0	        print(string.format('(%3s de %3s) FAILURE - File "%s" expected to PASS on semantic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     358	      elseif (ok and not valid.semantic) then
*******0	        unexpected_error = true
*******0	        print(string.format('(%3s de %3s) FAILURE - File "%s" expected to FAIL on semantic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     358	      elseif (not ok and not valid.semantic) then
     265	        expected_error = true
        	      end
        	    end
        	
        	    -- TEST INTERMEDIATE CODE GENERATOR
        	    ------------------------------------------------
     386	    local icg_error = false
     386	    if (not unexpected_error and not expected_error) then
      93	      ok, msg = InterCodeGen.Open("out/" .. valid.name, Semantic.GetTree())
      93	      if (not ok) then
*******0	        icg_error = true
*******0	        print(string.format('(%3s de %3s) FAILURE - Unexpected error while writing intermediate code.', num_files_read, num_files))
        	      end
        	    end
        	
        	    -- PASSED ALL TESTS
        	    ------------------------------------------------
     386	    if ((not unexpected_error or expected_error) and not icg_error) then
     386	      print(string.format('(%3s de %3s) SUCCESS - File "%s".', num_files_read, num_files, valid.name))
     386	      if (expected_error and printFailMessage) then
*******0	        print("        ", msg)
        	      end
        	    end
     386	    num_files_read = num_files_read + 1
        	  end
        	end
        	
        	
        	--==============================================================================
        	-- Running
        	--==============================================================================
        	
       2	local ok, msg = pcall(function () Run() end)
       1	if (not ok) then
*******0	  print("Erro inesperado no teste automático. " .. msg)
        	end

==============================================================================
Summary
==============================================================================

34	6	85.00%	./lib/lulex.lua
24	4	85.71%	./lib/node_codes.lua
51	1	98.08%	./lib/token_codes.lua
62	64	49.21%	./lib/util.lua
123	10	92.48%	./lib/util_tree.lua
346	10	97.19%	./src/grammar.lua
419	7	98.36%	./src/intermediate_code.lua
176	1	99.44%	./src/lexical.lua
18	0	100.00%	./src/parser.lua
271	0	100.00%	./src/semantic.lua
54	4	93.10%	./src/symbol_table.lua
18	1	94.74%	./src/syntactic.lua
175	0	100.00%	./src/syntax_tree.lua
2431	15	99.39%	src/auto_test.lua
------------------------
4202	123	97.16%	
