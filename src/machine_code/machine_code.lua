--==============================================================================
-- Debug
--==============================================================================

local printBasicBlocks = false


--==============================================================================
-- Dependency
--==============================================================================

local OperationsCode  = require "operations_code"
local RegAndAddress   = require "machine_code/reg_add_manager"


--==============================================================================
-- Data Structure
--==============================================================================

local Class = {}

--  list of operations code
--  {
--    [name] = $number,
--  }
local operations_code = OperationsCode.GetList()

local indent = "    "


--==============================================================================
-- Private Methods
--==============================================================================

--DumpFunction:
--  Parameters:
--    [1] $       - Desired output
--    [2] 
--    [3] $table
--  Return:
function Class.DumpFunction (output, name, instructions)
  if (_DEBUG) then print("MCG :: DumpFunction") end
  output:write(string.format("  %s:\n", name))
  for _, instruction in ipairs(instructions) do
    output:write(string.format("%s%s\n", indent, instruction))
  end
end

--DumpGlobal:
--  Parameters:
--    [1] $       - Desired output
--    [2] $string - Variable name
--  Return:
function Class.DumpGlobal (output, list_funcs, list_globals)
  if (_DEBUG) then print("MCG :: DumpGlobal") end
  assert(type(list_funcs) == "table")
  assert(type(list_globals) == "table")
  local t = {}
  if (not util.TableIsEmpty(list_funcs)) then
    for _, func in ipairs(list_funcs) do
      table.insert(t, func.name)
    end
  end
  if (not util.TableIsEmpty(list_globals)) then
    for _, glob in ipairs(list_globals) do
      table.insert(t, glob)
    end
  end
  local str = t[1]
  if (#t > 1) then
    for i = 2, #t do
      str = str .. ", " .. t[i]
    end
  end
  output:write(string.format('  .globl %s\n', str))
end

--DumpString:
--  Parameters:
--    [1] $       - Desired output
--    [2] $string - Variable name
--    [3] $string - Literal string
--  Return:
function Class.DumpString (output, var, str)
  if (_DEBUG) then print("MCG :: DumpString") end
  assert(var)
  assert(str)
  output:write(string.format('%s%s: .string "%s"\n', indent, var, str))
end

--Error: Stop class execution and generate error message
--  Parameters:
--    [1] $string - 
--  Return:
function Class.Error (msg)
  if (_DEBUG) then print("MCG :: Error") end
  local str = string.format("machine code generator error: %s", msg or "")
  error(str, 0)
end

--GenBasicBlock: Receives a list of instructions and split it into basic blocks
--  Parameters:
--    [1] $table  - list of function instructions generated by intermediate code
--  Return:
--    [1] $table = {
--          [1 to N] = {    - list of basic blocks
--        }
function Class.GenBasicBlock (func)
  if (_DEBUG) then print("MCG :: GenBasicBlock") end
  local t = {}
  local enum_block = 0
  local next_is_block = false
  for enum_inst, inst in ipairs(func) do
    if (next_is_block) then
      next_is_block = false
      enum_block = enum_block + 1
      t[enum_block] = {}
      table.insert(t[enum_block], inst)
    elseif (enum_inst == 1) then
      enum_block = enum_block + 1
      t[enum_block] = {}
      table.insert(t[enum_block], inst)
    elseif (inst.code == operations_code["LABEL"]) then
      enum_block = enum_block + 1
      t[enum_block] = {}
      table.insert(t[enum_block], inst)
    elseif (inst.code == operations_code["GOTO"] or inst.code == operations_code["IFFALSEGOTO"] or inst.code == operations_code["IFGOTO"]) then
      next_is_block = true
      table.insert(t[enum_block], inst)
    else
      table.insert(t[enum_block], inst)
    end
  end
  if (printBasicBlocks) then
    util.TablePrint(t)
  end
  return t
end

--GenMachineBlock:
--  Parameters:
--    [1] $table  - Table generated by 'GenBasicBlock' function
--  Return:
function Class.GenMachineBlock (basic_blocks)
  if (_DEBUG) then print("MCG :: GenMachineBlock") end
  assert(type(basic_blocks) == "table")
  local t = {}
  for _, block in ipairs(basic_blocks) do
    RegAndAddress.New(block)



    
    for num, instruction in ipairs(block) do
      local op, reg1, reg2, reg3 = RegAndAddress.GetRegisters(num, instruction)
      if (op) then
        for _, inst in ipairs(op) do
          table.insert(t, inst)
        end
      end
      Class.GenMachineInstruction(t, instruction.code, reg1, reg2, reg3)
    end
  end
  return t
end

--GenMachineInstruction:
--  Parameters:
--  Return:
--    [1] $string   - Assembly instruction;
function Class.GenMachineInstruction (t, code, op1, op2, op3)
  if (_DEBUG) then print("MCG :: GenMachineInstruction") end
  if (code == operations_code["CALLID"]) then
    table.insert(t, string.format("  call   %s", op1))
  elseif (code == operations_code["GOTO"]) then
    table.insert(t, string.format("  jmp    %s", op1))
  elseif (code == operations_code["IFFALSEGOTO"]) then
    
  elseif (code == operations_code["IFGOTO"]) then
    table.insert(t, string.format("  jnz    %s", op1))
  elseif (code == operations_code["LABEL"]) then
    table.insert(t, string.format("%s", op1))
  elseif (code == operations_code["PARAM"]) then
    
  elseif (code == operations_code["RET_OP"]) then
    table.insert(t, string.format("  ret    %s", op1))
  elseif (code == operations_code["RET_NIL"]) then
    table.insert(t, string.format("  ret"))
  elseif (code == operations_code["ID=rval"]) then
    table.insert(t, string.format("  movl   %s, %s", op1, op2))
  elseif (code == operations_code["ID=BYTErval"]) then
    table.insert(t, string.format("  movb   %s, %s", op1, op2))
  elseif (code == operations_code["ID=ID[rval]"]) then
    
  elseif (code == operations_code["ID=BYTEID[rval]"]) then

  elseif (code == operations_code["ID=-rval"]) then
    table.insert(t, string.format("  movl   %s, %s", op1, op2))
    table.insert(t, string.format("  negl   %s", op1))
  elseif (code == operations_code["ID=NEWrval"]) then
    
  elseif (code == operations_code["ID=NEWBYTErval"]) then
    
  elseif (code == operations_code["ID=rvalEQrval"]) then
    
  elseif (code == operations_code["ID=rvalNErval"]) then
    
  elseif (code == operations_code["ID=rvalGErval"]) then
    
  elseif (code == operations_code["ID=rvalLErval"]) then
    
  elseif (code == operations_code["ID=rval<rval"]) then
    
  elseif (code == operations_code["ID=rval>rval"]) then
    
  elseif (code == operations_code["ID=rval+rval"]) then
    
  elseif (code == operations_code["ID=rval-rval"]) then
    
  elseif (code == operations_code["ID=rval*rval"]) then
    
  elseif (code == operations_code["ID=rval/rval"]) then
    
  elseif (code == operations_code["ID[rval]=rval"]) then
    
  elseif (code == operations_code["ID[rval]=BYTErval"]) then
    
  end
end

--==============================================================================
-- Public Methods
--==============================================================================

--Open: Write a 'path'.o file with machine code.
--  Parameters:
--    [1] $string   - Path of exit file. Extension will be converted to '.o'
--    [2] $table    - Struct of program builded by intermediate code.
--  Return:
--    [1] $boolean  - false if found any problem, true otherwise
--    [2] $string   - only when [1] is false, informing which error occurs
function Class.Open (path, intermediate_code)
  if (_DEBUG) then print("MCG :: Open") end
  assert(path)
  assert(type(intermediate_code) == "table")
  local ok, msg = pcall(function ()
    local f = io.open(util.FileRemoveExtension(path) .. ".s", "w")
    if (not f) then
      Class.Error(string.format("output file '%s' could not be opened"), path)
    end
    f:write(string.format('.data\n'))
    for _, string in ipairs(intermediate_code.strings) do
      Class.DumpString(f, string.var, string.str)
    end
    f:write(string.format('.text\n'))
    Class.DumpGlobal(f, intermediate_code.functions, intermediate_code.globals)
    for _, func in ipairs(intermediate_code.functions) do
      local basic_blocks = Class.GenBasicBlock(func)
      local machine_block = Class.GenMachineBlock(basic_blocks)
      Class.DumpFunction(f, func.name, machine_block)
    end
  end)
  if (not ok) then
    return false, msg
  end
  return true
end


--==============================================================================
-- Return
--==============================================================================

return Class

-- ASSEMBLER
--
--  .data
--      s1:  .string ""
--  .text
--  
--  .globl main, etc, etc2
--
--  main:
--  
--  
--  jz  .Label   jump if zero
--  jmp .Label   jump
--  jnz .Label   jump if not zero
