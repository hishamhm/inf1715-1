--==============================================================================
-- Bugs and Improvement
--==============================================================================

-- BUG: We are using 6 registers. Only EAX, EBX, ECX and EDX can have its lowest
--      byte accessed. When we dump instruction ["ID[rval]=BYTErval"] we need to
--      access its lowest byte. If third operator is inside ESI or EDI, it wont
--      complete its instructions

-- BUG: After calling a instruction, the number of parameters pushed into %ebp
--      must be discharged. "ADDL $(4 * number of parameters), %esi" must be
--      inserted to assembler.

-- IMP: Intermediate code insert a 'ret' instruction at the end of every function.
--      We could dischard this intruction if function already has a 'return'.


--==============================================================================
-- Debug
--==============================================================================

local _DEBUG            = false
local _DETAIL           = true
local printBasicBlocks  = false
local printRegVarTable  = false


--==============================================================================
-- Dependency
--==============================================================================

local OperationsCode  = require "operations_code"


--==============================================================================
-- Data Structure
--==============================================================================

local Class = {}

local indent = "    "

--  table with list of function assembler code
--  {
--    [1 to N] =  {                 --  enum of functions.
--      name     = "name"           --  function name.
--      [1 to N] = "instruction"    --  enum of instructions.
--    }
--  }
local fun_assembler = {}

--  count the number of labels present in code
local label_count = 0

--  table with list of globals viewable by assembler
--  {
--    [1 to N] = "global"   --  enum of labels, global variables, functions.
--  }
local list_globals = {}

--  list of operations code
--  {
--    [name] = $number,
--  }
local operations_code = OperationsCode.GetList()

--  list of registers
--  {
--    [1 to N] = $string  - register name
--  }
local registers = {
  "%eax",
  "%ebx",
  "%ecx",
  "%edx",
  "%edi",
  "%esi",
}

--  table with registers and variables allocation
--  {
--    regs = {
--      [1 to N] = {          -- list of registers
--        [1 to N] = "name"   -- variables with values inside this registers
--      }
--    }
--    vars = {
--      "name" = {
--        [1 to N] = "name"   -- places where this variable is kept
--      }
--    }
--  }
local reg_var = {}

--  table with variables inside stack
--  {
--    "name" = "position"
--  }
local stack = {}

--  table with list of instruction number where they appear
--  {
--    [1 to N] = {          --  enum of instructions. 'N' will have one line more
--                              than number of instructions in basic block, where
--                              the last line has all variables 'alive'.
--      "name" = {
--        alive     = $boolean
--        next_inst = $number
--      }
--    }
--  }
local var_use = {}


--==============================================================================
-- Private Methods
--==============================================================================

--BlockGenerateBasicBlocks: Split a list of instructions into basic blocks
--  Parameters:
--    [1] $table  - List of function instructions generated by 'intermediate_code'
--  Return:
--    [1] $table  = {
--          [1 to N] = {          -- enum of basic blocks
--            [1 to N] = $table   -- node generated by 'intermediate_code' 
--          }
--        }
function Class.BlockGenerateBasicBlocks (func)
  if (_DEBUG) then print("MCG :: BlockGenerateBasicBlocks") end
  assert(type(func) == "table")
  local t = {}
  local enum_block = 0
  local next_is_block = false
  for enum_inst, inst in ipairs(func) do
    if (next_is_block) then
      next_is_block = false
      enum_block = enum_block + 1
      t[enum_block] = {}
      table.insert(t[enum_block], inst)
    elseif (enum_inst == 1) then
      enum_block = enum_block + 1
      t[enum_block] = {}
      table.insert(t[enum_block], inst)
    elseif (inst.code == operations_code["LABEL"]) then
      enum_block = enum_block + 1
      t[enum_block] = {}
      table.insert(t[enum_block], inst)
    elseif (inst.code == operations_code["GOTO"] or inst.code == operations_code["IFFALSEGOTO"] or inst.code == operations_code["IFGOTO"]) then
      next_is_block = true
      table.insert(t[enum_block], inst)
    else
      table.insert(t[enum_block], inst)
    end
  end
  if (printBasicBlocks) then
    util.TablePrint(t)
  end
  return t
end

--BlockBuildRegistersVariables: Initialize 'reg_var' with desired values. In
--    'reg_var', 'regs' are started empty and 'vars' with their own position
--    only.
--  Parameters:
--    [1] $table  - Table containing one basic block
--  Return:
function Class.BlockBuildRegistersVariables (basic_block)
  if (_DEBUG) then print("MCG :: BlockBuildRegistersVariables") end
  reg_var = {
    regs = {},
    vars = {},
  }
  for num, _ in ipairs(registers) do
    reg_var.regs[num] = {}
  end
  for num, block in ipairs(basic_block) do
    if (Class.GetOperatorIsVar(block.op1)) then
      reg_var.vars[block.op1] = reg_var.vars[block.op1] or {block.op1}
    end
    if (Class.GetOperatorIsVar(block.op2)) then
      reg_var.vars[block.op2] = reg_var.vars[block.op2] or {block.op2}
    end
    if (Class.GetOperatorIsVar(block.op3)) then
      reg_var.vars[block.op3] = reg_var.vars[block.op3] or {block.op3}
    end
  end
end

--BlockBuildVariablesNextUse: Initialize 'var_use' with desired values. In
--    'var_use', all instructions number wher variable appear will be placed
--    inside list.
--  Parameters:
--    [1] $table  - Table containing one basic block
--  Return:
function Class.BlockBuildVariablesNextUse (basic_block)
  if (_DEBUG) then print("MCG :: BlockBuildVariablesNextUse") end
  var_use = {}
  var_use[#basic_block + 1] = {}
  for var_name, _ in pairs(reg_var.vars) do
    var_use[#basic_block + 1][var_name] = {
      alive     = true,
      next_inst = #basic_block + 1,
    }
  end
  for i = #basic_block, 1, -1 do
    var_use[i] = util.TableCopy(var_use[i + 1])
    local group = Class.GetOperationGroup(basic_block[i].code)
    if (group == "0in0out") then
      -- nothing to do
    elseif (group == "1in0out") then
      if (Class.GetOperatorIsVar(basic_block[i].op1)) then
        var_use[i][basic_block[i].op1].alive = true
        var_use[i][basic_block[i].op1].next_inst = i
      end
    elseif (group == "1in1out") then
      if (Class.GetOperatorIsVar(basic_block[i].op1)) then
        var_use[i][basic_block[i].op1].alive = false
        var_use[i][basic_block[i].op1].next_inst = i
      end
      if (Class.GetOperatorIsVar(basic_block[i].op2)) then
        var_use[i][basic_block[i].op2].alive = true
        var_use[i][basic_block[i].op2].next_inst = i
      end
    elseif (group == "2in1out") then
      if (Class.GetOperatorIsVar(basic_block[i].op1)) then
        var_use[i][basic_block[i].op1].alive = false
        var_use[i][basic_block[i].op1].next_inst = i
      end
      if (Class.GetOperatorIsVar(basic_block[i].op2)) then
        var_use[i][basic_block[i].op2].alive = true
        var_use[i][basic_block[i].op2].next_inst = i
      end
      if (Class.GetOperatorIsVar(basic_block[i].op3)) then
        var_use[i][basic_block[i].op3].alive = true
        var_use[i][basic_block[i].op3].next_inst = i
      end
    elseif (group == "3in0out") then
      if (Class.GetOperatorIsVar(basic_block[i].op1)) then
        var_use[i][basic_block[i].op1].alive = true
        var_use[i][basic_block[i].op1].next_inst = i
      end
      if (Class.GetOperatorIsVar(basic_block[i].op2)) then
        var_use[i][basic_block[i].op2].alive = true
        var_use[i][basic_block[i].op2].next_inst = i
      end
      if (Class.GetOperatorIsVar(basic_block[i].op3)) then
        var_use[i][basic_block[i].op3].alive = true
        var_use[i][basic_block[i].op3].next_inst = i
      end
    end
  end
end

--Clear: Clear all persistance data. Return to class initial state
--  Parameters:
--  Return:
function Class.Clear ()
  if (_DEBUG) then print("MCG :: Clear") end
  fun_assembler = {}
  label_count   = 0
  list_globals  = {}
  reg_var       = {}
  stack         = {}
  var_use       = {}
end

--DumpFunction: Write functions instructions in output
--  Parameters:
--    [1] $       - Desired output
--  Return:
function Class.DumpFunctions (output)
  if (_DEBUG) then print("MCG :: DumpFunction") end
  for func_num, func in ipairs(fun_assembler) do
    output:write(string.format("  %s:\n", func.name))
    for _, instruction in ipairs(fun_assembler[func_num]) do
      output:write(string.format("%s%s\n", indent, instruction))
    end
  end
end

--DumpGlobals: Write '.globl' enum
--  Parameters:
--    [1] $       - Desired output
--  Return:
function Class.DumpGlobals (output)
  if (_DEBUG) then print("MCG :: DumpGlobals") end
  local str = ".globl"
  for i = 1, #list_globals do
    str = str .. " " .. list_globals[i]
    if (i < #list_globals) then
      str = str .. ","
    end
  end
  output:write(string.format('  %s\n', str))
end

--DumpGlobal: Write globals in output
--  Parameters:
--    [1] $       - Desired output
--    [2] $table  - Functions list generated by 'intermediate_code'
--    [3] $table  - Globals list generated by 'intermediate_code'
--  Return:
function Class.DumpGlobalVariable (output, global)
  if (_DEBUG) then print("MCG :: DumpGlobal") end
  assert(global)
  output:write(string.format('%s%s: .int\n', indent, global))
end

--DumpString: Write string in output
--  Parameters:
--    [1] $       - Desired output
--    [2] $string - Variable name
--    [3] $string - Literal string
--  Return:
function Class.DumpString (output, var, str)
  if (_DEBUG) then print("MCG :: DumpString") end
  assert(var)
  assert(str)
  output:write(string.format('%s%s: .string "%s"\n', indent, var, str))
end

--Error: Stop class execution and generate error message
--  Parameters:
--    [1] $string - 
--  Return:
function Class.Error (msg)
  if (_DEBUG) then print("MCG :: Error") end
  local str = string.format("machine code generator error: %s", msg or "")
  error(str, 0)
end

--FunAddAssemblerInst: Insert instruction inside function table 'fun_assembler'
--  Parameters:
--    [1] $number - Function number
--    [2] $string - Assembler instruction
--  Return:
function Class.FunAddAssemblerInst (func_num, inst)
  if (_DEBUG) then print("MCG :: FunAddAssemblerInst") end
  assert(type(func_num) == "number")
  assert(type(inst) == "string")
  table.insert(fun_assembler[func_num], inst)
end

--FunBuildStack: Create parameters and variables table for position in memory
--  Parameters:
--  Return:
--    [1] $number - Number of variables inside function.
function Class.FunBuildStack (func)
  if (_DEBUG) then print("MCG :: FunBuildStack") end
  stack = {}
  -- parameters
  local _, _, params = string.find(func.header, "%(([^%)]+)%)")
  if (params) then
    params = string.gsub(params, ",", " ")
    local count = 0
    for param in string.gmatch(params, "%w+") do
      count = count + 1
      stack[param] = (count * 4) .. "(%ebp)"
    end
  end
  -- variables
  local count = 1
  for _, func in ipairs(func) do
    if (func.op1 and Class.GetOperatorIsVar(func.op1) and not stack[func.op1]) then
      count = count + 1
      stack[func.op1] = "-" .. (count * 4) .. "(%ebp)"
    end
    if (func.op2 and Class.GetOperatorIsVar(func.op2) and not stack[func.op2]) then
      count = count + 1
      stack[func.op1] = "-" .. (count * 4) .. "(%ebp)"
    end
    if (func.op3 and Class.GetOperatorIsVar(func.op3) and not stack[func.op3]) then
      count = count + 1
      stack[func.op1] = "-" .. (count * 4) .. "(%ebp)"
    end
  end
  return count - 1
end

--FunGenMachineCode:
--  Parameters:
--    [1] $number - Enumeration of function
--    [2] $table  - Table generated by 'BlockGenerateBasicBlocks' function
--  Return:
function Class.FunGenMachineCode (func_num, func)
  if (_DEBUG) then print("MCG :: FunGenMachineCode") end
  assert(type(func) == "table")
  fun_assembler[func_num] = {
    name = func.name,
  }
  Class.GlobalAdd(func.name)
  Class.FunAddAssemblerInst(func_num, string.format("  pushl  %%ebp"))
  Class.FunAddAssemblerInst(func_num, string.format("  movl   %%esp, %%ebp"))
  Class.FunAddAssemblerInst(func_num, string.format("  pushl  %%ebx"))
  Class.FunAddAssemblerInst(func_num, string.format("  pushl  %%esi"))
  Class.FunAddAssemblerInst(func_num, string.format("  pushl  %%edi"))
  local var_count = Class.FunBuildStack(func)
  Class.FunAddAssemblerInst(func_num, string.format("  subl   $%d, %%esp", var_count * 4))
  local basic_blocks = Class.BlockGenerateBasicBlocks(func)
  for _, block in ipairs(basic_blocks) do
    Class.BlockBuildRegistersVariables(block)
    Class.BlockBuildVariablesNextUse(block)
    for num, inst in ipairs(block) do
      reg1, reg2, reg3 = Class.GetReg(func_num, num, inst)
      reg1 = (registers[reg1]) or (tonumber(inst.op1) and "$" .. inst.op1) or inst.op1
      reg2 = (registers[reg2]) or (tonumber(inst.op2) and "$" .. inst.op2) or inst.op2
      reg3 = (registers[reg3]) or (tonumber(inst.op3) and "$" .. inst.op3) or inst.op3
      if (printRegVarTable) then
        print("----------------------------")
        print(string.format("INS %d: 1: %s 2: %s 3: %s", num, reg1 or "", reg2 or "", reg3 or ""))
        Class.PrintTableRegistersVariables()
      end
      Class.FunGenMachineInst(func_num, inst.code, inst.label, reg1, reg2, reg3)
    end
  end
end

--FunGenMachineInst:
--  Parameters:
--  Return:
--    [1] $string   - Assembly instruction;
function Class.FunGenMachineInst (func_num, code, label, op1, op2, op3)
  if (_DEBUG) then print("MCG :: FunGenMachineInst") end
  if (code == operations_code["CALLID"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    -- registrador EAX é feito spill para fazer o call da chamada,
    -- enquanto o ECX e EDX sao empilhados e depois do call desempilhados
    local eax_num = Class.RegGetNum("%eax")
    for _, var in ipairs(reg_var.regs[eax_num]) do
      Class.VarClear(var)
      Class.VarSaveMem(func_num, var, eax_num)
    end
    Class.FunAddAssemblerInst(func_num, string.format("  pushl  %%ecx"))
    Class.FunAddAssemblerInst(func_num, string.format("  pushl  %%edx"))
    Class.FunAddAssemblerInst(func_num, string.format("  call   %s", op1))
    -- RETORNO EM EAX
    Class.FunAddAssemblerInst(func_num, string.format("  pushl  %%edx"))
    Class.FunAddAssemblerInst(func_num, string.format("  pushl  %%ecx"))
    local _, _, num_params = string.find(op2, "(%d+)")
    Class.FunAddAssemblerInst(func_num, string.format("  addl   $%s, %%esp", num_params * 4))
    -- DESEMPILHA PARAMETROS
  elseif (code == operations_code["GOTO"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("  jmp    %s", op1))
  elseif (code == operations_code["IFFALSEGOTO"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("  cmpl   %s, $0", op1))
    Class.FunAddAssemblerInst(func_num, string.format("  je     %s", op2))
  elseif (code == operations_code["IFGOTO"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("  cmpl   %s, $1", op1))
    Class.FunAddAssemblerInst(func_num, string.format("  je     %s", op2))
  elseif (code == operations_code["LABEL"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("%s:", label))
  elseif (code == operations_code["PARAM"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("  pushl  %s", op1))
  elseif (code == operations_code["RET_OP"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    if (op1 ~= "%eax") then
      Class.FunAddAssemblerInst(func_num, string.format("  movl   %s, %%eax", op1))
    end
    Class.FunAddAssemblerInst(func_num, string.format("  popl   %%edi"))
    Class.FunAddAssemblerInst(func_num, string.format("  popl   %%esi"))
    Class.FunAddAssemblerInst(func_num, string.format("  popl   %%ebx"))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   %%ebp, %%esp"))
    Class.FunAddAssemblerInst(func_num, string.format("  popl   %%ebp"))
    Class.FunAddAssemblerInst(func_num, string.format("  ret"))
  elseif (code == operations_code["RET_NIL"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("  popl   %%edi"))
    Class.FunAddAssemblerInst(func_num, string.format("  popl   %%esi"))
    Class.FunAddAssemblerInst(func_num, string.format("  popl   %%ebx"))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   %%ebp, %%esp"))
    Class.FunAddAssemblerInst(func_num, string.format("  popl   %%ebp"))
    Class.FunAddAssemblerInst(func_num, string.format("  ret"))
  elseif (code == operations_code["ID=rval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("  movl   %s, %s", op2, op1))
  elseif (code == operations_code["ID=BYTErval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("  movsbl %s, %s", op2, op1))
  elseif (code == operations_code["ID=ID[rval]"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("  movl   %s, %%esi", op3))
    Class.FunAddAssemblerInst(func_num, string.format("  imul   $4, %%esi"))
    Class.FunAddAssemblerInst(func_num, string.format("  addl   %s, %%esi", op2))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   (%%esi), %s", op1))
  elseif (code == operations_code["ID=BYTEID[rval]"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("  movl   %s, %%esi", op3))
    Class.FunAddAssemblerInst(func_num, string.format("  addl   %s, %%esi", op2))
    Class.FunAddAssemblerInst(func_num, string.format("  movsbl %s, (%%esi)", op1))
  elseif (code == operations_code["ID=-rval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("  movl   %s, %s", op2, op1))
    Class.FunAddAssemblerInst(func_num, string.format("  negl   %s", op1))
  elseif (code == operations_code["ID=NEWrval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    -- call malloc (parametro é tamanho * 4)
  elseif (code == operations_code["ID=NEWBYTErval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    -- push parametro
    -- call malloc (parametro é tamanho)
    -- retorno no eax
  elseif (code == operations_code["ID=rvalEQrval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    local lbl_true  = Class.LabelGetNew()
    local lbl_end   = Class.LabelGetNew()
    Class.FunAddAssemblerInst(func_num, string.format("  cmpl   %s, %s", op2, op3))
    Class.FunAddAssemblerInst(func_num, string.format("  je     %s", lbl_true))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   $0, %s", op1))
    Class.FunAddAssemblerInst(func_num, string.format("  jmp    %s", lbl_end))
    Class.FunAddAssemblerInst(func_num, string.format("%s:", lbl_true))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   $1, %s", op1))
    Class.FunAddAssemblerInst(func_num, string.format("%s:", lbl_end))
  elseif (code == operations_code["ID=rvalNErval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    local lbl_true  = Class.LabelGetNew()
    local lbl_end   = Class.LabelGetNew()
    Class.FunAddAssemblerInst(func_num, string.format("  cmpl   %s, %s", op2, op3))
    Class.FunAddAssemblerInst(func_num, string.format("  jne    %s", lbl_true))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   $0, %s", op1))
    Class.FunAddAssemblerInst(func_num, string.format("  jmp    %s", lbl_end))
    Class.FunAddAssemblerInst(func_num, string.format("%s:", lbl_true))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   $1, %s", op1))
    Class.FunAddAssemblerInst(func_num, string.format("%s:", lbl_end))
  elseif (code == operations_code["ID=rvalGErval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    local lbl_true  = Class.LabelGetNew()
    local lbl_end   = Class.LabelGetNew()
    Class.FunAddAssemblerInst(func_num, string.format("  cmpl   %s, %s", op2, op3))
    Class.FunAddAssemblerInst(func_num, string.format("  jge    %s", lbl_true))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   $0, %s", op1))
    Class.FunAddAssemblerInst(func_num, string.format("  jmp    %s", lbl_end))
    Class.FunAddAssemblerInst(func_num, string.format("%s:", lbl_true))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   $1, %s", op1))
    Class.FunAddAssemblerInst(func_num, string.format("%s:", lbl_end))
  elseif (code == operations_code["ID=rvalLErval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    local lbl_true  = Class.LabelGetNew()
    local lbl_end   = Class.LabelGetNew()
    Class.FunAddAssemblerInst(func_num, string.format("  cmpl   %s, %s", op2, op3))
    Class.FunAddAssemblerInst(func_num, string.format("  jle    %s", lbl_true))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   $0, %s", op1))
    Class.FunAddAssemblerInst(func_num, string.format("  jmp    %s", lbl_end))
    Class.FunAddAssemblerInst(func_num, string.format("%s:", lbl_true))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   $1, %s", op1))
    Class.FunAddAssemblerInst(func_num, string.format("%s:", lbl_end))
  elseif (code == operations_code["ID=rval<rval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    local lbl_true  = Class.LabelGetNew()
    local lbl_end   = Class.LabelGetNew()
    Class.FunAddAssemblerInst(func_num, string.format("  cmpl   %s, %s", op2, op3))
    Class.FunAddAssemblerInst(func_num, string.format("  jl     %s", lbl_true))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   $0, %s", op1))
    Class.FunAddAssemblerInst(func_num, string.format("  jmp    %s", lbl_end))
    Class.FunAddAssemblerInst(func_num, string.format("%s:", lbl_true))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   $1, %s", op1))
    Class.FunAddAssemblerInst(func_num, string.format("%s:", lbl_end))
  elseif (code == operations_code["ID=rval>rval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    local lbl_true  = Class.LabelGetNew()
    local lbl_end   = Class.LabelGetNew()
    Class.FunAddAssemblerInst(func_num, string.format("  cmpl   %s, %s", op2, op3))
    Class.FunAddAssemblerInst(func_num, string.format("  jg     %s", lbl_true))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   $0, %s", op1))
    Class.FunAddAssemblerInst(func_num, string.format("  jmp    %s", lbl_end))
    Class.FunAddAssemblerInst(func_num, string.format("%s:", lbl_true))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   $1, %s", op1))
    Class.FunAddAssemblerInst(func_num, string.format("%s:", lbl_end))
  elseif (code == operations_code["ID=rval+rval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("  movl   %s, %s", op2, op1))
    Class.FunAddAssemblerInst(func_num, string.format("  addl   %s, %s", op3, op1))
  elseif (code == operations_code["ID=rval-rval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("  movl   %s, %s", op2, op1))
    Class.FunAddAssemblerInst(func_num, string.format("  subl   %s, %s", op3, op1))
  elseif (code == operations_code["ID=rval*rval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("  movl   %s, %s", op2, op1))
    Class.FunAddAssemblerInst(func_num, string.format("  imul   %s, %s", op3, op1))
  elseif (code == operations_code["ID=rval/rval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    -- cltd
    -- idiv
  elseif (code == operations_code["ID[rval]=rval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("  movl   %s, %%esi", op2))
    Class.FunAddAssemblerInst(func_num, string.format("  imul   $4, %%esi"))
    Class.FunAddAssemblerInst(func_num, string.format("  addl   %s, %%esi", op1))
    Class.FunAddAssemblerInst(func_num, string.format("  movl   %s, (%%esi)", op3))
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
  elseif (code == operations_code["ID[rval]=BYTErval"]) then
    if (_DETAIL) then Class.FunAddAssemblerInst(func_num, string.format("/*-------*/")) end
    Class.FunAddAssemblerInst(func_num, string.format("  movl   %s, %%esi", op2))
    Class.FunAddAssemblerInst(func_num, string.format("  addl   %s, %%esi", op1))
    -- WARNING: REGISTER USED IN LAST RVAL VALUE MUST BE ONE OF: EAX, EBX, ECX or EDX
    if (Class.RegGetNum(op3)) then
      local _, _, reg_low = string.find(op3, "([abcd])")
      if (reg_low) then
        reg_low = "%" .. reg_low .. "l"
        Class.FunAddAssemblerInst(func_num, string.format("  movb   %s, (%%esi)", reg_low))
      else
        print(string.format("Operator '%s' cannot be accessed by his lowest value"))
        Class.Error("Register cannot have its lowest byte accessed")
      end
    else
      print("operator is num: ", op3)
      print(string.format("  movb   %s, (%%esi)", op3))
      Class.FunAddAssemblerInst(func_num, string.format("  movb   %s, (%%esi)", op3))
    end
  end
end

--GetOperationGroup: Get a operation node received from intermediate_code and
--    return the group where it belong
--  Parameters:
--    [1] $number - Operation code;
--  Return:
--    [1] $string - Group code [0in0out, 1in0out, 1in1out, 2in1out, 3in0out];
function Class.GetOperationGroup (code)
  if (_DEBUG) then print("MCG :: GetOperationGroup") end
  assert(code and type(code) == "number")
  local group = {
    ["CALLID"]            = "0in0out",
    ["GOTO"]              = "0in0out",
    ["LABEL"]             = "0in0out",
    ["RET_NIL"]           = "0in0out",
    ["IFFALSEGOTO"]       = "1in0out",
    ["IFGOTO"]            = "1in0out",
    ["PARAM"]             = "1in0out",
    ["RET_OP"]            = "1in0out",
    ["ID=rval"]           = "1in1out",
    ["ID=BYTErval"]       = "1in1out",
    ["ID=-rval"]          = "1in1out",
    ["ID=NEWrval"]        = "1in1out",
    ["ID=NEWBYTErval"]    = "1in1out",
    ["ID=ID[rval]"]       = "2in1out",
    ["ID=BYTEID[rval]"]   = "2in1out",
    ["ID=rvalEQrval"]     = "2in1out",
    ["ID=rvalNErval"]     = "2in1out",
    ["ID=rvalGErval"]     = "2in1out",
    ["ID=rvalLErval"]     = "2in1out",
    ["ID=rval<rval"]      = "2in1out",
    ["ID=rval>rval"]      = "2in1out",
    ["ID=rval+rval"]      = "2in1out",
    ["ID=rval-rval"]      = "2in1out",
    ["ID=rval*rval"]      = "2in1out",
    ["ID=rval/rval"]      = "2in1out",
    ["ID[rval]=rval"]     = "3in0out",
    ["ID[rval]=BYTErval"] = "3in0out",
  }
  local name = OperationsCode.GetName(code)
  return group[name]
end

--GetOperatorIsVar: Verify if a operator defined in intermediate code is a
--    variable. If the operator is not a variable, it is $nil, a $number
--    (LIT_NUM), or a label, that starts with '.'
--  Parameters:
--    [1] $string   - Operator defined in intermediate code
--  Return:
--    [1] $boolean  - TRUE if operator is a variable, FALSE otherwise
function Class.GetOperatorIsVar (op)
  if (_DEBUG) then print("MCG :: GetOperatorIsVar") end
  if (op and not tonumber(op) and not string.find(op, "^%.")) then
    return true
  end
  return false
end

--GetReg: Receive a instruction node created by intermediate code
--    and return registers that should be used for operation
--  Parameters:
--    [1] $number - Function number
--    [2] $number - Number of current instruction
--    [3] $table  - Table containing a instruction
--  Return:
--    [1] $string or $nil - Register for first operator
--    [2] $string or $nil - Register for second operator
--    [3] $string or $nil - Register for third operator
function Class.GetReg (func_num, inst_num, inst)
  if (_DEBUG) then print("MCG :: GetReg") end
  assert(type(func_num) == "number")
  assert(type(inst_num) == "number")
  local operations = {}
  local reg1, reg2, reg3
  local group = Class.GetOperationGroup(inst.code)
  if (group == "0in0out") then
  elseif (group == "1in0out") then
    reg1 = Class.GetRegRead(func_num, inst_num, inst.op1)
  elseif (group == "1in1out") then
    reg2 = Class.GetRegRead(func_num, inst_num, inst.op2)
    reg1 = Class.GetRegWrite(func_num, inst_num, inst.op1, inst.op2, reg2)
  elseif (group == "2in1out") then
    reg2 = Class.GetRegRead(func_num, inst_num, inst.op2)
    reg3 = Class.GetRegRead(func_num, inst_num, inst.op3, inst.op2, reg2)
    reg1 = Class.GetRegWrite(func_num, inst_num, inst.op1, inst.op2, reg2, inst.op3, reg3)
  elseif (group == "3in0out") then
    reg1 = Class.GetRegRead(func_num, inst_num, inst.op1)
    reg2 = Class.GetRegRead(func_num, inst_num, inst.op2)
    reg3 = Class.GetRegRead(func_num, inst_num, inst.op3)
  end
  return reg1, reg2, reg3
end

--GetRegRead:
--  Parameters:
--    [1] $number         - Function number
--    [2] $number         - Number of current instruction
--    [3] $string         - Variable that should get a registrator
--    [4] $string or $nil - Operator 1 already allocated by 'GetReg'
--    [5] $number or $nil - Number of register used by Operator 1
--    [6] $string or $nil - Operator 2 already allocated by 'GetReg'
--    [7] $number or $nil - Number of register used by Operator 2
--  Return:
--    [1] $number         - Number of register to use;
function Class.GetRegRead (func_num, inst_num, op, op1, reg1, op2, reg2)
  if (_DEBUG) then print("MCG :: GetReg") end
  assert(type(func_num) == "number")
  assert(type(inst_num) == "number")
  assert(type(op) == "string")
  assert(not op1 or type(op1) == "string")
  assert(not reg1 or type(reg1) == "number")
  assert(not op2 or type(op2) == "string")
  assert(not reg2 or type(reg2) == "number")
  local operations = {}
  if (not Class.GetOperatorIsVar(op)) then
    return nil
  end
  local reg
  if (Class.GetVarInReg(op)) then
    return Class.GetVarInReg(op)
  end
  if (Class.GetRegEmpty()) then
    reg = Class.GetRegEmpty()
    Class.RegGetMem(func_num, reg, op)
    Class.UpdateTables(reg, op)
    return reg
  end
  for regnum, regtable in ipairs(reg_var.regs) do
    local avaiable = true
    for _, var in ipairs(regtable) do
      if (not Class.GetVarInMem(var)) then
        avaiable = false
        break
      end
    end
    if (avaiable) then
      Class.UpdateTables(regnum, op, true)
      Class.RegGetMem(func_num, regnum, op)
      return regnum
    end
  end
  for regnum, regtable in ipairs(reg_var.regs) do
    local avaiable = true
    for _, var in ipairs(regtable) do
      if (Class.GetVarNextUse(inst_num, var)) then
        avaiable = false
        break
      end
    end
    if (avaiable) then
      Class.UpdateTables(regnum, op, true)
      Class.RegGetMem(func_num, regnum, op)
      return regnum
    end
  end
  local t = {}
  for regnum, regtable in ipairs(reg_var.regs) do
    if ((not reg1 or regnum ~= reg1) and (not reg2 or regnum ~= reg2)) then
      local count = 0
      for _, var in ipairs(regtable) do
        if (not Class.GetVarInMem(var) and Class.GetVarNextUse(inst_num, var)) then
          count = count + 1
        end
      end
      t[regnum] = count
    end
  end
  local selected
  for i = 1, #registers do
    if (t[i] and not selected) then
      selected = i
    elseif (t[i] and t[i] > selected) then
      selected = i
    end
  end
  for _, var in ipairs(reg_var.regs[selected]) do
    Class.VarClear(var)
    Class.VarSaveMem(func_num, var, selected)
  end
  Class.RegClear(selected)
  Class.RegAddVar(selected, op)
  Class.RegGetMem(func_num, selected, op)
  return selected
end

--GetRegWrite:
--  Parameters:
--    [1] $number         - Function number
--    [2] $number         - Number of current instruction
--    [3] $string         - Variable that should get a registrator
--    [4] $string or $nil - Operator 1 already allocated by 'GetReg'
--    [5] $number or $nil - Number of register used by Operator 1
--    [6] $string or $nil - Operator 2 already allocated by 'GetReg'
--    [7] $number or $nil - Number of register used by Operator 2
--  Return:
--    [1] $number         - Number of register to use
function Class.GetRegWrite (func_num, inst_num, op, op1, reg1, op2, reg2)
  if (_DEBUG) then print("MCG :: GetReg") end
  assert(type(func_num) == "number")
  assert(type(inst_num) == "number")
  assert(type(op) == "string")
  assert(not op1 or type(op1) == "string")
  assert(not reg1 or type(reg1) == "number")
  assert(not op2 or type(op2) == "string")
  assert(not reg2 or type(reg2) == "number")
  if (not Class.GetOperatorIsVar(op)) then
    return nil
  end
  for regnum, regtable in ipairs(reg_var.regs) do
    if (#regtable == 1 and regtable[1] == op) then
      return regnum
    end
  end
  if (reg1 and not Class.GetVarNextUse(inst_num, op1)) then
    if (#reg_var.regs[reg1] == 1) then
      Class.UpdateTables(reg1, op, true, true)
      return reg1
    end
  end
  if (reg2 and not Class.GetVarNextUse(inst_num, op2)) then
    if (#reg_var.regs[reg2] == 1) then
      Class.UpdateTables(reg2, op, false, true)
      return reg2
    end
  end
  if (Class.GetRegEmpty()) then
    reg = Class.GetRegEmpty()
    Class.UpdateTables(reg, op, false, true)
    return reg
  end
  for regnum, regtable in ipairs(reg_var.regs) do
    local avaiable = true
    for _, var in ipairs(regtable) do
      if (not Class.GetVarInMem(var)) then
        avaiable = false
        break
      end
    end
    if (avaiable) then
      Class.UpdateTables(regnum, op, true, true)
      return regnum
    end
  end
  for regnum, regtable in ipairs(reg_var.regs) do
    local avaiable = true
    for _, var in ipairs(regtable) do
      if (Class.GetVarNextUse(inst_num, var)) then
        avaiable = false
        break
      end
    end
    if (avaiable) then
      Class.UpdateTables(regnum, op, true, true)
      return regnum
    end
  end
  local t = {}
  for regnum, regtable in ipairs(reg_var.regs) do
    if ((not reg1 or regnum ~= reg1) and (not reg2 or regnum ~= reg2)) then
      local count = 0
      for _, var in ipairs(regtable) do
        if (not Class.GetVarInMem(var) and Class.GetVarNextUse(inst_num, var)) then
          count = count + 1
        end
      end
      t[regnum] = count
    end
  end
  local selected
  for i = 1, #registers do
    if (t[i] and not selected) then
      selected = i
    elseif (t[i] and t[i] > selected) then
      selected = i
    end
  end
  for _, var in ipairs(reg_var.regs[selected]) do
    Class.VarClear(var)
    Class.VarSaveMem(func_num, var, selected)
  end
  Class.RegClear(selected)
  Class.RegAddVar(selected, op)
  return selected
end

--GetRegEmpty: Check if a register is empty
--  Parameters:
--    [1] $number         - Start counting from this number
--  Return:
--    [1] $number or $nil - Number of register who is empty
function Class.GetRegEmpty ()
  if (_DEBUG) then print("MCG :: GetRegEmpty") end
  for regnum, regtable in ipairs(reg_var.regs) do
    if (util.TableIsEmpty(regtable)) then
      return regnum
    end
  end
  return nil
end

--GetVarInMem: Check if a variable is placed inside memory
--  Parameters:
--    [1] $string   - Variable name
--  Return:
--    [1] $boolean  - TRUE if variable is saved in memory, FALSE otherwise
function Class.GetVarInMem (var)
  if (_DEBUG) then print("MCG :: GetVarInMem") end
  assert(type(var) == "string")
  for _, place in ipairs(reg_var.vars[var]) do
    if (place == var) then
      return true
    end
  end
  return false
end

--GetVarInReg: Check if a variable is placed inside a register
--  Parameters:
--    [1] $string         - Variable name
--  Return:
--    [1] $number or $nil - Number of register who has variable inside
function Class.GetVarInReg (var)
  if (_DEBUG) then print("MCG :: GetVarInReg") end
  assert(type(var) == "string")
  for regnum, regtable in ipairs(reg_var.regs) do
    for _, variable in ipairs(regtable) do
      if (var == variable) then
        return regnum
      end
    end
  end
  return nil
end

--GetVarNextUse:
--  Parameters:
--    [1] $string - Variable name
--    [2] $number - Number of current instruction
--  Return:
--    [1] $boolean  - TRUE if variable is going to be used, FALSE if value
--                    can be erased
--    [2] $number   - Return the next use of variable
function Class.GetVarNextUse (inst_num, var)
  if (_DEBUG) then print("MCG :: GetVarNextUse") end
  assert(type(inst_num) == "number")
  assert(type(var) == "string")
  return var_use[inst_num][var].alive, var_use[inst_num][var].next_inst
end

--GlobalAdd: Insert a global in the list to be declared under '.globl'
--    assembler code, in '.text' sector
--  Parameters:
--    [1] $string - Label, function name or global variable
--  Return:
function Class.GlobalAdd (str)
  if (_DEBUG) then print("MCG :: GlobalAdd") end
  assert(str)
  table.insert(list_globals, str)
end

--LabelCount:
--  Parameters:
--  Return:
function Class.LabelCount (functions)
  local count = 0
  for _, func in ipairs(functions) do
    for _, inst in ipairs(func) do
      if (inst.code == operations_code["LABEL"]) then
        count = count + 1
      end
    end
  end
  label_count = count
end

--LabelGetNew:
--  Parameters:
--  Return:
--    [1] $string - New unique label
function Class.LabelGetNew ()
  label_count = label_count + 1
  return ".L" .. label_count
end

--PrintTableRegistersVariables:
--  Parameters:
--  Return:
function Class.PrintTableRegistersVariables ()
  if (_DEBUG) then print("MCG :: PrintTableRegistersVariables") end
  for regnum, regtable in ipairs(reg_var.regs) do
    local str = "REG " .. regnum .. ": "
    for _, var in ipairs(regtable) do
      str = str .. " \t" .. var
    end
    print(str)
  end
  for varname, vartable in pairs(reg_var.vars) do
    local str = "VAR " .. varname .. ": "
    for _, place in ipairs(vartable) do
      str = str .. " \t" .. place
    end
    print(str)
  end
end

--RegAddVar: Add a variable inside a register
--  Parameters:
--    [1] $number   - Number of register
--    [2] $string   - Variable name
--  Return:
function Class.RegAddVar (reg, var)
  if (_DEBUG) then print("MCG :: RegAddVar") end
  assert(type(reg) == "number")
  assert(type(var) == "string")
  table.insert(reg_var.regs[reg], var)
end

--RegClear: Remove all variables from a register
--  Parameters:
--    [1] $number   - Number of register
--  Return:
function Class.RegClear (reg)
  if (_DEBUG) then print("MCG :: RegClear") end
  assert(type(reg) == "number")
  reg_var.regs[reg] = {}
end

--RegGetMem:
--  Parameters:
--  Return:
function Class.RegGetMem (func_num, reg, var)
  if (_DEBUG) then print("MCG :: VarSaveMem") end
  assert(type(func_num) == "number")
  assert(type(reg) == "number")
  assert(type(var) == "string")
  Class.FunAddAssemblerInst(func_num, string.format("  movl   %s, %s", stack[var], registers[reg]))
end

--RegGetNum: Get a register number 
--  Parameters:
--    [1] $string - Register name
--  Return:
--    [1] $number or $nil - Register number
function Class.RegGetNum (str)
  for regnum, regname in ipairs(registers) do
    if (regname == str) then
      return regnum
    end
  end
  return nil
end

--UpdateTables: Update 'reg_var' and 'var_use' tables
--  Parameters:
--    [1] $number   - Number of register
--    [2] $string   - Variable name
--    [3] $boolean  - TRUE to empty register before addition
--    [4] $boolean  - TRUE to empty var references except new register
--  Return:
function Class.UpdateTables (reg, var, reg_clear, var_write)
  if (_DEBUG) then print("MCG :: UpdateTables") end
  assert(type(reg) == "number")
  assert(type(var) == "string")
  assert(not reg_clear or type(reg_clear) == "boolean")
  assert(not var_write or type(var_write) == "boolean")
  if (var_write or reg_clear) then
    for _, var_in_reg in ipairs(reg_var.regs[reg]) do
      Class.VarRemoveReg(var_in_reg, reg)
    end
    Class.RegClear(reg)
    Class.RegAddVar(reg, var)
    if (var_write) then
      Class.VarClear(var)
      Class.VarAddReg(var, reg)
    end
  else
    Class.RegAddVar(reg, var)
  end
end

--VarAddReg: Add a register inside a variable
--  Parameters:
--    [1] $string   - Variable name
--    [2] $number   - Number of register
--  Return:
function Class.VarAddReg (var, reg)
  if (_DEBUG) then print("MCG :: VarAddReg") end
  assert(type(reg) == "number")
  assert(type(var) == "string")
  table.insert(reg_var.vars[var], reg)
end

--VarClear: Remove all registers and variable from a variable
--  Parameters:
--    [1] $string   - Variable name
--  Return:
function Class.VarClear (var)
  if (_DEBUG) then print("MCG :: VarClear") end
  assert(type(var) == "string")
  reg_var.vars[var] = {}
end

--VarRemoveReg: Remove a register from a variable
--  Parameters:
--    [1] $string   - Variable name
--    [2] $number   - Number of register
--  Return:
function Class.VarRemoveReg (var, reg)
  if (_DEBUG) then print("MCG :: VarRemoveReg") end
  assert(type(var) == "string")
  assert(type(reg) == "number")
  for i, data in ipairs(reg_var.vars[var]) do
    if (data == reg) then
      table.remove(reg_var.vars[var], i)
    end
  end
end

--VarSaveMem: Add assembler instruction to save variable from register to memory
--    and update table;
--  Parameters:
--  Return:
function Class.VarSaveMem (func_num, var, reg)
  if (_DEBUG) then print("MCG :: VarSaveMem") end
  assert(type(func_num) == "number")
  assert(type(var) == "string")
  assert(type(reg) == "number")
  Class.FunAddAssemblerInst(func_num, string.format("  movl   %s, %s", registers[reg], stack[var]))
  table.insert(reg_var.vars[var], var)
end


--==============================================================================
-- Public Methods
--==============================================================================

--Open: Write a 'path'.o file with machine code.
--  Parameters:
--    [1] $string   - Path of exit file. Extension will be converted to '.o'
--    [2] $table    - Struct of program builded by intermediate code.
--  Return:
--    [1] $boolean  - false if found any problem, true otherwise
--    [2] $string   - only when [1] is false, informing which error occurs
function Class.Open (path, intermediate_code)
  if (_DEBUG) then print("MCG :: Open") end
  assert(path)
  assert(type(intermediate_code) == "table")
  local ok, msg = pcall(function ()
    Class.Clear()
    local f = io.open(util.FileRemoveExtension(path) .. ".s", "w")
    if (not f) then
      Class.Error(string.format("output file '%s' could not be opened"), path)
    end
    f:write(string.format('.data\n'))
    for _, string in ipairs(intermediate_code.strings) do
      Class.DumpString(f, string.var, string.str)
    end
    for _, global in ipairs(intermediate_code.globals) do
      Class.DumpGlobalVariable(f, global)
    end
    f:write(string.format('.text\n'))
    Class.LabelCount(intermediate_code.functions)
    for i, func in ipairs(intermediate_code.functions) do
      Class.FunGenMachineCode(i, func)
    end
    Class.DumpGlobals(f)
    Class.DumpFunctions(f)
  end)
  if (not ok) then
    return false, msg
  end
  return true
end


--==============================================================================
-- Return
--==============================================================================

return Class
