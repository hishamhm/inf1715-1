
==============================================================================
./lib/lulex.lua
==============================================================================
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      18	local Lulex = {}
        	
        	local rex_ok, rex
        	
      36	for _, flavor in ipairs{"gnu", "pcre", "tre", "posix", "oniguruma"} do
      36	   rex_ok, rex = pcall(require, "rex_"..flavor)
      36	   if rex_ok then
      18	      break
        	   end
        	end
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	local function Lua_match(rule, input, at)
*******0	   if (_DEBUG) then print("LLX :: Lua_match") end
*******0	   local match = string.match(input, "^"..rule[1], at)
*******0	   if match then
*******0	      return at + #match
        	   end
        	end
        	
        	local function Re_match(rule, input, at)
 1055564	   if (_DEBUG) then print("LLX :: Re_match") end
 3199716	   if not rule.pat then
     774	      rule.pat = rex.new("^"..rule[1])
        	   end
 3199716	   local start, finish = rule.pat:find(input:sub(at))
 3199716	   if start then
  164333	      return at+(finish-start)+1
        	   end
        	end
        	
        	local function Run(self, input)
     758	   if (_DEBUG) then print("LLX :: Run") end
    1839	   local at = 1
   76251	   while at <= #input do
   74412	      local lrule = nil
   74412	      local llen = 0
 3274128	      for _, rule in ipairs(self.rules) do
 3199716	         local found = self.match(rule, input, at)
 3199716	         if found then
  164333	            local len = found - at
  164333	            if len > llen then
   74996	               llen = len
   74996	               lrule = rule
        	            end
        	         end
        	      end
   74412	      if lrule then
   74412	         lrule[2](input:sub(at, at+llen-1))
   74412	         at = at + llen
        	      else
*******0	         io.write(input:sub(at, at))
*******0	         at = at + 1
        	      end
        	   end
        	end
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
      18	function Lulex.New(rules, use_lua)
       2	   if (_DEBUG) then print("LLX :: New") end
      18	   return {
      18	      match = (use_lua or not rex_ok) and Lua_match or Re_match,
      18	      rules = rules,
      18	      run = Run,
      18	   }
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      18	return Lulex

==============================================================================
./lib/node_codes.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      18	local Nodes = {}
        	
        	-- code of each node
        	--  {
        	--    ["node id"] = $number,
        	--  }
      18	local codes = {
      18	  ["ATTRIBUTION"] = 01,
      18	  ["CALL"]        = 02,
      18	  ["DECLARE"]     = 03,
      18	  ["ELSEIF"]      = 04,
      18	  ["FUNCTION"]    = 05,
      18	  ["IF"]          = 06,
      18	  ["LITERAL"]     = 07,
      18	  ["NEGATE"]      = 08,
      18	  ["NEWVAR"]      = 09,
      18	  ["OPERATOR"]    = 10,
      18	  ["PARAMETER"]   = 11,
      18	  ["PROGRAM"]     = 12,
      18	  ["RETURN"]      = 13,
      18	  ["UNARY"]       = 14,
      18	  ["VAR"]         = 15,
      18	  ["WHILE"]       = 16,
      16	}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
       2	function Nodes.GetNodesList ()
      26	  return codes
        	end
        	
       2	function Nodes.GetNodeName (node_code)
      16	  assert(type(node_code) == "number")
*******0	  for name, code in pairs(codes) do
*******0	    if (code == node_code) then
*******0	      return name
        	    end
        	  end
*******0	  return nil
        	end
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       2	return Nodes

==============================================================================
./lib/token_codes.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      18	local Tokens = {}
        	
        	-- code of each token
        	--  {
        	--    ["token id"] = $number,
        	--  }
      18	local codes = {
      18	  COMMENT_LINE  = 610,
      18	  COMMENT_BLOCK = 620,
      18	  K_IF          = 101,
      18	  K_THEN        = 102,
      18	  K_ELSE        = 103,
      18	  K_WHILE       = 104,
      18	  K_LOOP        = 105,
      18	  K_FUN         = 106,
      18	  K_RETURN      = 107,
      18	  K_NEW         = 108,
      18	  K_STRING      = 109,
      18	  K_INT         = 110,
      18	  K_CHAR        = 111,
      18	  K_BOOL        = 112,
      18	  K_TRUE        = 113,
      18	  K_FALSE       = 114,
      18	  K_AND         = 115,
      18	  K_OR          = 116,
      18	  K_NOT         = 117,
      18	  K_END         = 118,
      18	  STRING        = 200,
      18	  NUMBER        = 300,
      18	  ["OP_("]      = 401,
      18	  ["OP_)"]      = 402,
      18	  ["OP_,"]      = 403,
      18	  ["OP_:"]      = 404,
      18	  ["OP_>"]      = 405,
      18	  ["OP_<"]      = 406,
      18	  ["OP_>="]     = 407,
      18	  ["OP_<="]     = 408,
      18	  ["OP_="]      = 409,
      18	  ["OP_<>"]     = 410,
      18	  ["OP_["]      = 411,
      18	  ["OP_]"]      = 412,
      18	  ["OP_+"]      = 413,
      18	  ["OP_-"]      = 414,
      18	  ["OP_*"]      = 415,
      18	  ["OP_/"]      = 416,
      18	  LINE_END      = 500,
      18	  ID            = 800,
      18	  ERROR         = 000,
        	}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
      18	function Tokens.GetTokensList ()
      36	  return codes
        	end
        	
      18	function Tokens.GetTokenName (token_code)
     396	  assert(type(token_code) == "number")
   10440	  for name, code in pairs(codes) do
   10440	    if (code == token_code) then
     396	      return name
        	    end
        	  end
*******0	  return nil
        	end
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      18	return Tokens

==============================================================================
./lib/util.lua
==============================================================================
        	--==============================================================================
        	-- Class Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Class Implementation
        	--==============================================================================
        	
      18	util = {}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--FileExists:
        	--  parameters:
        	--    [1] $string  [file path and name including extension to be evaluated]
        	--  return:
        	--    [1] $boolean [true if file exists, false otherwise]
      36	function util.FileExists (file)
*******0	  if (file == nil or type(file) ~= "string" or file == "") then
*******0	    return false
        	  end
*******0	  local f, msg = io.open(file, "r")
*******0	  if (f == nil) then
*******0	    return false
        	  end
*******0	  f:close()
*******0	  return true
        	end
        	
        	--FileRemoveExtension()
        	--  parameters:
        	--    [1] $string  [file path and name including extension to be evaluated]
        	--  return:
        	--    [1] 
      36	function util.FileRemoveExtension (file)
     174	  assert(file)
     174	  return string.gsub(file, "(.+)%.(.*)","%1")
        	end
        	
        	--FileToTable:
        	--  parameters:
        	--    [1] 
        	--  return:
        	--    [1] 
       4	function util.FileToTable (file)
*******0	  if (file == nil or type(file) ~= "string" or file == "") then
*******0	    return false, "Parameter 'file' is invalid"
        	  end
      16	  local f = io.open(file, "r")
*******0	  if (f == nil) then
*******0	    return false, "Could not open desired file"
        	  end
*******0	  local t = FileToTableAux(f, {})
*******0	  f:close()
*******0	  if (t and type(t) == "table") then
      32	    return true, t
        	  end
      16	  return false, {}
        	end
        	
        	--StringIsNull:
        	--  parameters:
        	--    [1] $string  [string that is going to be evaluated]
        	--  return:
        	--    [1] $boolean [true if string is null]
   22076	function util.StringIsNull (str)
*******0	  return (str == nil or str == "")
        	end
        	
        	--TableCopy:
        	--  parameters:
        	--    [1] $table [table that is going to be duplicated]
        	--  return:
        	--    [1] $table [copy of incoming table]
   66466	function util.TableCopy (t)
   79852	  if (not t or type(t) ~= "table") then
   19079	    return
        	  end
   60773	  local ret = {}
   13390	  local mt = getmetatable(t)
   13390	  if mt then
   22072	    setmetatable(ret, mt)
        	  end
   56132	  for k,v in pairs(t) do
   42742	    v = rawget(t, k)
   42742	    if type(v)== "table" then
    9966	      rawset(ret, k, util.TableCopy(v))
        	    else
   32776	      rawset(ret, k, v)
        	    end
        	  end
   13390	  return ret
        	end
        	
        	--TableGetChanges:
        	--  required:
        	--    [1] $table [old table]
        	--    [2] $table [new table]
        	--  return:
        	--    [1] $table [fields that have been modified from old_table to new_table]
       4	function util.TableGetChanges (old_table, new_table)
*******0	  if not old_table or not new_table then 
*******0	    return 
        	  end
*******0	  local changes = {}
*******0	  for k, v in pairs(old_table) do
*******0	    if type(v) == "table" then
      16	      changes[k] = utils.GetTableChanges(v, new_table[k])
        	    else
*******0	      if new_table[k] ~= nil and new_table[k] ~= v then
*******0	        changes[k] = new_table[k]
        	      end
        	    end
        	  end
      32	  if next(changes) then
*******0	    return changes
        	  end
        	end
        	
        	--TableIsEmpty:
        	--  parameters:
        	--    [1] $table   [table that is going to be valuated]
        	--  return:
        	--    [1] $boolean [true if table is empty, false otherwise]
       4	function util.TableIsEmpty (t)
     102	  assert(type(t) == "table")
      70	  for _, _ in pairs(t) do
      20	    return false
        	  end
      50	  return true
        	end
        	
        	--TablePrint:
        	--  parameters:
        	--    [1] $table [table that is going to be printed]
       4	function util.TablePrint (t)
     174	  if (not t) then
      32	    return
        	  end
     174	  print(TablePrintAux("", t, ""))
        	end
        	
        	--TableToFile:
        	--  parameters:
        	--    [1] $table  [table that is going to be printed]
        	--  return:
        	--    [1] $string [string of copied table]
       4	function util.TableToFile (file, t)
*******0	  if (file == nil or type(file) ~= "string" or file == "") then
*******0	    return false, "Parameter 'file' is invalid"
        	  end
      16	  local f = io.open(file, "w")
*******0	  if (f == nil) then
*******0	    return false, "Could not open desired file"
        	  end
*******0	  if (not t) then
*******0	    return
        	  end
      32	  TableToFileAux(f, "", t, "")
*******0	  f:close()
*******0	  return true
        	end
        	
        	--TableToString:
        	--  parameters:
        	--    [1] $table  [table that is going to be printed]
        	--  return:
        	--    [1] $string [string of copied table]
       4	function util.TableToString (t)
*******0	  if (not t) then
      16	    return
        	  end
*******0	  return TablePrintAux("", t, "")
        	end
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
       2	function FileToTableAux(file, t)
*******0	  local str = file:read()
*******0	  while (str) do
*******0	    if (string.find(str, '%["([^"]+)"%] = {')) then
*******0	      local _, _, field = string.find(str, '%["([^"]+)"%] = {')
*******0	      t[field] = FileToTableAux(file, {})
*******0	    elseif (string.find(str, '%[([^%]]+)%] = {')) then
*******0	      local _, _, n = string.find(str, '%[([^%]]+)%] = {')
*******0	      n = tonumber(n)
*******0	      t[n] = FileToTableAux(file, {})
*******0	    elseif (string.find(str, '%["([^"]+)"%]%s%=%s"([^"]+)"')) then
*******0	      local _, _, field, value = string.find(str, '%["([^"]+)"%]%s%=%s"([^"]+)"')
      16	      t[field] = value
*******0	    elseif (string.find(str, '%[([^%]]+)%]%s%=%s"([^"]+)"')) then
      16	      local _, _, n, value = string.find(str, '%[([^%]]+)%]%s%=%s"([^"]+)"')
*******0	      n = tonumber(n)
*******0	      t[n] = value
*******0	    elseif (string.find(str, "}")) then
*******0	      return t
        	    end
*******0	    str = file:read()
        	  end
        	end
        	
       2	function TablePrintAux (s, t, indent)
    1814	  s = s .. "{\n"
    1814	  local oldindent = indent
    1814	  indent = indent .. "  "
    5824	  for k, v in pairs(t) do
    4010	    if (type(k) == "string") then
    2832	      s = s .. indent .. "[" .. string.format("%q", k) .. "] = "
    1178	    elseif (type(k) == "number") then
    1178	      s = s .. indent .. "[" .. k .. "] = "
        	    end
    4010	    if (type(v) == "table") then
    1656	      s = TablePrintAux(s, v, indent)
    2370	    elseif (type(v) == "string") then
    1482	      s = s .. string.format("%q", v)
        	    else
     904	      s = s .. tostring(v)
        	    end
    4010	    s = s .. ",\n"
        	  end
    1814	  s = s .. oldindent .. "}"
    1814	  return s
        	end
        	
       2	function TableToFileAux (file, s, t, indent)
*******0	  file:write("{\n")
*******0	  local oldindent = indent
*******0	  indent = indent .. "  "
*******0	  for k, v in pairs(t) do
*******0	    if (type(k) == "string") then
*******0	      file:write(indent .. "[" .. string.format("%q", k) .. "] = ")
*******0	    elseif (type(k) == "number") then
*******0	      file:write(indent .. "[" .. k .. "] = ")
        	    end
      32	    if (type(v) == "table") then
*******0	      s = TableToFileAux(file, s, v, indent)
*******0	    elseif (type(v) == "string") then
*******0	      file:write(string.format("%q", v))
        	    else
*******0	      file:write(tostring(v))
        	    end
*******0	    file:write(",\n")
        	  end
*******0	  file:write(oldindent .. "}")
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	

==============================================================================
./lib/util_tree.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      13	local NodesClass  = require "lib/node_codes"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      13	local Print = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
      13	local nodes_codes = NodesClass.GetNodesList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
      13	function Print.Block (indent, t)
      17	  if (t) then
      42	    for _, node in ipairs(t) do
      25	      if (node.id == nodes_codes["ATTRIBUTION"]) then
      11	        Print.ComandAttribution(indent, node)
      14	      elseif (node.id == nodes_codes["IF"]) then
       1	        Print.ComandIf(indent, node)
      13	      elseif (node.id == nodes_codes["RETURN"]) then
       5	        Print.ComandReturn(indent, node)
       8	      elseif (node.id == nodes_codes["WHILE"]) then
       2	        Print.ComandWhile(indent, node)
       6	      elseif (node.id == nodes_codes["DECLARE"]) then
       2	        Print.Declare(indent, node)
       4	      elseif (node.id == nodes_codes["CALL"]) then
       4	        Print.Call(indent, node)
        	      --elseif (node.id == nodes_codes["VAR"]) then
        	        --Print.Variable(indent, node)
        	      else
*******0	        error("block node error")
        	      end
        	    end
        	  end
        	end
        	
      13	function Print.Call (indent, t)
       4	  print(indent .. "CALL [" .. t.name .. "] @" .. t.line .. "  {")
       6	  for _, node in ipairs(t.exps) do
       2	    print(indent .. "  PARAM " .. Print.Expression(node))
        	  end
       4	  local str = indent .. "}"
       4	  if (t.sem_type and t.sem_dimension) then
       3	    str = str .. string.format(" #%s:%d", t.sem_type, t.sem_dimension)
        	  end
       4	  print(str)
        	end
        	
      13	function Print.ComandAttribution (indent, t)
      23	  print(indent .. "ATRIB @" .. t.line .. " {")
      23	  local str = ""
      23	  str = str .. t.var.name
      23	  if (t.var.array) then
      30	    for _, exp in ipairs(t.var.array) do
       7	      str = str .. "[" .. Print.Expression(exp) .. "]"
        	    end
        	  end
      23	  Print.Variable(indent .. "  ", t.var)
        	
      23	  print(indent .. "  =" .. Print.Expression(t.exp))
      23	  print(indent .. "}")
        	end
        	
      13	function Print.ComandElseIf (indent, t)
       2	  print(indent .. "ELSEIF [" .. Print.Expression(t.cond) .. "] @" .. t.line)
       2	  Print.Block(indent .. "  ", t.block)
        	end
        	
      13	function Print.ComandIf (indent, t)
       6	  print(indent .. "IF [" .. Print.Expression(t.cond) .. "] @" .. t.line .. " {")
       6	  Print.Block(indent .. "  ", t.block)
       6	  if (t["elseif"]) then
       8	    for _, elseif_node in ipairs(t["elseif"]) do
       2	      Print.ComandElseIf(indent, elseif_node)
        	    end
        	  end
       6	  if (t["else"]) then
       5	    print(indent .. "ELSE ")
       5	    Print.Block(indent .. "  ", t["else"])
        	  end
       6	  print(indent .. "}")
        	end
        	
      13	function Print.ComandReturn (indent, t)
       8	  print(indent .. "RETURN @" .. t.line .. " {")
       8	  print(indent .. "  " .. Print.Expression(t.exp))
       8	  print(indent .. "}")
        	  -- print(indent .. "RETURN [" .. Print.Expression(t.exp) .. "] @" .. t.line)
        	end
        	
      13	function Print.ComandWhile (indent, t)
       4	  print(indent .. "WHILE [" .. Print.Expression(t.cond) .. "] @" .. t.line .. " {")
       4	  Print.Block(indent .. "  ", t.block)
       4	  print(indent .. "}")
        	end
        	
      13	function Print.Declare (indent, t)
      24	  print(indent .. "DECLARE @" .. t.line .. "{")
      24	  print(indent .. "  ID [" .. t.name .. "] " .. t.type .. string.rep("[]", t.dimension) .. " @" .. t.line)
      24	  print(indent .. "}")
        	  -- print(indent .. "DECLARE [" .. t.name .. "] " .. t.type .. string.rep("[]", t.dimension) .. " @" .. t.line)
        	end
        	
      13	function Print.Expression (t)
     109	  local str = "("
     109	  if (not t) then
       7	    return ""
        	  end
     102	  if (t.id == nodes_codes["PARENTHESIS"]) then
*******0	    str = str .. " (" .. Print.Expression(t.exp) .. ")"
     102	  elseif (t.id == nodes_codes["NEWVAR"]) then
       3	    str = str .. " new [" .. Print.Expression(t.exp) .. "] " .. t.type
      99	  elseif (t.id == nodes_codes["NEGATE"]) then
       1	    str = str .. " not " .. Print.Expression(t.exp)
      98	  elseif (t.id == nodes_codes["UNARY"]) then
*******0	    str = str .. " - " .. Print.Expression(t.exp)
      98	  elseif (t.id == nodes_codes["OPERATOR"]) then
      22	    str = str .. Print.Expression(t[1]) .. " " .. t.op .. " " .. Print.Expression(t[2])
      76	  elseif (t.id == nodes_codes["LITERAL"]) then
      44	    str = str .. " " .. t.value
      32	  elseif (t.id == nodes_codes["CALL"]) then
       2	    str = str .. " " .. t.name .. "("
       2	    if (t.exps) then
       2	      str = str .. Print.Expression(t.exps[1])
       2	      if (t.exps[2]) then
*******0	        for i = 2, #t.exps do
*******0	          str = str .. ", " .. Print.Expression(t.exps[i])
        	        end
        	      end
        	    end
       2	    str = str .. ")"
      30	  elseif (t.id == nodes_codes["VAR"]) then
      30	    str = str .. " " .. t.name
      30	    if (t.array) then
      30	      for _, exp in ipairs(t.array) do
*******0	        str = str .. "["
*******0	        str = str .. Print.Expression(exp)
*******0	        str = str .. "]"
        	      end
        	    end
        	  else
*******0	    error("expression node error")
        	  end
     102	  if (t.sem_type and t.sem_dimension) then
     102	    str = str .. string.format(" #%s:%d", t.sem_type, t.sem_dimension)
        	  end
     102	  return str .. ")"
        	end
        	
      13	function Print.Function (indent, t)
      15	  print(indent .. "FUN [" .. t.name .. "] @" .. t.line .. " {")
      22	  for _, node in ipairs(t.params) do
       7	    print(indent .. "  FUNC_PARAMETER [" .. node.name .. "] " .. node.type .. string.rep("[]", node.dimension))
        	  end
      15	  print(indent .. "  FUNC_RETURN " .. (t.ret_type or "VOID") .. string.rep("[]", t.ret_dimension or 0))
      45	  for _, node in ipairs(t.block) do
      30	    if (node.id == nodes_codes["DECLARE"]) then
       8	      Print.Declare(indent .. "  ", node)
      22	    elseif (node.id == nodes_codes["CALL"]) then
*******0	      Print.Call(indent .. "  ", node)
      22	    elseif (node.id == nodes_codes["ATTRIBUTION"]) then
      12	      Print.ComandAttribution(indent .. "  ", node)
      10	    elseif (node.id == nodes_codes["IF"]) then
       5	      Print.ComandIf(indent .. "  ", node)
       5	    elseif (node.id == nodes_codes["RETURN"]) then
       3	      Print.ComandReturn(indent .. "  ", node)
       2	    elseif (node.id == nodes_codes["WHILE"]) then
       2	      Print.ComandWhile(indent .. "  ", node)
        	    end
        	  end
      15	  print(indent .. "}")
        	end
        	
      13	function Print.Program (indent, t)
      10	  print(indent .. "PROGRAM {")
      39	  for _, node in ipairs(t) do
      29	    if (node.id == nodes_codes["DECLARE"]) then
      14	      Print.Declare(indent .. "  ", node)
      15	    elseif (node.id == nodes_codes["FUNCTION"]) then
      15	      Print.Function(indent .. "  ", node)
        	    end
        	  end
      10	  print(indent .. "}")
        	end
        	
      13	function Print.Variable (indent, t)
      23	  local array_str = ""
      30	  for _, exp in ipairs(t.array) do
       7	    array_str = array_str .. "[" .. Print.Expression() .. "]"
        	  end
      23	  print(indent .. "ID [" .. t.name .. "] " .. array_str .. " @" .. t.line)
        	end
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Print: Print Abstract Syntax or Semantic Tree with comprehensible format
        	--  parameters:
        	--  return:
      13	function Print.Print (tree)
      10	  if (_DEBUG) then print("PRT :: Print") end
      10	  Print.Program("", tree)
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      13	return Print

==============================================================================
./src/grammar.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
      18	local printTokensMatch = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      18	local TokensClass = require "lib/token_codes"
      18	local ASTClass    = require "src/syntax_tree"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      18	local Language = {}
        	
        	-- Stores Parser Functions
        	--  {
        	--    $name = $function
        	--  }
      18	local Parser = {}
        	
        	-- Stores Grammar Functions
        	--  {
        	--    $name = $function
        	--  }
      18	local Grammar = {}
        	
        	--  list of tokens
        	--  {
        	--    [name] = $number,
        	--  }
      18	local tokens = TokensClass.GetTokensList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	--Error: Callback of errors that occurs during syntax analysis
        	--  Parameters:
        	--    [1] $number - line number of grammar syntax error
        	--  Return:
        	local function Error (line)
     269	  error(string.format("@%d syntactic error.", line), 0)
        	end
        	
        	--Match: Receives a token code number and compare with next avaiable token received from lexical
        	--  Parameters:
        	--    [1] $number - Next expected token code number
        	--  Return:
        	--    [1] $string - Token value/name
        	--    [2] $number - Token line number
        	local function Match (code)
   52352	  if (_DEBUG) then print("LAN :: Match") end
   52352	  local token = Parser.Peek()
   52352	  if (token and token.code == code) then
   52154	    if (_DEBUG or printTokensMatch) then
*******0	      print(string.format("    Match code '%10s' %s", TokensClass.GetTokenName(code), token.token))
        	    end
   52154	    Parser.Advance()
   52154	    return token.token, token.line
        	  else
     198	    if (token) then
     198	      error(string.format("@%d syntactic error: expected token '%s' got token '%s'.", token.line, TokensClass.GetTokenName(code), TokensClass.GetTokenName(token.code)), 0)
        	    else
*******0	      error(string.format("@EOF syntactic error: expected token '%s' got 'END_OF_TOKENS'.", TokensClass.GetTokenName(code)), 0)
        	    end
        	  end
        	end
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	--Block:
        	--  syntax:
        	--    bloco     → { declvar nl }
        	--                { comando nl }
        	--  parameters:
        	--  return:
        	--    [1] $table  - List of DECLARE, [...] nodes
      18	function Grammar.Block ()
    2850	  if (_DEBUG) then print("LAN :: Grammar_bloco") end
    2850	  local list = {}
*******0	  while (true) do
    3919	    local token = Parser.Peek()
    3919	    local token2 = Parser.Peek2()
    3919	    if (token and token2 and token.code == tokens.ID and token2.code == tokens["OP_:"]) then
    1087	      table.insert(list, Grammar.DeclareVar())
    1087	      Grammar.LineEnd()
        	    else
        	      break
        	    end
        	  end
*******0	  while (true) do
    6470	    local token = Parser.Peek()
    6470	    if (token and
    6470	        token.code == tokens.ID or
    4013	        token.code == tokens.K_IF or
    3519	        token.code == tokens.K_WHILE or
    3387	        token.code == tokens.K_RETURN) then
    3872	      table.insert(list, Grammar.Command() or {}) -- RETIRAR OPCAO {}
    3638	      Grammar.LineEnd()
        	    else
        	      break
        	    end
        	  end
    2598	  return list
        	end
        	
        	--Call:
        	--  syntax:
        	--    chamada   → ID '(' listaexp ')'
        	--  parameters:
        	--  return:
        	--    [1] $table  - CALL node
      18	function Grammar.Call ()
     396	  if (_DEBUG) then print("LAN :: Grammar_chamada") end
        	  local name, line, exps
     396	  name, line = Match(tokens.ID)
     396	  Match(tokens["OP_("])
     396	  exps = Grammar.ListExpressions()
     378	  Match(tokens["OP_)"])
     378	  return ASTClass.NewCallNode(line, name, exps)
        	end
        	
        	--CmdAttrib:
        	--  syntax:
        	--    cmdatrib  → var '=' exp
        	--  parameters:
        	--  return:
        	--    [1] $table  - ATTRIBUTION node
      18	function Grammar.CmdAttrib ()
    2125	  if (_DEBUG) then print("LAN :: Grammar_cmdatrib") end
        	  local var, expression
    2125	  var = Grammar.Var()
    2125	  Match(tokens["OP_="])
    2107	  expression = Grammar.Expression()
    2107	  return ASTClass.NewAttributionNode(var, expression)
        	end
        	
        	--CmdIf:
        	--  syntax:
        	--    cmdif     → 'if' exp nl
        	--                    bloco
        	--                { 'else' 'if' exp nl
        	--                    bloco
        	--                }
        	--                [ 'else' nl
        	--                    bloco
        	--                ]
        	--                'end'
      18	function Grammar.CmdIf ()
     494	  if (_DEBUG) then print("LAN :: Grammar_cmdif") end
        	  local line, condition, block, else_block
     494	  local elseif_nodes = {}
     494	  _, line = Match(tokens.K_IF)
     494	  condition = Grammar.Expression()
     422	  Grammar.LineEnd()
     404	  block = Grammar.Block()
*******0	  while (true) do
     542	    local token = Parser.Peek()
     542	    local token2 = Parser.Peek2()
     542	    if (token and token2 and token.code == tokens.K_ELSE and token2.code == tokens.K_IF) then
        	      local line, condition, block
     192	      _, line = Match(tokens.K_ELSE)
     192	      Match(tokens.K_IF)
     192	      condition = Grammar.Expression()
     156	      Grammar.LineEnd()
     156	      block = Grammar.Block()
     156	      table.insert(elseif_nodes, ASTClass.NewElseIfNode(line, condition, block))
        	    else
        	      break
        	    end
        	  end
     350	  local token = Parser.Peek()
     350	  if (token and token.code == tokens.K_ELSE) then
     162	    Match(tokens.K_ELSE)
     162	    Grammar.LineEnd()
     162	    else_block = Grammar.Block()
        	  end
     350	  Match(tokens.K_END)
     350	  return ASTClass.NewIfNode(line, condition, block, elseif_nodes, else_block)
        	end
        	
        	--CmdReturn:
        	--  syntax:
        	--    cmdreturn → 'return' exp | 'return'
        	--  parameters:
        	--  return:
        	--    [1] $table  - RETURN node
      18	function Grammar.CmdReturn ()
     789	  if (_DEBUG) then print("LAN :: Grammar_cmdreturn") end
        	  local line, exp
     789	  _, line = Match(tokens.K_RETURN)
     789	  local token = Parser.Peek()
     789	  if (token and token.code ~= tokens.LINE_END) then
     727	    exp = Grammar.Expression()
        	  end
     789	  return ASTClass.NewReturnNode(line, exp)
        	end
        	
        	--CmdWhile:
        	--  syntax:
        	--    cmdwhile  → 'while' exp nl
        	--                    bloco
        	--                'loop'
        	--  parameters:
        	--  return:
        	--    [1] $table  - WHILE node
      18	function Grammar.CmdWhile ()
     132	  if (_DEBUG) then print("LAN :: Grammar_cmdwhile") end
        	  local line, exp, block
     132	  _, line = Match(tokens.K_WHILE)
     132	  exp = Grammar.Expression()
     132	  Grammar.LineEnd()
     132	  block = Grammar.Block()
     114	  Match(tokens.K_LOOP)
      96	  return ASTClass.NewWhileNode(line, exp, block)
        	end
        	
        	--Command:
        	--  syntax:
        	--    comando   → cmdif | cmdwhile | cmdatrib | cmdreturn | chamada
        	--  parameters:
        	--  return:
        	--    [1] $table - List of DECLARE, CMDATRIB, CMDIF, CMDRETURN, CMDWHILE, [...] nodes
      18	function Grammar.Command ()
    3872	  if (_DEBUG) then print("LAN :: Grammar_comando") end
    3872	  local token = Parser.Peek()
    3872	  if (token and token.code == tokens.K_IF) then
     494	    return Grammar.CmdIf()
    3378	  elseif (token and token.code == tokens.K_WHILE) then
     132	    return Grammar.CmdWhile()
    3246	  elseif (token and token.code == tokens.K_RETURN) then
     789	    return Grammar.CmdReturn()
    2457	  elseif (token and token.code == tokens.ID) then
    2457	    local token2 = Parser.Peek2()
    2457	    if (token2 and token2.code == tokens["OP_("]) then
     314	      return Grammar.Call()
    2143	    elseif (token2 and 
    2143	            token2.code == tokens["OP_="] or
     181	            token2.code == tokens["OP_["]) then
    2125	      return Grammar.CmdAttrib()
        	    else
      18	      Error(token and token.line or 0)
        	    end
        	  else
*******0	    Error(token and token.line or 0)
        	  end
        	end
        	
        	--Declare:
        	--  syntax:
        	--    decl      → funcao | global
        	--  parameters:
        	--  return:
        	--    [1] $table  - DECLARE or FUNCTION node
      18	function Grammar.Declare ()
    2615	  if (_DEBUG) then print("LAN :: Grammar_decl") end
        	  local decl
    2615	  local token = Parser.Peek()
    2615	  if (token and token.code == tokens.K_FUN) then
    2086	    decl = Grammar.Function(parent_node)
     529	  elseif (token and token.code == tokens.ID) then
     529	    decl = Grammar.Global(parent_node)
        	  else
*******0	    Error(token and token.line or 0)
        	  end
    2237	  return decl
        	end
        	
        	--DeclareVar:
        	--  syntax:
        	--    declvar   → ID ':' tipo
        	--  parameters:
        	--  return:
        	--    [1] $table  - DECLARE node
      18	function Grammar.DeclareVar ()
    1616	  if (_DEBUG) then print("LAN :: Grammar_declvar") end
        	  local name, line, typebase, array
    1616	  name, line = Match(tokens.ID)
    1616	  Match(tokens["OP_:"])
    1598	  typebase, array = Grammar.Type()
    1562	  return ASTClass.NewDeclVarNode(line, name, typebase, array)
        	end
        	
        	--Expression:
        	--  syntax:
        	--    exp       → LITNUMERAL
        	--              | LITSTRING
        	--              | TRUE
        	--              | FALSE
        	--              | var
        	--              | 'new' '[' exp ']' tipo
        	--              | '(' exp ')'
        	--              | chamada
        	--              | exp '+' exp
        	--              | exp '-' exp
        	--              | exp '*' exp
        	--              | exp '/' exp
        	--              | exp '>' exp
        	--              | exp '<' exp
        	--              | exp '>=' exp
        	--              | exp '<=' exp
        	--              | exp '=' exp
        	--              | exp '<>' exp
        	--              | exp 'and' exp
        	--              | exp 'or' exp
        	--              | 'not' exp
        	--              | '-' exp
      18	function Grammar.Expression ()
    4979	  if (_DEBUG) then print("LAN :: Grammar_exp") end
    4979	  local exp = Grammar.ExpressionLevel1()
    4835	  if (not exp) then
     166	    Error(0)
        	  end
    4669	  return exp
        	end
        	
      18	function Grammar.ExpressionLevel1 ()
    5123	  local left = Grammar.ExpressionLevel2()
    4979	  local token = Parser.Peek()
    4979	  if (token and token.code == tokens.K_OR) then
     144	    Match(tokens.K_OR)
     144	    return ASTClass.NewOperatorNode(token.line, left, "or", Grammar.ExpressionLevel1())
        	  end
    4835	  return left
        	end
        	
      18	function Grammar.ExpressionLevel2 ()
    5315	  local left = Grammar.ExpressionLevel3()
    5171	  local token = Parser.Peek()
    5171	  if (token and token.code == tokens.K_AND) then
     192	    Match(tokens.K_AND)
     192	    return ASTClass.NewOperatorNode(token.line, left, "and", Grammar.ExpressionLevel2())
        	  end
    4979	  return left
        	end
        	
      18	function Grammar.ExpressionLevel3 ()
    5845	  local left = Grammar.ExpressionLevel4()
    5701	  local token = Parser.Peek()
    5701	  if (token and token.code == tokens["OP_="]) then
     404	    Match(tokens["OP_="])
     404	    return ASTClass.NewOperatorNode(token.line, left, "=", Grammar.ExpressionLevel3())
    5297	  elseif (token and token.code == tokens["OP_<>"]) then
     126	    Match(tokens["OP_<>"])
     126	    return ASTClass.NewOperatorNode(token.line, left, "<>", Grammar.ExpressionLevel3())
        	  end
    5171	  return left
        	end
        	
      18	function Grammar.ExpressionLevel4 ()
    6325	  local left = Grammar.ExpressionLevel5()
    6181	  local token = Parser.Peek()
    6181	  if (token and token.code == tokens["OP_>"]) then
     150	    Match(tokens["OP_>"])
     150	    return ASTClass.NewOperatorNode(token.line, left, ">", Grammar.ExpressionLevel4())
    6031	  elseif (token and token.code == tokens["OP_<"]) then
     236	    Match(tokens["OP_<"])
     236	    return ASTClass.NewOperatorNode(token.line, left, "<", Grammar.ExpressionLevel4())
    5795	  elseif (token and token.code == tokens["OP_>="]) then
      20	    Match(tokens["OP_>="])
      20	    return ASTClass.NewOperatorNode(token.line, left, ">=", Grammar.ExpressionLevel4())
    5775	  elseif (token and token.code == tokens["OP_<="]) then
      74	    Match(tokens["OP_<="])
      74	    return ASTClass.NewOperatorNode(token.line, left, "<=", Grammar.ExpressionLevel4())
        	  end
    5701	  return left
        	end
        	
      18	function Grammar.ExpressionLevel5 ()
    6837	  local left = Grammar.ExpressionLevel6()
    6693	  local token = Parser.Peek()
    6693	  if (token and token.code == tokens["OP_+"]) then
     373	    Match(tokens["OP_+"])
     373	    return ASTClass.NewOperatorNode(token.line, left, "+", Grammar.ExpressionLevel5())
    6320	  elseif (token and token.code == tokens["OP_-"]) then
     139	    Match(tokens["OP_-"])
     139	    return ASTClass.NewOperatorNode(token.line, left, "-", Grammar.ExpressionLevel5())
        	  end
    6181	  return left
        	end
        	
      18	function Grammar.ExpressionLevel6 ()
    7113	  local left = Grammar.ExpressionLevel7()
    6969	  local token = Parser.Peek()
    6969	  if (token and token.code == tokens["OP_*"]) then
     183	    Match(tokens["OP_*"])
     183	    return ASTClass.NewOperatorNode(token.line, left, "*", Grammar.ExpressionLevel6())
    6786	  elseif (token and token.code == tokens["OP_/"]) then
      93	    Match(tokens["OP_/"])
      93	    return ASTClass.NewOperatorNode(token.line, left, "/", Grammar.ExpressionLevel6())
        	  end
    6693	  return left
        	end
        	
      18	function Grammar.ExpressionLevel7 ()
    7483	  local token = Parser.Peek()
    7483	  if (token and token.code == tokens.NUMBER) then
    2344	    return ASTClass.NewLiteralNode(token.line, "int", Match(tokens.NUMBER))
    5139	  elseif (token and token.code == tokens.STRING) then
     132	    return ASTClass.NewLiteralNode(token.line, "string", Match(tokens.STRING))
    5007	  elseif (token and token.code == tokens.K_TRUE) then
     230	    return ASTClass.NewLiteralNode(token.line, "bool", Match(tokens.K_TRUE))
    4777	  elseif (token and token.code == tokens.K_FALSE) then
     152	    return ASTClass.NewLiteralNode(token.line, "bool", Match(tokens.K_FALSE))
    4625	  elseif (token and token.code == tokens.K_NEW) then
     146	    Match(tokens.K_NEW)
     146	    Match(tokens["OP_["])
     146	    local exp = Grammar.Expression()
     146	    Match(tokens["OP_]"])
     146	    local typebase, dimension = Grammar.Type()
     146	    return ASTClass.NewNewVarNode(token.line, exp, typebase, dimension)
    4479	  elseif (token and token.code == tokens.K_NOT) then
     229	    Match(tokens.K_NOT)
     229	    local exp = Grammar.ExpressionLevel7()
     229	    return ASTClass.NewNegateNode(token.line, exp)
    4250	  elseif (token and token.code == tokens.ID) then
        	    local node
    3655	    local token2 = Parser.Peek2()
    3655	    if (token2 and token2.code == tokens["OP_("]) then
      82	      return Grammar.Call()
        	    else
    3573	      return Grammar.Var()
        	    end
     595	  elseif (token and token.code == tokens["OP_("]) then
     328	    Match(tokens["OP_("])
     328	    local exp = Grammar.Expression()
     310	    Match(tokens["OP_)"])
     310	    return exp
     267	  elseif (token and token.code == tokens["OP_-"]) then
     141	    Match(tokens["OP_-"])
     141	    return ASTClass.NewUnaryNode(token.line, Grammar.ExpressionLevel7())
        	  else
     126	    Error(token and token.line or 0)
        	  end
        	end
        	
        	--Function:
        	--  syntax:
        	--    funcao    → 'fun' ID '(' params ')' [ ':' tipo ] nl
        	--                    bloco
        	--                'end' nl
        	--  parameters:
        	--  return:
        	--    [1] $table  - FUNCTION node
      18	function Grammar.Function ()
    2086	  if (_DEBUG) then print("LAN :: Grammar_funcao") end
        	  local name, line, params, ret_type, array_size, block
    2086	  Match(tokens.K_FUN)
    2086	  name, line = Match(tokens.ID)
    2050	  Match(tokens["OP_("])
    2050	  params = Grammar.Parameters()
    1996	  Match(tokens["OP_)"])
    1996	  local token = Parser.Peek()
    1996	  if (token and token.code == tokens["OP_:"]) then
     975	    Match(tokens["OP_:"])
     975	    ret_type, array_size = Grammar.Type()
        	  end
    1996	  Grammar.LineEnd()
    1996	  block = Grammar.Block()
    1780	  Match(tokens.K_END)
    1780	  Grammar.LineEnd()
    1780	  return ASTClass.NewFunctionNode(line, name, params, ret_type, array_size, block)
        	end
        	
        	--Global:
        	--  syntax:
        	--    global    → declvar nl
        	--  parameters:
        	--  return:
        	--    [1] $table  - DECLARE node
      18	function Grammar.Global ()
     529	  if (_DEBUG) then print("LAN :: Grammar_global") end
     529	  local node = Grammar.DeclareVar()
     475	  Grammar.LineEnd()
     457	  return node
        	end
        	
        	--ListExpressions:
        	--  syntax:
        	--    listaexp  → /*vazio*/ | exp { ',' exp }
        	--  parameters:
        	--  return:
        	--    [1] $table  - List of EXPRESSION nodes
      18	function Grammar.ListExpressions ()
     396	  if (_DEBUG) then print("LAN :: Grammar_listaexp") end
     396	  local list = {}
     396	  local token = Parser.Peek()
     396	  if (token and token.code ~= tokens["OP_)"]) then
     295	    table.insert(list, Grammar.Expression())
*******0	    while (true) do
     429	      token = Parser.Peek()
     429	      if (token and token.code == tokens["OP_,"]) then
     152	        Match(tokens["OP_,"])
     152	        table.insert(list, Grammar.Expression())
        	      else
        	        break
        	      end
        	    end
        	  end
     378	  return list
        	end
        	
        	--LineEnd:
        	--  syntax:
        	--    nl        → NL { NL }
      18	function Grammar.LineEnd()
   10941	  if (_DEBUG) then print("LAN :: Grammar_nl") end
   10941	  Match(tokens.LINE_END)
*******0	  while (true) do
   10977	    local token = Parser.Peek()
   10977	    if (token and token.code == tokens.LINE_END) then
      90	      Match(tokens.LINE_END)
        	    else
        	      break
        	    end
        	  end
        	end
        	
        	--Parameter:
        	--  syntax:
        	--    parametro → ID ':' tipo
        	--  parameters:
        	--  return:
        	--    [1] $table  - PARAMETER node
      18	function Grammar.Parameter ()
     892	  if (_DEBUG) then print("LAN :: Grammar_parametro") end
        	  local name, line, typebase, array_size
     892	  name, line = Match(tokens.ID)
     856	  Match(tokens["OP_:"])
     838	  typebase, array_size = Grammar.Type()
     838	  return ASTClass.NewParameterNode(line, name, typebase, array_size)
        	end
        	
        	--Parameters:
        	--  syntax:
        	--    params    → /*vazio*/ | parametro { ',' parametro }
        	--  parameters:
        	--  return:
        	--    [1] $table  - List of PARAMETER nodes
      18	function Grammar.Parameters ()
    2050	  if (_DEBUG) then print("LAN :: Grammar_params") end
    2050	  local list = {}
    2050	  local token = Parser.Peek()
    2050	  if (token and token.code ~= tokens["OP_)"]) then
     699	    table.insert(list, Grammar.Parameter())
*******0	    while (true) do
     838	      token = Parser.Peek()
     838	      if (token and token.code == tokens["OP_,"]) then
     193	        Match(tokens["OP_,"])
     193	        table.insert(list, Grammar.Parameter())
        	      else
        	        break
        	      end
        	    end
        	  end
    1996	  return list
        	end
        	
        	--Program:
        	--  syntax:
        	--    programa  → { NL } decl { decl }
      18	function Grammar.Program ()
    1822	  if (_DEBUG) then print("LAN :: Grammar_programa") end
    1822	  local node = {}
    1822	  local token = Parser.Peek()
    1822	  if (token and token.code == tokens.LINE_END) then
    1093	    Grammar.LineEnd()
        	  end
    1822	  token = Parser.Peek()
    1822	  if (token and (token.code == tokens.K_FUN or token.code == tokens.ID)) then
    1736	    table.insert(node, Grammar.Declare())
      14	    while (true) do
    2235	      token = Parser.Peek()
    2184	      if (token) then
     913	        table.insert(node, Grammar.Declare())
        	      else
      23	        break
        	      end
        	    end
        	  else
      85	    Error(token and token.line or 0)
        	  end
    1328	  ASTClass.NewProgramNode(node)
        	end
        	
        	--Type:
        	--  syntax:
        	--    tipo      → tipobase | '[' ']' tipo
        	--  parameters:
        	--  return:
        	--    [1] $typebase
        	--    [2] $array_size
      17	function Grammar.Type (array_size)
    4872	  if (_DEBUG) then print("LAN :: Grammar_tipo") end
    4873	  array_size = array_size or 0
        	  local typebase
    4974	  local token = Parser.Peek()
    4974	  if (token and
    4974	      token.code == tokens.K_INT or
    2969	      token.code == tokens.K_BOOL or
    2235	      token.code == tokens.K_CHAR or
    1682	      token.code == tokens.K_STRING) then
    3457	    typebase = Grammar.Typebase()
    1454	  elseif (token and token.code == tokens["OP_["]) then
    1487	    Match(tokens["OP_["])
    1419	    Match(tokens["OP_]"])
    1417	    array_size = array_size + 1
    1417	    typebase, array_size = Grammar.Type(array_size)
        	  else
      49	    Error(token and token.line or 0)
        	  end
    4840	  return typebase, array_size
        	end
        	
        	--Typebase:
        	--  syntax:
        	--    tipobase  → 'int' | 'bool' | 'char' | 'string'
        	--  parameters:
        	--  return:
        	--    [1] $typebase
      17	function Grammar.Typebase ()
    3436	  if (_DEBUG) then print("LAN :: Grammar_tipobase") end
    3437	  local token = Parser.Peek()
    3521	  if (token and token.code == tokens.K_INT) then
    2090	    Match(tokens.K_INT)
    2090	    return "int"
    1499	  elseif (token and token.code == tokens.K_BOOL) then
     802	    Match(tokens.K_BOOL)
     751	    return "bool"
     710	  elseif (token and token.code == tokens.K_CHAR) then
     498	    Match(tokens.K_CHAR)
     489	    return "char"
     215	  elseif (token and token.code == tokens.K_STRING) then
     215	    Match(tokens.K_STRING)
     213	    return "string"
        	  else
       1	    Error(token and token.line or 0)
        	  end
        	end
        	
        	--Var:
        	--  syntax:
        	--    var       → ID | var '[' exp ']'
        	--  parameters:
        	--  return:
        	--    [1] $table - VAR node
      17	function Grammar.Var ()
    5482	  if (_DEBUG) then print("LAN :: Grammar_var") end
        	  local name, line
    5698	  local array = {}
    5698	  name, line = Match(tokens.ID)
     216	  while (true) do
    6096	    local token = Parser.Peek()
    5880	    if (token and token.code == tokens["OP_["]) then
     622	      Match(tokens["OP_["])
     622	      table.insert(array, Grammar.Expression())
     406	      Match(tokens["OP_]"])
        	    else
       8	      break
        	    end
        	  end
    5482	  return ASTClass.NewVarNode(line, name, array)
        	end
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
      17	function Language.Start (func_advance, func_peek, func_peek2)
    1766	  if (_DEBUG) then print("LAN :: Start") end
    1767	  assert(type(func_advance) == "function")
    1822	  assert(type(func_peek) == "function")
    1822	  assert(type(func_peek2) == "function")
    1822	  Parser.Advance = func_advance
    1822	  Parser.Peek = func_peek
    1822	  Parser.Peek2 = func_peek2
    3588	  local ok, msg = pcall(function () Grammar.Program() end)
    1822	  if (not ok) then
     554	    return false, msg
        	  end
    1350	  return true
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      17	return Language
        	
        	
        	--==============================================================================
        	-- Grammar
        	--==============================================================================
        	
        	-- programa  → { NL } decl { decl }
        	--
        	-- decl      → funcao | global
        	--
        	-- nl        → NL { NL }
        	--
        	-- global    → declvar nl
        	--
        	-- funcao    → 'fun' ID '(' params ')' [ ':' tipo ] nl
        	--                bloco
        	--             'end' nl
        	--
        	-- bloco     → { declvar nl }
        	--             { comando nl }
        	--
        	-- params    → /*vazio*/ | parametro { ',' parametro }
        	--
        	-- parametro → ID ':' tipo
        	--
        	-- tipo      → tipobase | '[' ']' tipo
        	--
        	-- tipobase  → 'int' | 'bool' | 'char' | 'string'
        	--
        	-- declvar   → ID ':' tipo
        	--
        	-- comando   → cmdif | cmdwhile | cmdatrib | cmdreturn | chamada 
        	--
        	-- cmdif     → 'if' exp nl
        	--                bloco
        	--             { 'else' 'if' exp nl
        	--                bloco
        	--             }
        	--             [ 'else' nl
        	--                bloco
        	--             ]
        	--             'end'
        	--
        	-- cmdwhile  → 'while' exp nl
        	--                bloco
        	--             'loop'
        	--
        	-- cmdatrib  → var '=' exp
        	--
        	-- chamada   → ID '(' listaexp ')'
        	--
        	-- listaexp  → /*vazio*/ | exp { ',' exp }
        	--
        	-- cmdreturn → 'return' exp | 'return'
        	--
        	-- var       → ID | var '[' exp ']'
        	--
        	-- exp       → LITNUMERAL
        	--           | LITSTRING
        	--           | TRUE
        	--           | FALSE
        	--           | var
        	--           | 'new' '[' exp ']' tipo
        	--           | '(' exp ')'
        	--           | chamada
        	--           | exp '+' exp
        	--           | exp '-' exp
        	--           | exp '*' exp
        	--           | exp '/' exp
        	--           | exp '>' exp
        	--           | exp '<' exp
        	--           | exp '>=' exp
        	--           | exp '<=' exp
        	--           | exp '=' exp
        	--           | exp '<>' exp
        	--           | exp 'and' exp
        	--           | exp 'or' exp
        	--           | 'not' exp
        	--           | '-' exp

==============================================================================
./src/intermediate_code.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
       2	local printStruct = false
       2	local _DEBUG = true
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
       2	local NodesClass = require "lib/node_codes"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
       2	local InterCodeGen = {}
        	
        	--  store file path
        	local file
        	
        	--  count number of generated labels
       2	local label_counter = 0
        	
        	--  count number of generated variables
       2	local var_counter = 0
        	
       2	local function_counter = 0
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
       2	local nodes_codes = NodesClass.GetNodesList()
        	
        	-- avaiable operator codes of intermediate language
       2	local enum_opcodes = {
       2	  ["LABEL"]         = 01,
       2	  ["RETURN"]        = 02,
       2	  ["ID=rval"]       = 03,
       2	  ["ID=BYTErval"]   = 04,
       2	  ["ID=unoprval"]   = 05,
       2	  ["ID=rvalEQrval"] = 06,
       2	  ["IFFALSEGOTO"]   = 07,
       2	  ["GOTO"]          = 08,
        	}
        	
        	--  three address codes
        	--  {
        	--    strings   = {
        	--      [1 to N] = {
        	--        var = $string   - variable name
        	--        str = $string   - literal string
        	--      }
        	--    }
        	--    globals   = {
        	--      [1 to N] = "name"
        	--    }
        	--    functions = {
        	--      [1 to N] = {      - list of functions
        	--        [1 to N] = {    - list of instructions
        	--        }
        	--      }
        	--    }
        	--  }
       2	local struct = {}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	--AddInstruction:
        	--  Parameters:
        	--    [1] $table  - Table created by 'NewInstruction' function
        	--  Return:
       2	function InterCodeGen.AddInstruction (inst)
     904	  if (_DEBUG) then print("ICG :: AddInstruction") end
     904	  assert (inst and type(inst) == "table")
     904	  table.insert(struct.functions[function_counter], inst)
        	end
        	
        	--Clear: Set Initial Condition
        	--  Parameters:
        	--  Return:
       2	function InterCodeGen.Clear ()
     174	  if (_DEBUG) then print("ICG :: Clear") end
     174	  struct = {
     174	    strings   = {},
     174	    globals   = {},
     174	    functions = {},
     174	  }
     174	  var_counter = 0
     174	  label_counter = 0
     174	  function_counter = 0
        	end
        	
        	--Dump: Write struct to file
        	--  Parameters:
        	--    [1] $string   - complete file path
        	--  Return:
       2	function InterCodeGen.Dump (output)
     174	  util.TablePrint(struct)
     174	  if (_DEBUG) then print("ICG :: Dump") end
     180	  for _, str_node in ipairs(struct.strings) do
       6	    output:write(string.format('%8s STRING  %s = "%s"\n', "", str_node.var, str_node.str))
        	  end
     234	  for _, name in ipairs(struct.globals) do
      60	    output:write(string.format('%8s GLOBAL %s\n', "", name))
        	  end
     304	  for _, func in ipairs(struct.functions) do
     192	    output:write(func.header)
     618	    for _, inst in ipairs(func) do
     488	      InterCodeGen.DumpInstruction(output, inst)
        	    end
        	  end
        	end
        	
        	--DumpInstruction:
        	--  Parameters:
        	--    [1] $       - Desired output
        	--    [2] $table  - Table created by 'AddInstruction' function
        	--  Return:
       2	function InterCodeGen.DumpInstruction (output, inst)
     488	  if ((inst.code == enum_opcodes["LABEL"])) then
      28	    output:write(string.format('%14s\n', inst.label and ("LABEL: " .. inst.label) or ""))
     460	  elseif (inst.code == enum_opcodes["RETURN"]) then
     102	    output:write(string.format('%14s   RET %s\n', inst.label and ("LABEL: " .. inst.label) or "", inst.op1 or ""))
     358	  elseif (inst.code == enum_opcodes["ID=rval"]) then
     182	    output:write(string.format('%14s   %s = %s\n', inst.label and ("LABEL: " .. inst.label) or "", inst.op1, inst.op2))
     176	  elseif (inst.code == enum_opcodes["ID=BYTErval"]) then
     132	    output:write(string.format('%14s   %s = BYTE %s\n', inst.label and ("LABEL: " .. inst.label) or "", inst.op1, inst.op2))
      44	  elseif (inst.code == enum_opcodes["ID=unoprval"]) then
       2	    output:write(string.format('%14s   %s = %s %s\n', inst.label and ("LABEL: " .. inst.label) or "", inst.op1, inst.op2, inst.op3))
      42	  elseif (inst.code == enum_opcodes["ID=rvalEQrval"]) then
       2	    output:write(string.format('%14s   %s = %s == %s\n', inst.label and ("LABEL: " .. inst.label) or "", inst.op1, inst.op2, inst.op3))
      40	  elseif (inst.code == enum_opcodes["IFFALSEGOTO"]) then
      26	    output:write(string.format('%14s   IFFALSE %s GOTO %s\n', inst.label and ("LABEL: " .. inst.label) or "", inst.op1, inst.op2))
      14	  elseif (inst.code == enum_opcodes["GOTO"]) then
      14	    output:write(string.format('%14s   GOTO %s\n', inst.label and ("LABEL: " .. inst.label) or "", inst.op1))
        	  end
        	end
        	
        	--Error:
        	--  Parameters:
        	--    [1] $string - 
        	--  Return:
       2	function InterCodeGen.Error (msg)
*******0	  local str = string.format("intermediate code generator error: %s", msg or "")
*******0	  error(str, 0)
        	end
        	
        	--GenAttribution:
        	--  Parameters:
        	--    [1] $table  - 
        	--  Return:
       2	function InterCodeGen.GenAttribution (node)
     262	  if (_DEBUG) then print("ICG :: GenAttribution") end
     262	  assert(node.id == nodes_codes["ATTRIBUTION"])
     262	  if ((node.var.sem_type == "char" or node.var.sem_type == "bool") and (node.var.sem_dimension == 0)) then
     118	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=BYTErval", node.var.name, InterCodeGen.GenExpression(node.exp)))
        	  else
     144	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=rval", node.var.name, InterCodeGen.GenExpression(node.exp)))
        	  end
        	end
        	
        	--GenBlock:
        	--  Parameters:
        	--    [1] $table  - 
        	--  Return:
       2	function InterCodeGen.GenBlock (block)
     292	  if (_DEBUG) then print("ICG :: GenBlock") end
     950	  for _, node in ipairs(block) do
     658	    if (node.id == nodes_codes["ATTRIBUTION"]) then
     262	      InterCodeGen.GenAttribution(node)
     396	    elseif (node.id == nodes_codes["CALL"]) then
      18	      InterCodeGen.GenCall(node)
     378	    elseif (node.id == nodes_codes["DECLARE"]) then
     188	      InterCodeGen.GenDeclare(node)
     190	    elseif (node.id == nodes_codes["IF"]) then
      34	      InterCodeGen.GenIf(node)
     156	    elseif (node.id == nodes_codes["RETURN"]) then
     140	      InterCodeGen.GenReturn(node)
      16	    elseif (node.id == nodes_codes["WHILE"]) then
      16	      InterCodeGen.GenWhile(node)
        	    end
        	  end
        	end
        	
        	--GenCall: 
        	--  Parameters:
        	--    [1] $table  - 
        	--  Return:
       2	function InterCodeGen.GenCall (node)
      18	  if (_DEBUG) then print("ICG :: GenCall") end
      18	  assert(node.id == nodes_codes["CALL"])
        	  -- COMPLETE
        	end
        	
        	--GenDeclare: Create a new instruction and add it to current function
        	--  Parameters:
        	--    [1] $table  - 
        	--  Return:
       2	function InterCodeGen.GenDeclare (node)
     188	  if (_DEBUG) then print("ICG :: GenDeclare") end
     188	  assert(node.id == nodes_codes["DECLARE"])
        	  local op
     188	  if ((node.type == "bool" or node.type == "char") and node.dimension == 0) then
      64	    op = "ID=BYTErval"
        	  else
     124	    op = "ID=rval"
        	  end
     188	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, op, node.name, "0"))
        	end
        	
        	--GenExpression:
        	--  Parameters:
        	--    [1] $table  - 
        	--  Return:
        	--    [1] $string - Variable or value of expression return
       2	function InterCodeGen.GenExpression (node)
     490	  if (node.id == nodes_codes["CALL"]) then
       2	    return InterCodeGen.GenExpressionCall(node)
     488	  elseif (node.id == nodes_codes["LITERAL"]) then
     110	    return InterCodeGen.GenExpressionLiteral(node)
     378	  elseif (node.id == nodes_codes["NEGATE"]) then
      14	    return InterCodeGen.GenExpressionNegate(node)
     364	  elseif (node.id == nodes_codes["NEWVAR"]) then
      26	    return InterCodeGen.GenExpressionNewVar(node)
     338	  elseif (node.id == nodes_codes["OPERATOR"]) then
     166	    return InterCodeGen.GenExpressionOperator(node)
     172	  elseif (node.id == nodes_codes["UNARY"]) then
      14	    return InterCodeGen.GenExpressionUnary(node)
     158	  elseif (node.id == nodes_codes["VAR"]) then
     158	    return InterCodeGen.GenExpressionVar(node)
        	  end
        	end
        	
       2	function InterCodeGen.GenExpressionCall (node)
        	  -- COMPLETE
        	end
        	
       2	function InterCodeGen.GenExpressionLiteral (node)
        	  local op
     110	  if (node.type == "char") then
       6	    op = InterCodeGen.GetVariable()
       6	    local t = {
       6	      var = op,
       6	      str = node.value,
        	    }
       6	    table.insert(struct.strings, t)
     104	  elseif (node.type == "bool") then
      54	    op = (node.value == "true" and "1") or "0"
        	  else
      50	    op = node.value
        	  end
     110	  return op
        	end
        	
       2	function InterCodeGen.GenExpressionNegate (node)
      14	  local op = InterCodeGen.GetVariable()
      14	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=rvalEQrval", op, InterCodeGen.GenExpression(node.exp), "0"))
      14	  return op
        	end
        	
       2	function InterCodeGen.GenExpressionNewVar (node)
        	  -- COMPLETE
        	end
        	
       2	function InterCodeGen.GenExpressionOperator (node)
        	  --[and or + - * / > < >= <= = <>]
        	  -- COMPLETE
        	end
        	
       2	function InterCodeGen.GenExpressionUnary (node)
      14	  local op = InterCodeGen.GetVariable()
      14	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=unoprval", op, "-", InterCodeGen.GenExpression(node.exp)))
      14	  return op
        	end
        	
       2	function InterCodeGen.GenExpressionVar (node)
        	  -- COMPLETE
        	  -- verify dimension
        	end
        	
        	--GenFunction: 
        	--  Parameters:
        	--    [1] $table  - 
        	--  Return:
       2	function InterCodeGen.GenFunction (node)
     208	  if (_DEBUG) then print("ICG :: GenFunction") end
     208	  assert(node.id == nodes_codes["FUNCTION"])
     208	  function_counter = function_counter + 1
     208	  local header = string.format("%8s FUN %s (", "", node.name)
     208	  if (node.params and node.params[1]) then
      70	    header = header .. node.params[1].name
        	  end
     208	  if (node.params and #node.params > 1) then
      30	    for i = 2, #node.params do
      18	      header = header .. "," .. node.params[i].name
        	    end
        	  end
     208	  header = header .. ")\n"
     208	  struct.functions[function_counter] = {
     208	    header = header,
     208	  }
     208	  InterCodeGen.GenBlock(node.block)
        	end
        	
        	--GenGlobal:
        	--  Parameters:
        	--    [1] $table  - 
        	--  Return:
       2	function InterCodeGen.GenGlobal (node)
      60	  if (_DEBUG) then print("ICG :: GenGlobal") end
      60	  assert(node.id == nodes_codes["DECLARE"])
      60	  table.insert(struct.globals, node.name)
        	end
        	
        	--GenIf:
        	--  Parameters:
        	--    [1] $table  - 
        	--  Return:
       2	function InterCodeGen.GenIf(node)
      34	  if (_DEBUG) then print("ICG :: GenIf") end
      34	  assert(node.id == nodes_codes["IF"])
      34	  local lbl_end       = InterCodeGen.GetLabel()
      34	  local var_condition = InterCodeGen.GetVariable()
      34	  local op = InterCodeGen.GenExpression(node.cond)
      34	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=BYTErval", var_condition, op))
      34	  if (node["elseif"] or node["else"]) then
      24	    local lbl_next = InterCodeGen.GetLabel()
      24	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFFALSEGOTO", var_condition, lbl_next))
      24	    InterCodeGen.GenBlock(node.block)
      24	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "GOTO", lbl_end))
      24	    if (node["elseif"]) then
      30	      for i = 1, #node["elseif"] do
      18	        InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(lbl_next, "LABEL"))
      18	        var_condition = InterCodeGen.GetVariable()
      18	        op = InterCodeGen.GenExpression(node["elseif"][i].cond)
      18	        InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=BYTErval", var_condition, op))
      18	        if ((#node["elseif"] - i) > 0) then
       6	          lbl_next = InterCodeGen.GetLabel()
       6	          InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFFALSEGOTO", var_condition, lbl_next))
       6	          InterCodeGen.GenBlock(node["elseif"][i].block)
       6	          InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "GOTO", lbl_end))
        	        else
      12	          if (node["else"]) then
       4	            lbl_next = InterCodeGen.GetLabel()
       4	            InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFFALSEGOTO", var_condition, lbl_next))
       4	            InterCodeGen.GenBlock(node["elseif"][i].block)
       4	            InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "GOTO", lbl_end))
        	          else
       8	            InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFFALSEGOTO", var_condition, lbl_end))
       8	            InterCodeGen.GenBlock(node["elseif"][i].block)
        	          end
        	        end
        	      end
        	    end
      24	    if (node["else"]) then
      16	      InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(lbl_next, "LABEL"))
      16	      InterCodeGen.GenBlock(node["else"])
        	    end
        	  else
      10	    InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFFALSEGOTO", var_condition, lbl_end))
      10	    InterCodeGen.GenBlock(node.block)
        	  end
      34	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(lbl_end, "LABEL"))
        	end
        	
        	--GenReturn:
        	--  Parameters:
        	--    [1] $table  - 
        	--  Return:
       2	function InterCodeGen.GenReturn (node)
     140	  if (_DEBUG) then print("ICG :: GenReturn") end
     140	  assert(node.id == nodes_codes["RETURN"])
        	  local op
     140	  if (node.exp) then
     132	    op = InterCodeGen.GenExpression(node.exp)
        	  end
     140	  local t = InterCodeGen.NewInstruction(nil, "RETURN", op)
     140	  InterCodeGen.AddInstruction(t)
        	end
        	
        	--GenWhile:
        	--  Parameters:
        	--    [1] $table  - 
        	--  Return:
       2	function InterCodeGen.GenWhile (node)
      16	  if (_DEBUG) then print("ICG :: GenWhile") end
      16	  assert(node.id == nodes_codes["WHILE"])
      16	  local lbl_before    = InterCodeGen.GetLabel()
      16	  local lbl_after     = InterCodeGen.GetLabel()
      16	  local var_condition = InterCodeGen.GetVariable()
      16	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(lbl_before, "LABEL"))
      16	  local op = InterCodeGen.GenExpression(node.cond)
      16	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "ID=BYTErval", var_condition, op))
      16	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "IFFALSEGOTO", var_condition, lbl_after))
      16	  InterCodeGen.GenBlock(node.block)
      16	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(nil, "GOTO", lbl_before))
      16	  InterCodeGen.AddInstruction(InterCodeGen.NewInstruction(lbl_after, "LABEL"))
        	end
        	
        	--GetLabel: Get a new string to use as a label
        	--  Parameters:
        	--  Return:
        	--    [1] $string   - New unique label
       2	function InterCodeGen.GetLabel ()
     100	  if (_DEBUG) then print("ICG :: GetLabel") end
     100	  label_counter = label_counter + 1
     100	  return ".L" .. label_counter
        	end
        	
        	--GetVariable: Get a new string to use as a variable
        	--  Parameters:
        	--  Return:
        	--    [1] $string   - New unique variable
       2	function InterCodeGen.GetVariable ()
     102	  if (_DEBUG) then print("ICG :: GetVariable") end
     102	  var_counter = var_counter + 1
     102	  return "$t" .. var_counter
        	end
        	
        	--NewInstruction:
        	--  Parameters:
        	--    [1] $string - 
        	--    [2] $string - 
        	--    [3] $string - 
        	--    [4] $string - 
        	--    [5] $string - 
        	--  Return:
       2	function InterCodeGen.NewInstruction (label, code, operator1, operator2, operator3)
     904	  if (_DEBUG) then print("ICG :: NewInstruction") end
     904	  assert (enum_opcodes[code])
     904	  local t = {
     904	    label = label,
     904	    code  = enum_opcodes[code],
     904	    op1   = operator1,
     904	    op2   = operator2,
     904	    op3   = operator3,
        	  }
     904	  return t
        	end
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Open:
        	--  parameters:
        	--    [1] $string   - 
        	--    [2] $table    - 
        	--  return:
        	--    [1] $boolean  - false if found any problem, true otherwise
        	--    [2] $string   - only when [1] is false, informing which error occurs
       2	function InterCodeGen.Open (path, tree)
     174	  if (_DEBUG) then print("ICG :: Open") end
     174	  assert(path)
     174	  assert(tree and type(tree) == "table")
     174	  InterCodeGen.Clear()
     348	  local ok, msg = pcall(function ()
     442	    for _, node in ipairs(tree) do
     268	      if (node.id == nodes_codes["DECLARE"]) then
      60	        InterCodeGen.GenGlobal(node)
     208	      elseif (node.id == nodes_codes["FUNCTION"]) then
     208	        InterCodeGen.GenFunction(node)
        	      else
*******0	        InterCodeGen.Error("unknown program node.")
        	      end
        	    end
     174	    local f = io.open(util.FileRemoveExtension(path) .. ".icg", "w")
     174	    if (not f) then
*******0	      Error(string.format("output file '%s' could not be opened"), path)
        	    end
     174	    InterCodeGen.Dump(f)
     112	    f:close()
     112	    if (printStruct) then
*******0	      util.TablePrint(struct)
        	    end
     286	  end)
     174	  if (not ok) then
      62	    return false, msg
        	  end
     112	  return true
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       2	return InterCodeGen
        	
        	
        	--[[
        	program   : strings globals functions
        	          ;
        	
        	strings   : string strings
        	          |;
        	
        	globals   : global globals
        	          |;              
        	    
        	functions : function functions
        	          |;  
        	
        	nl        : NL opt_nl ;
        	
        	opt_nl    : NL opt_nl
        	          |;
        	
        	string    : STRING ID '=' LITSTRING nl
        	
        	global    : GLOBAL ID nl
        	
        	function  : FUN ID '(' args ')' nl
        	          commands
        	          ;
        	
        	args      : arg more_args
        	          |;
        	
        	more_args : ',' args
        	          |;
        	
        	arg       : ID
        	          ;
        	
        	commands  : label command nl commands
        	          |;
        	
        	label     : LABEL ':' opt_nl label
        	          |;
        	
        	rval      : LITNUM
        	          | ID
        	          ;
        	
        	command   : ID '=' rval
        	          | ID '=' BYTE rval
        	          | ID '=' rval binop rval
        	          | ID '=' unop rval
        	          | ID '=' ID '[' rval ']'
        	          | ID '[' rval ']' '=' rval
        	          | ID '=' BYTE ID '[' rval ']'
        	          | ID '[' rval ']' '=' BYTE rval
        	          | IF ID GOTO LABEL
        	          | IFFALSE ID GOTO LABEL
        	          | GOTO LABEL
        	          | call
        	          | RET rval
        	          | RET
        	          ;
        	
        	binop     : EQ
        	          | NE
        	          | '<'
        	          | '>'
        	          | GE
        	          | LE
        	          | '+'
        	          | '-'
        	          | '*'
        	          | '/'
        	          ;
        	
        	unop      : '-'
        	          | NEW
        	          | NEW BYTE
        	          ;
        	
        	call      : params
        	          CALL ID
        	          ;
        	
        	params    : param nl params
        	          |;
        	
        	param     : PARAM rval
        	          ;
        	--]]

==============================================================================
./src/lexical.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
      18	local printTokensCapture  = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      18	local lulex       = require "lib/lulex"
      18	local TokensClass = require "lib/token_codes"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      18	local Lexical = {}
        	
        	-- number of current line
        	local line_number
        	
        	-- lexer instructions and callbacks
        	--  {
        	--    [#] = {
        	--      [1] = pattern,
        	--      [2] = function,
        	--    }
        	--  }
      18	local lexer = {}
        	
        	-- tags read in input
        	--  {
        	--    [#] = {
        	--      code  = $number,
        	--      line  = $number,
        	--      token = $string,
        	--    }
        	--  }
      18	local tags = {}
        	
        	--  list of tokens
        	--  {
        	--    [name] = $number,
        	--  }
      18	local tokens = TokensClass.GetTokensList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	local function StoreToken (code, token, line)
   58707	  if (_DEBUG) then print("LEX :: StoreToken") end
   58707	  assert(code and type(code) == "number")
   58707	  assert(token)
   58707	  assert(line and type(line) == "number")
   58707	  if (_DEBUG or printTokensCapture) then
*******0	    print(string.format("codigo: '%10s' linha: %4d token: %s", TokensClass.GetTokenName(code), line, tostring(token)))
        	  end
   58707	  local t = {
   58707	    code = code,
   58707	    line = line,
   58707	    token = token,
        	  }
   58707	  table.insert(tags, t)
        	end
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
      36	lexer = lulex.New{
      18	  { '[ \t]+',
        	    function (token)
        	    end
      18	  },
      18	  { '//[^\n]+',
        	    function (token)
        	      --StoreToken(tokens.COMMENT_LINE, token, line_number)
        	    end
      18	  },
      18	  { '/\\*([^\\*]|\\*[^/])*\\*/',
        	    function (token)
        	      --StoreToken(tokens.COMMENT_BLOCK, token, line_number)
      58	      local init = 0
     180	      while (string.find(token, "\n", init)) do
     122	        _, init = string.find(token, "\n", init)
     122	        init = init + 1
     122	        line_number = line_number + 1
        	      end
        	    end
      18	  },
      18	  { 'if',
        	    function (token)
     812	      StoreToken(tokens.K_IF, token, line_number)
        	    end
      18	  },
      18	  { 'then',
        	    function (token)
      18	      StoreToken(tokens.K_THEN, token, line_number)
        	    end
      18	  },
      18	  { 'else',
        	    function (token)
     516	      StoreToken(tokens.K_ELSE, token, line_number)
        	    end
      18	  },
      18	  { 'while',
        	    function (token)
     132	      StoreToken(tokens.K_WHILE, token, line_number)
        	    end
      18	  },
      18	  { 'loop',
        	    function (token)
     132	      StoreToken(tokens.K_LOOP, token, line_number)
        	    end
      18	  },
      18	  { 'fun',
        	    function (token)
    2104	      StoreToken(tokens.K_FUN, token, line_number)
        	    end
      18	  },
      18	  { 'return',
        	    function (token)
     879	      StoreToken(tokens.K_RETURN, token, line_number)
        	    end
      18	  },
      18	  { 'new',
        	    function (token)
     164	      StoreToken(tokens.K_NEW, token, line_number)
        	    end
      18	  },
      18	  { 'string',
        	    function (token)
     231	      StoreToken(tokens.K_STRING, token, line_number)
        	    end
      18	  },
      18	  { 'int',
        	    function (token)
    2127	      StoreToken(tokens.K_INT, token, line_number)
        	    end
      18	  },
      18	  { 'char',
        	    function (token)
     506	      StoreToken(tokens.K_CHAR, token, line_number)
        	    end
      18	  },
      18	  { 'bool',
        	    function (token)
     783	      StoreToken(tokens.K_BOOL, token, line_number)
        	    end
      18	  },
      18	  { 'true',
        	    function (token)
     302	      StoreToken(tokens.K_TRUE, token, line_number)
        	    end
      18	  },
      18	  { 'false',
        	    function (token)
     224	      StoreToken(tokens.K_FALSE, token, line_number)
        	    end
      18	  },
      18	  { 'and',
        	    function (token)
     210	      StoreToken(tokens.K_AND, token, line_number)
        	    end
      18	  },
      18	  { 'or',
        	    function (token)
     180	      StoreToken(tokens.K_OR, token, line_number)
        	    end
      18	  },
      18	  { 'not',
        	    function (token)
     247	      StoreToken(tokens.K_NOT, token, line_number)
        	    end
      18	  },
      18	  { 'end',
        	    function (token)
    2670	      StoreToken(tokens.K_END, token, line_number)
        	    end
      18	  },
      18	  { '\\"([^\\"\\\\]|\\\\[nt\\\\"])*\\"',
        	    function (token)
     258	      local str = token
     258	      str = string.gsub(str, '^"', '')
     258	      str = string.gsub(str, '"$', '')
     258	      str = string.gsub(str, '\\"', '"')
     258	      str = string.gsub(str, '\\n', '\n')
     258	      str = string.gsub(str, '\\t', '\t')
     258	      str = string.gsub(str, '\\\\', '\\')
     258	      StoreToken(tokens.STRING, str, line_number)
        	    end
      18	  },
      18	  { '[0-9]+',
        	    function (token)
    2902	      StoreToken(tokens.NUMBER, token, line_number)
        	    end
      18	  },
      18	  { '0x[0-9a-fA-F]+',
        	    function (token)
      36	      StoreToken(tokens.NUMBER, tonumber(token), line_number)
        	    end
      18	  },
      18	  { '\\(',
        	    function (token)
    2936	      StoreToken(tokens["OP_("], token, line_number)
        	    end
      18	  },
      18	  { '\\)',
        	    function (token)
    2936	      StoreToken(tokens["OP_)"], token, line_number)
        	    end
      18	  },
      18	  { ',',
        	    function (token)
     399	      StoreToken(tokens["OP_,"], token, line_number)
        	    end
      18	  },
      18	  { ':',
        	    function (token)
    3483	      StoreToken(tokens["OP_:"], token, line_number)
        	    end
      18	  },
      18	  { '>',
        	    function (token)
     168	      StoreToken(tokens["OP_>"], token, line_number)
        	    end
      18	  },
      18	  { '<',
        	    function (token)
     272	      StoreToken(tokens["OP_<"], token, line_number)
        	    end
      18	  },
      18	  { '>=',
        	    function (token)
      38	      StoreToken(tokens["OP_>="], token, line_number)
        	    end
      18	  },
      18	  { '<=',
        	    function (token)
     110	      StoreToken(tokens["OP_<="], token, line_number)
        	    end
      18	  },
      18	  { '=',
        	    function (token)
    3105	      StoreToken(tokens["OP_="], token, line_number)
        	    end
      18	  },
      18	  { '<>',
        	    function (token)
     162	      StoreToken(tokens["OP_<>"], token, line_number)
        	    end
      18	  },
      18	  { '\\[',
        	    function (token)
    2005	      StoreToken(tokens["OP_["], token, line_number)
        	    end
      18	  },
      18	  { '\\]',
        	    function (token)
    2005	      StoreToken(tokens["OP_]"], token, line_number)
        	    end
      18	  },
      18	  { '\\+',
        	    function (token)
     427	      StoreToken(tokens["OP_+"], token, line_number)
        	    end
      18	  },
      18	  { '-',
        	    function (token)
     316	      StoreToken(tokens["OP_-"], token, line_number)
        	    end
      18	  },
      18	  { '\\*',
        	    function (token)
     201	      StoreToken(tokens["OP_*"], token, line_number)
        	    end
      18	  },
      18	  { '/',
        	    function (token)
     111	      StoreToken(tokens["OP_/"], token, line_number)
        	    end
      18	  },
      18	  { '[ \n]+',
        	    function (token)
   12957	      StoreToken(tokens.LINE_END, token, line_number)
   12957	      local init = 0
   27416	      while (string.find(token, "\n", init)) do
   14459	        _, init = string.find(token, "\n", init)
   14459	        init = init + 1
   14459	        line_number = line_number + 1
        	      end
        	    end
      18	  },
      18	  { '[a-zA-Z_][a-zA-Z0-9_]*',
        	    function (token)
   11575	      StoreToken(tokens.ID, token, line_number)
        	    end
      18	  },
      18	  { '.',
        	    function (token)
      68	      StoreToken(tokens.ERROR, token, line_number)
        	    end
      18	  },
      36	}
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Open:
        	--  parameters:
        	--    [1] $string  - path of file to be analysed
        	--  return:
        	--    [1] $boolean - false if found any problem, true otherwise
        	--    [2] $string  - only when [1] is false, informing which error occurs
      18	function Lexical.Open (txt)
    1839	  if (_DEBUG) then print("LEX :: Open") end
    1839	  assert(txt and type(txt) == "string")
    1839	  tags = {}
    1839	  line_number = 1
    1839	  lexer:run(txt, true)
   60308	  for _, tab in ipairs(tags) do
   58486	    if (tab.code == tokens.ERROR) then
      17	      return false, string.format("@%d lexical error: could not recognize tags.", tab.line)
        	    end
        	  end
    1822	  return true
        	end
        	
      18	function Lexical.GetTags()
    1822	  if (_DEBUG) then print("LEX :: GetTags") end
    1822	  return tags
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      18	return Lexical

==============================================================================
./src/parser.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      18	local Parser = {}
        	
        	-- store tokens list received in input
      18	local tokens_list = {}
        	
        	-- keep the number of the current token
      18	local current = 0
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--Advance:
        	--  parameters:
        	--  return:
      18	function Parser.Advance ()
   52154	  if (_DEBUG) then print("PAR :: Advance") end
   52154	  current = current + 1
        	end
        	
        	--Open: Start a new parser with current table input, erasing any previous one
        	--  parameters:
        	--    [1] $table   - table with tokens read in lexical
        	--  return:
      18	function Parser.Open (t)
    1822	  if (_DEBUG) then print("PAR :: Open") end
    1822	  assert(type(t) == "table")
    1822	  current = 0
    1822	  tokens_list = t
        	end
        	
        	--Peek: peek the next token
        	--  parameters:
        	--  return:
      18	function Parser.Peek ()
  151252	  if (_DEBUG) then print("PAR :: Peek") end
  151252	  return tokens_list[current + 1]
        	end
        	
        	--Peek2: peek the second next token
        	--  parameters:
        	--  return:
      18	function Parser.Peek2 ()
   10573	  if (_DEBUG) then print("PAR :: Peek2") end
   10573	  return tokens_list[current + 2]
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      18	return Parser

==============================================================================
./src/semantic.lua
==============================================================================
        	--==============================================================================
        	-- Considerations
        	--==============================================================================
        	
        	-- Functions sets new unreach code variable '@ret' as its return VAR variable
        	-- Functions sets PARAMETER nodes to own scope
        	-- ALLOW overcharge variable in diferent scopes
        	
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
      13	local printTree = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      18	require "lib/util"
      18	local NodesClass  = require "lib/node_codes"
      16	local PrintClass  = require "lib/util_tree"
      13	local SymbolClass = require "src/symbol_table"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      13	local Semantic = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
      13	local nodes_codes = NodesClass.GetNodesList()
        	
        	--  AST tree (structed nodes)
       2	local tree = {}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	--Error: Callback of errors that occurs during semantic analysis
        	--  Parameters:
        	--    [1] $string
        	--  Return:
        	local function Error (msg, line)
     528	  local str = string.format("@%d semantic error: %s", line or 0, msg or "")
     528	  error(str, 0)
        	end
        	
        	--VerifyAttribution: Verify integrity of ATTRIBUTION node
        	--  Parameters:
        	--    [1] $table  = ATTRIBUTION node
        	--  Return:
     152	function Semantic.VerifyAttribution (node)
     556	  if (_DEBUG) then print("SEM :: VerifyAttribution") end
     547	  assert(node.id == nodes_codes["ATTRIBUTION"])
     430	  Semantic.VerifyVar(node.var)
     523	  Semantic.VerifyExpression(node.exp)
     404	  Semantic.VerifyCompatibleTypes(node.line, node.var.sem_type, node.var.sem_dimension, node.exp.sem_type, node.exp.sem_dimension)
        	  -- MUST UPDATE SYMBOL TABLE VALUE
        	end
        	
        	--VerifyBlock: Verify integrity of BLOCK/COMMANDS nodes
        	--  Parameters:
        	--    [1] $table  = collection of ATTRIBUTION, CALL, DECLARE, IF, RETURN and WHILE nodes
        	--  Return:
     389	function Semantic.VerifyBlock (block)
    1023	  if (_DEBUG) then print("SEM :: VerifyBlock") end
    2065	  for _, node in ipairs(block or {}) do
    1538	    if (node.id == nodes_codes["ATTRIBUTION"]) then
     627	      Semantic.VerifyAttribution(node)
    1176	    elseif (node.id == nodes_codes["CALL"]) then
     131	      Semantic.VerifyCall(node)
    1090	    elseif (node.id == nodes_codes["DECLARE"]) then
     558	      Semantic.VerifyDeclare(node)
     586	    elseif (node.id == nodes_codes["IF"]) then
      73	      Semantic.VerifyIf(node)
     503	    elseif (node.id == nodes_codes["RETURN"]) then
     468	      Semantic.VerifyReturn(node)
      20	    elseif (node.id == nodes_codes["WHILE"]) then
      51	      Semantic.VerifyWhile(node)
        	    else
     262	      Error("unknown block node")
        	    end
        	  end
        	end
        	
        	--VerifyCall: Verify integrity of CALL node
        	--  Parameters:
        	--    [1] $table  = CALL node
        	--  Return:
     126	function Semantic.VerifyCall (node)
     446	  if (_DEBUG) then print("SEM :: VerifyCall") end
     983	  assert(node.id == nodes_codes["CALL"])
    1204	  local symbol = SymbolClass.GetSymbol(node.name)
     883	  if (not symbol) then
     447	    Error(string.format("symbol '%s' was not declared.", node.name), node.line)
        	  end
     392	  if (symbol.id ~= "function") then
     402	    Error(string.format("attempt to call %s '%s', which is a '%s', not a 'function'.", symbol.id, symbol.name, symbol.type), node.line)
        	  end
     388	  local num_func_params = symbol.params and #symbol.params or 0
     206	  local num_call_params = node.exps and #node.exps or 0
     292	  if (num_func_params ~= num_call_params) then
     155	    Error(string.format("attempt to call function '%s' with '%d' parameter(s), but it demands '%d'.", symbol.name, num_func_params, num_call_params), node.line)
        	  end
     250	  for i = 1, num_func_params do
     194	    Semantic.VerifyExpression(node.exps[i])
      97	    Semantic.VerifyCompatibleTypes(node.line, symbol.params[i].type, symbol.params[i].dimension, node.exps[i].sem_type, node.exps[i].sem_dimension)
        	  end
     184	  node.sem_type = symbol.ret_type
     281	  node.sem_dimension = symbol.ret_dimension
        	end
        	
        	--VerifyCompatibleTypes: Check if two different variables can be matched
        	--  Parameters:
        	--    [1] $number = line number
        	--    [2] $string = type of first variable
        	--    [3] $number = dimension of first variable
        	--    [4] $string = type of second variable
        	--    [5] $number = dimension of second variable
        	--  Return:
      54	function Semantic.VerifyCompatibleTypes (line, first_type, first_dimension, second_type, second_dimension)
     970	  local err = false
     945	  if (first_type ~= second_type) then
     411	    if (first_type == "int" and second_type == "char") or (first_type == "char" and second_type == "int") then
     226	      if (first_dimension ~= 0 or second_dimension ~= 0) then
     203	        err = true
        	      end
        	    else
     241	      err = true
        	    end
        	  else
     550	    if (first_dimension ~= second_dimension) then
     139	      err = true
        	    end
        	  end
     940	  if (err) then
     572	    Error(string.format("uncompatible types '%s' dimension '%d' and '%s' dimension '%d'.", first_type, first_dimension, second_type, second_dimension), line)
        	  end
     567	  return true
        	end
        	
        	--VerifyDeclare: Verify integrity of DECLARE node
        	--  Parameters:
        	--    [1] $table  = DECLARE node
        	--  Return:
      70	function Semantic.VerifyDeclare (node)
     517	  if (_DEBUG) then print("SEM :: VerifyDeclare") end
     506	  assert(node.id == nodes_codes["DECLARE"])
        	  --local symbol = SymbolClass.GetCurrentScopeSymbol(node.name)
     502	  local symbol = SymbolClass.GetSymbol(node.name)
     499	  if (symbol) then
     123	    Error(string.format("symbol '%s' was already declared at line %d.", symbol.name, symbol.line), node.line)
        	  else
     594	    SymbolClass.SetSymbol(node)
        	  end
        	end
        	
        	--VerifyElseIf: Verify integrity of ELSEIF node
        	--  Parameters:
        	--    [1] $table  = ELSEIF node
        	--  Return:
     125	function Semantic.VerifyElseIf (node)
      51	  if (_DEBUG) then print("SEM :: VerifyElseIf") end
      68	  assert(node.id == nodes_codes["ELSEIF"])
      95	  SymbolClass.AddScope()
      30	  Semantic.VerifyExpression(node.cond)
      30	  if (node.cond.sem_type ~= "bool" or node.cond.sem_dimension ~= 0) then
      27	    Error(string.format("'else if' expects expression of type 'bool' with dimension '0', but got type '%s' with dimension '%d'.", node.cond.sem_type, node.cond.sem_dimension), node.line)
        	  end
      65	  Semantic.VerifyBlock(node.block)
      40	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyExpression: Verify integrity of EXPRESSION node
        	--  Parameters:
        	--    [1] $table  = CALL, NEGATE, NEWVAR, OPERATOR, UNARY, VALUE or VAR node
        	--  Return:
     194	function Semantic.VerifyExpression (node)
    1902	  if (_DEBUG) then print("SEM :: VerifyExpression") end
    1938	  if (node.id == nodes_codes["CALL"]) then
     268	    Semantic.VerifyCall(node)
    1961	  elseif (node.id == nodes_codes["NEGATE"]) then
     558	    Semantic.VerifyNegate(node)
    2160	  elseif (node.id == nodes_codes["NEWVAR"]) then
     193	    Semantic.VerifyNewVar(node)
    2247	  elseif (node.id == nodes_codes["OPERATOR"]) then
     357	    Semantic.VerifyOperator(node)
    1994	  elseif (node.id == nodes_codes["UNARY"]) then
     111	    Semantic.VerifyUnary(node)
    1989	  elseif (node.id == nodes_codes["LITERAL"]) then
     562	    Semantic.VerifyLiteral(node)
    1423	  elseif (node.id == nodes_codes["VAR"]) then
    1110	    Semantic.VerifyVar(node)
        	  else
     163	    Error("unknown expression node", node.line)
        	  end
        	end
        	
        	--VerifyFunction: Verify integrity of FUNCTION node
        	--  Parameters:
        	--    [1] $table  = FUNCTION node
        	--  Return:
     333	function Semantic.VerifyFunction (node)
    1265	  if (_DEBUG) then print("SEM :: VerifyFunction") end
    1852	  assert(node.id == nodes_codes["FUNCTION"])
    1681	  SymbolClass.AddScope()
    1417	  for _, param in ipairs(node.params) do
    1179	    if (SymbolClass.GetSymbol(param.name)) then
        	    --if (SymbolClass.GetCurrentScopeSymbol(param.name)) then
     160	      Error(string.format("function parameter '%s' already declared.", param.name), node.line)
        	    end
     627	    SymbolClass.SetSymbol(param)
        	  end
    1273	  if (node.ret_type) then
    1250	    local ret = {
     543	      id        = nodes_codes["DECLARE"],
     642	      name      = "@ret",
     629	      line      = node.line,
     592	      type      = node.ret_type,
     843	      dimension = node.ret_dimension,
     591	    }
    1335	    SymbolClass.SetSymbol(ret)
        	  end
     987	  Semantic.VerifyBlock(node.block)
     415	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyGlobals: Add global functions and variables to scope
        	--  Parameters:
        	--    [1] $table  = PROGRAM node
        	--  Return:
      61	function Semantic.VerifyGlobals (t)
     797	  if (_DEBUG) then print("SEM :: VerifyGlobals") end
     993	  assert(t.id == nodes_codes["PROGRAM"])
    1710	  for _, node in ipairs(t) do
     992	    local symbol = SymbolClass.GetSymbol(node.name)
     988	    if (symbol) then
     104	      Error(string.format("global symbol '%s' was already declared at line %d.", symbol.name, symbol.line), node.line)
        	    end
    1283	    SymbolClass.SetSymbol(node)
        	  end
        	end
        	
        	--VerifyIf: Verify integrity of IF node
        	--  Parameters:
        	--    [1] $table  = IF node
        	--  Return:
      22	function Semantic.VerifyIf (node)
     144	  if (_DEBUG) then print("SEM :: VerifyIf") end
      75	  assert(node.id == nodes_codes["IF"])
     110	  SymbolClass.AddScope()
     148	  Semantic.VerifyExpression(node.cond)
     146	  if (node.cond.sem_type ~= "bool" or node.cond.sem_dimension ~= 0) then
     136	    Error(string.format("'if' expects expression of type 'bool' with dimension '0', but got type '%s' with dimension '%d'.", node.cond.sem_type, node.cond.sem_dimension), node.line)
        	  end
      94	  Semantic.VerifyBlock(node.block)
     135	  if (node["elseif"]) then
     163	    for _, n in ipairs (node["elseif"]) do
      43	      Semantic.VerifyElseIf(n)
        	    end
        	  end
     132	  SymbolClass.AddScope()
      61	  Semantic.VerifyBlock(node["else"])
      67	  SymbolClass.RemoveScope()
     342	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyLiteral: Verify integrity of LITERAL node
        	--  Parameters:
        	--    [1] $table  = LITERAL node
        	--  Return:
     415	function Semantic.VerifyLiteral (node)
    1277	  if (_DEBUG) then print("SEM :: VerifyLiteral") end
     984	  assert(node.id == nodes_codes["LITERAL"])
     959	  node.sem_type = node.type
     891	  node.sem_dimension = node.dimension
        	end
        	
        	--VerifyNewVar: Verify integrity of NEWVAR node
        	--  Parameters:
        	--    [1] $table  = NEWVAR node
        	--  Return:
      63	function Semantic.VerifyNewVar (node)
      38	  if (_DEBUG) then print("SEM :: VerifyNewVar") end
     136	  assert(node.id == nodes_codes["NEWVAR"])
      96	  Semantic.VerifyExpression(node.exp)
     228	  if (node.exp.sem_type ~= "int" and node.exp.sem_type ~= "char") then
      64	    Error(string.format("'new var' expression must have type 'int' or 'char', but got type '%s'.", node.exp.sem_type), node.line)
        	  end
      36	  node.sem_type = node.type
      34	  node.sem_dimension = node.dimension + 1
        	end
        	
        	--VerifyNegate: Verify integrity of NEGATE node
        	--  Parameters:
        	--    [1] $table  = NEGATE node
        	--  Return:
      86	function Semantic.VerifyNegate (node)
      85	  if (_DEBUG) then print("SEM :: VerifyNegate") end
     159	  assert(node.id == nodes_codes["NEGATE"])
     165	  Semantic.VerifyExpression(node.exp)
      96	  if (node.exp.sem_type ~= "bool" or node.exp.sem_dimension ~= 0) then
     165	    Error(string.format("'not' must be done over type 'bool' with dimension '0', but got type '%s' with dimension '%d'.", node.exp.sem_type, node.exp.sem_dimension))
        	  end
     211	  node.sem_type = "bool"
     208	  node.sem_dimension = 0
        	end
        	
        	--VerifyOperator: Verify integrity of OPERATOR node
        	--  Parameters:
        	--    [1] $table  = NEGATE node
        	--  Return:
     199	function Semantic.VerifyOperator (node)
     718	  if (_DEBUG) then print("SEM :: VerifyOperator") end
     475	  assert(node.id == nodes_codes["OPERATOR"])
     493	  Semantic.VerifyExpression(node[1])
     296	  Semantic.VerifyExpression(node[2])
     310	  if (node.op == "and" or node.op == "or") then
      64	    if (node[1].sem_type ~= "bool") then
     126	      Error(string.format("operation '%s' cannot be made over left type '%s'.", node.op, node[1].sem_type), node.line)
     146	    elseif (node[2].sem_type ~= "bool") then
     192	      Error(string.format("operation '%s' cannot be made over right type '%s'.", node.op, node[2].sem_type), node.line)
        	    end
     529	    if (node[1].sem_dimension ~= 0) then
     506	      Error(string.format("operation '%s' cannot be made over arrays values, but left side of expression has dimension '%d'.", node.op, node[1].sem_dimension), node.line)
     995	    elseif (node[2].sem_dimension ~= 0) then
     750	      Error(string.format("operation '%s' cannot be made over arrays values, but right side of expression has dimension '%d'.", node.op, node[2].sem_dimension), node.line)
        	    end
     168	    node.sem_type = "bool"
     226	    node.sem_dimension = 0
     814	  elseif (node.op == "=" or node.op == "<>") then
     231	    if (node[1].sem_type ~= node[2].sem_type) then
     355	      if ((node[1].sem_type ~= "int" and node[1].sem_type ~= "char") or (node[2].sem_type ~= "int" and node[2].sem_type ~= "char")) then
      78	        Error(string.format("operation '%s' require 'int' or 'char' expressions on both sides, but got '%s' and '%s'.", node.op, node[1].sem_type, node[2].sem_type), node.line)
        	      end
        	    end
     175	    if (node[1].sem_dimension ~= node[2].sem_dimension) then
     150	      Error(string.format("operation '%s' require variables with same dimension, but got dimensions '%s' and '%s'.", node.op, node[1].sem_dimension, node[2].sem_dimension), node.line)
        	    end
     261	    node.sem_type = "bool"
     180	    node.sem_dimension = 0
     331	  elseif (node.op == ">" or node.op == "<" or node.op == ">=" or node.op == "<=" or 
     310	          node.op == "+" or node.op == "-" or node.op == "*" or node.op == "/") then
     344	    if (node[1].sem_type ~= "int" and node[1].sem_type ~= "char") then
      60	      Error(string.format("operation '%s' require 'int' or 'char' expression on both sides, but got type '%s' on left side.", node.op, node[1].sem_type), node.line)
     259	    elseif (node[2].sem_type ~= "int" and node[2].sem_type ~= "char") then
      89	      Error(string.format("operation '%s' require 'int' or 'char' expression on both sides, but got type '%s' on right side.", node.op, node[2].sem_type), node.line)
     285	    elseif (node[1].sem_dimension ~= 0) then
      98	      Error(string.format("operation '%s' require dimension '0' on both sides, but got dimension '%d' on left side.", node.op, node[1].sem_dimension), node.line)
     222	    elseif (node[2].sem_dimension ~= 0) then
      32	      Error(string.format("operation '%s' require dimension '0' on both sides, but got dimension '%d' on right side.", node.op, node[2].sem_dimension), node.line)
        	    end
     276	    node.sem_dimension = 0
     253	    if (node.op == ">" or node.op == "<" or node.op == ">=" or node.op == "<=") then
     186	      node.sem_type = "bool"
        	    else
     138	      node.sem_type = "int"
        	    end
        	  else
      42	    Error(string.format("unknown operation '%s'.", node.op), node.line)
        	  end
        	end
        	
        	--VerifyProgram: Verify integrity of PROGRAM node
        	--  Parameters:
        	--    [1] $table  = PROGRAM node
        	--  Return:
     553	function Semantic.VerifyProgram (t)
    1115	  if (_DEBUG) then print("SEM :: VerifyProgram") end
    1239	  assert(t.id == nodes_codes["PROGRAM"])
    1453	  SymbolClass.AddScope()
    1190	  Semantic.VerifyGlobals(t)
    1227	  for _, node in ipairs(t) do
    1406	    if (node.id == nodes_codes["DECLARE"]) then
        	      -- DO NOT VERIFY. SYMBOL ADDED IN GLOBALS
     888	    elseif (node.id == nodes_codes["FUNCTION"]) then
     921	      Semantic.VerifyFunction(node)
        	    else
     219	      Error("unknown program node.")
        	    end
        	  end
     343	  SymbolClass.RemoveScope()
        	end
        	
        	--VerifyReturn: Verify integrity of RETURN node
        	--  Parameters:
        	--    [1] $table  = RETURN node
        	--  Return:
      59	function Semantic.VerifyReturn (node)
     528	  if (_DEBUG) then print("SEM :: VerifyReturn") end
     561	  assert(node.id == nodes_codes["RETURN"])
     606	  local symbol = SymbolClass.GetSymbol("@ret")
     616	  if (not symbol) then
     127	    if (node.exp) then
      78	      Error(string.format("function with return 'void' must not attempt to call 'return'."), node.line)
        	    end
     584	  elseif (node.exp) then
     563	    Semantic.VerifyExpression(node.exp)
     525	    Semantic.VerifyCompatibleTypes(node.line, symbol.type, symbol.dimension, node.exp.sem_type, node.exp.sem_dimension)
      40	  elseif (symbol.type) then
      38	    Error(string.format("function expected to return type '%s' but got 'nil'.", symbol.type), node.line)
        	  else
      58	    Error("unknown function return error.", node.line)
        	  end
        	end
        	
        	--VerifyUnary: Verify integrity of UNARY node
        	--  Parameters:
        	--    [1] $table  = UNARY node
        	--  Return:
     118	function Semantic.VerifyUnary (node)
     131	  if (_DEBUG) then print("SEM :: VerifyUnary") end
     131	  assert(node.id == nodes_codes["UNARY"])
     280	  Semantic.VerifyExpression(node.exp)
     486	  if ((node.exp.sem_type ~= "int" and node.exp.sem_type ~= "char") or node.exp.sem_dimension ~= 0) then
     706	    Error(string.format("'unary' must be done over type 'char' or 'int' with dimension '0', but got type '%s' with dimension '%d'.", node.exp.sem_type, node.exp.sem_dimension), node.line)
        	  end
     674	  node.sem_type = node.exp.sem_type
     305	  node.sem_dimension = node.exp.sem_dimension
        	end
        	
        	--VerifyVar: Verify integrity of VAR node
        	--  Parameters:
        	--    [1] $table  = VAR node
        	--  Return:
     109	function Semantic.VerifyVar (node)
    1771	  if (_DEBUG) then print("SEM :: VerifyVar") end
    1717	  assert(node.id == nodes_codes["VAR"])
    1603	  local symbol = SymbolClass.GetSymbol(node.name)
    1593	  if (not symbol) then
     226	    Error(string.format("symbol '%s' was not declared.", node.name), node.line)
        	  end
    1681	  node.sem_type = symbol.type
    1974	  if (symbol.dimension and symbol.dimension > 0) then
    1112	    if (#node.array > symbol.dimension) then
     395	      Error(string.format("symbol '%s' dimension is '%d', but was called with dimension '%d'.", node.name, symbol.dimension, #node.array), node.line)
        	    end
    1028	    for _, exp in ipairs(node.array) do
     532	      Semantic.VerifyExpression(exp)
     601	      if (exp.sem_type ~= "int" and exp.sem_type ~= "char") then
     382	        Error(string.format("symbol '%s' dimension must be an 'int' or 'char', but was called with dimension '%s'.", node.name, exp.sem_type), node.line)
        	      end
        	    end
     877	    node.sem_dimension = symbol.dimension - #node.array
    1044	  elseif (node.array and #node.array > 0) then
     172	    Error(string.format("symbol '%s' dimension is '0', but was called with dimension '%d'.", node.name, #node.array), node.line)
        	  else
    1071	    node.sem_dimension = 0
        	  end
        	end
        	
        	--VerifyWhile: Verify integrity of WHILE node
        	--  Parameters:
        	--    [1] $table  = WHILE node
        	--  Return:
      57	function Semantic.VerifyWhile (node)
     103	  if (_DEBUG) then print("SEM :: VerifyWhile") end
      21	  assert(node.id == nodes_codes["WHILE"])
     120	  SymbolClass.AddScope()
      30	  Semantic.VerifyExpression(node.cond)
      90	  if (node.cond.sem_type ~= "bool" or node.cond.sem_dimension ~= 0) then
     141	    Error(string.format("while expects 'bool' expression with dimension '0', but got type '%s' with dimension '%d'.", node.cond.sem_type, node.cond.sem_dimension), node.line)
        	  end
      18	  Semantic.VerifyBlock(node.block)
     144	  SymbolClass.RemoveScope()
        	end
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--GetTree:
        	--  parameters:
        	--  return:
        	--    [1] $boolean - false if found any problem, true otherwise
      95	function Semantic.GetTree ()
     267	  return tree
        	end
        	
        	--Open:
        	--  parameters:
        	--    [1] $table   - table with AST tree nodes
        	--  return:
        	--    [1] $boolean - false if found any problem, true otherwise
        	--    [2] $string  - only when [1] is false, informing which error occurs
      49	function Semantic.Open (t)
     718	  if (_DEBUG) then print("SEM :: Open") end
     760	  assert(t and type(t) == "table")
     747	  SymbolClass.Clear()
    1451	  local ok, msg = pcall(function () Semantic.VerifyProgram(t) end)
     801	  if (not ok) then
     574	    return false, msg
        	  end
     177	  tree = t
     189	  if (printTree) then
      86	    Semantic.Print(t)
        	  end
     270	  return true
        	end
        	
        	--Print: Print Abstract Semantic Tree with comprehensible format
        	--  parameters:
        	--  return:
       3	function Semantic.Print (t)
*******0	  PrintClass.Print(t)
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       3	return Semantic

==============================================================================
./src/symbol_table.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      18	require "lib/util"
      18	local NodesClass  = require "lib/node_codes"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      18	local SymbolTable = {}
        	
      18	local scopes = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
      18	local nodes_codes = NodesClass.GetNodesList()
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
      18	function Error ()
*******0	  error("Symbol error.", 0)
        	end
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--AddScope: Insert a new scope level
        	--  parameters:
        	--  return:
      18	function SymbolTable.AddScope ()
    3289	  if (_DEBUG) then print("SYB :: AddScope") end
    3289	  scopes[#scopes + 1] = {}
        	end
        	
        	--Clear: Remove all scopes
        	--  parameters:
        	--  return:
      18	function SymbolTable.Clear ()
    1354	  if (_DEBUG) then print("SYB :: Clear") end
    1354	  scopes = {}
        	end
        	
        	--GetCurrentScopeSymbol: Get symbol only if present in current scope
        	--  parameters:
        	--    [1] $string         - Symbol name
        	--  return:
        	--    [1] $table or $nil  - Copy of symbol structure if found, otherwise nil
     414	function SymbolTable.GetCurrentScopeSymbol (name)
    1226	  if (_DEBUG) then print("SYB :: GetCurrentScopeSymbol") end
     964	  local num_scope = #scopes
     609	  if (scopes[#scopes][name]) then
     161	    local symbol = util.TableCopy(scopes[#scopes][name])
     155	    symbol.name = name
     131	    return symbol
        	  end
     448	  return nil
        	end
        	
        	--GetSymbol: Get symbol if present in current or above scopes
        	--  parameters:
        	--    [1] $string         - Symbol name
        	--  return:
        	--    [1] $table or $nil  - Copy of symbol structure if found, otherwise nil
     815	function SymbolTable.GetSymbol (name)
    6035	  if (_DEBUG) then print("SYB :: GetSymbol") end
    6037	  local num_scope = #scopes
   11468	  while (num_scope > 0) do
    8518	    if (scopes[num_scope][name]) then
    3632	      local symbol = util.TableCopy(scopes[num_scope][name])
    3085	      symbol.name = name
    3314	      return symbol
        	    end
    5488	    num_scope = num_scope - 1
        	  end
    2695	  return nil
        	end
        	
        	--Print: Print symbol table
        	--  parameters:
        	--  return:
      13	function SymbolTable.Print ()
*******0	  if (_DEBUG) then print("SYB :: Print") end
*******0	  util.TablePrint(scopes)
        	end
        	
        	--RemoveScope: Remove current scope
        	--  parameters:
        	--  return:
      13	function SymbolTable.RemoveScope ()
     978	  if (_DEBUG) then print("SYB :: RemoveScope") end
     978	  scopes[#scopes] = nil
        	end
        	
        	--SetSymbol: Create a new symbol in current scope
        	--          function or var
        	--  parameters:
        	--    [1] $table  - 
        	--              id   = $number - 
        	--              name = $string - 
        	--              line = $number - 
        	--              func_params {
        	--                params        = $table  - 
        	--                ret_type      = $string - 
        	--                ret_dimension = $number - 
        	--              }
        	--              var_params {
        	--                type
        	--                dimension = $number - 
        	--              }
        	--  return:
     351	function SymbolTable.SetSymbol (t)
    3953	  if (_DEBUG) then print("SYB :: SetSymbol") end
    4114	  assert(t and type(t) == "table")
    4114	  assert(t.line and type(t.line) == "number")
    3953	  assert(t.name and type(t.name) == "string")
    3924	  local symbol = {}
    3761	  symbol.line = t.line
    3761	  symbol.name = t.name
    3761	  if (t.id == nodes_codes["FUNCTION"]) then
    1530	    symbol.id = "function"
    1530	    symbol.params = util.TableCopy(t.params)
    1530	    symbol.ret_type = t.ret_type
    1532	    symbol.ret_dimension = t.ret_dimension
    2277	  elseif (t.id == nodes_codes["DECLARE"] or t.id == nodes_codes["PARAMETER"]) then
    2277	    symbol.id = "variable"
    2277	    symbol.type = t.type
    2615	    symbol.dimension = t.dimension
        	  else
*******0	    Error()
        	  end
    3615	  scopes[#scopes] = scopes[#scopes] or {}
    3615	  scopes[#scopes][t.name] = symbol
        	  --util.TablePrint(scopes)
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
      13	return SymbolTable

==============================================================================
./src/syntactic.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      18	local ParserClass 	= require "src/parser"
      18	local LanguageClass = require "src/grammar"
      18	local ASTClass		  = require "src/syntax_tree"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      18	local Syntactic = {}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--GetTree:
        	--  parameters:
        	--  return:
     652	function Syntactic.GetTree()
     720	  if (_DEBUG) then print("SYN :: GetTree") end
     704	  return ASTClass.GetTree()
        	end
        	
        	--Open:
        	--  parameters:
        	--    [1] $table   - table with tokens read in lexical
        	--  return:
        	--    [1] $boolean - false if found any problem, true otherwise
        	--    [2] $string  - only when [1] is false, informing which error occurs
    1068	function Syntactic.Open (t)
    1822	  if (_DEBUG) then print("SYN :: Open") end
    1822	  assert(t and type(t) == "table")
    1822	  ParserClass.Open(t)
    1172	  local ok, msg = LanguageClass.Start(ParserClass.Advance, ParserClass.Peek, ParserClass.Peek2)
     756	  if (not ok) then
     702	  	return false, msg
        	  end
     704	  return true
        	end
        	
        	--PrintTree:
       2	function Syntactic.PrintTree()
      16	  if (_DEBUG) then print("SYN :: PrintTree") end
*******0	  return ASTClass.Print()
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       2	return Syntactic

==============================================================================
./src/syntax_tree.lua
==============================================================================
        	--==============================================================================
        	-- Debug
        	--==============================================================================
        	
      18	local printTree = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      18	require "lib/util"
      18	local NodesClass  = require "lib/node_codes"
      13	local PrintClass  = require "lib/util_tree"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
      13	local AbstractSyntaxTree = {}
        	
        	--  list of nodes code
        	--  {
        	--    [name] = $number,
        	--  }
      13	local nodes_codes = NodesClass.GetNodesList()
        	
        	--  AST tree (structed nodes)
      13	local tree = {}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Initialize
        	--==============================================================================
        	
        	
        	
        	--==============================================================================
        	-- Public Methods
        	--==============================================================================
        	
        	--GetTree:
        	--  parameters:
        	--  return:
     465	function AbstractSyntaxTree.GetTree ()
        	  --return util.TableCopy(tree)
     704	  return tree
        	end
        	
        	--NewAttributionNode:
        	--  {
        	--    id    = $number - ATTRIBUTION code
        	--    exp   = $table  - EXPRESSION node
        	--    line  = $number - line number
        	--    var   = $table  - VAR node
        	--  }
        	--  parameters:
        	--  return:
    1103	function AbstractSyntaxTree.NewAttributionNode (var, expression)
    1663	  if (_DEBUG) then print("AST :: NewAttributionNode") end
    1663	  local node = {
    1668	    id    = nodes_codes["ATTRIBUTION"],
    1663	    exp   = expression,
     567	    line  = var.line,
    1663	    var   = var,
      11	  }
     562	  return node
        	end
        	
        	--NewCallNode:
        	--  {
        	--    id    = $number - CALL code
        	--    line  = $number - line number
        	--    name  = $string - var name
        	--    exps  = $table  - list of EXPRESSION nodes
        	--  }
        	--  parameters:
        	--  return:
     227	function AbstractSyntaxTree.NewCallNode (line, name, expressions)
     292	  if (_DEBUG) then print("AST :: NewCallNode") end
     292	  local node = {
     297	    id   = nodes_codes["CALL"],
     292	    line = line,
      77	    name = name,
     292	    exps = expressions,
      11	  }
      72	  return node
        	end
        	
        	--NewDeclVarNode:
        	--  {
        	--    id        = $number - DECLARE code
        	--    line      = $number - line number
        	--    name      = $string - var name
        	--    dimension = $number - var dimension
        	--    type      = $string - [bool, char, int]
        	--  }
        	--  parameters:
        	--  return:
     640	function AbstractSyntaxTree.NewDeclVarNode (line, name, typebase, size)
    1338	  if (_DEBUG) then print("AST :: NewDeclVarNode") end
    1338	  local node = {
    1338	    id        = nodes_codes["DECLARE"],
    1343	    line      = line,
    1338	    name      = name,
     705	    dimension = size,
    1338	    type      = typebase,
      19	  }
     710	  if (node.type == "string") then
      67	    node.type = "char"
     186	    node.dimension = node.dimension + 1
        	  end
     700	  return node
        	end
        	
        	--NewElseIfNode:
        	--  {
        	--    id    = $number - ELSEIF code
        	--    block = $table  - list of COMMANDS that will be executed if [cond] is true
        	--    cond  = $table  - EXPRESSION NODE, represents condition
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
      90	function AbstractSyntaxTree.NewElseIfNode (line, condition, block)
      48	  if (_DEBUG) then print("AST :: NewElseIfNode") end
     120	  local node = {
      57	    id          = nodes_codes["ELSEIF"],
      48	    block       = block,
      32	    cond        = condition,
      48	    line        = line,
       2	  }
      32	  return node
        	end
        	
        	--NewFunctionNode:
        	--  {
        	--    id            = $number - FUNCTION code
        	--    block         = $table  - list of COMMANDS that will be executed
        	--    line          = $number - line number
        	--    name          = $string - var name
        	--    params        = $table  - list of PARAMETER nodes
        	--    ret_type      = $string - [bool, char, int], represents function return type
        	--    ret_dimension = $number - function return dimension
        	--  }
        	--  parameters:
        	--  return:
     710	function AbstractSyntaxTree.NewFunctionNode (line, name, parameters, return_type, return_size, block)
    1496	  if (_DEBUG) then print("AST :: NewFunctionNode") end
    1496	  local node = {
    1496	    id            = nodes_codes["FUNCTION"],
     920	    line          = line,
    1496	    name          = name,
     929	    params        = parameters,
     920	    ret_type      = return_type,
     788	    ret_dimension = return_size,
     920	    block         = block,
       2	  }
     788	  if (node.ret_type == "string") then
      61	    node.ret_type = "char"
      56	    node.ret_dimension = node.ret_dimension + 1
        	  end
     788	  return node
        	end
        	
        	--NewIfNode:
        	--  {
        	--    id      = $number - IF code
        	--    block   = $table  - list of COMMANDS that will be executed if [cond] is true
        	--    cond    = $table  - EXPRESSION NODE, represents condition
        	--    else    = $table  - list of COMMANDS that will be executed none conditions are true
        	--    elseif  = $table  - list of ELSEIF nodes
        	--    line    = $number - line number
        	--  }
        	--  parameters:
        	--  return:
     200	function AbstractSyntaxTree.NewIfNode (line, condition, block, elseif_node, else_block)
     115	  if (_DEBUG) then print("AST :: NewIfNode") end
     106	  if (elseif_node and util.TableIsEmpty(elseif_node)) then
      50	    elseif_node = nil
        	  end
      72	  local node = {
      70	    id          = nodes_codes["IF"],
      75	    block       = block,
      70	    cond        = condition,
      75	    ["else"]    = else_block,
      70	    ["elseif"]  = elseif_node,
      79	    line        = line,
     104	  }
     174	  return node
        	end
        	
        	--NewLiteralNode:
        	--  {
        	--    id        = $number   - LITERAL code
        	--    dimension = $number   - var dimension
        	--    line      = $number   - line number
        	--    type      = $string   - [bool, char, int, string]
        	--    value     = $string   - if type == char or string, -- Value cannot be 'char' type.
        	--                $number   - if type == int,
        	--                $boolean  - if type == bool,
        	--  }
        	--  parameters:
        	--  return:
       2	function AbstractSyntaxTree.NewLiteralNode (line, type, value)
     678	  if (_DEBUG) then print("AST :: NewLiteralNode") end
     678	  local node = {
     687	    id        = nodes_codes["LITERAL"],
     741	    dimension = 0,
     741	    line      = line,
     741	    type      = type,
     743	    value     = value,
      77	  }
     755	  if (node.type == "string") then
     113	    node.type = "char"
      50	    node.dimension = 1
        	  end
     706	  return node
        	end
        	
        	--NewNegateNode:
        	--  {
        	--    id    = $number - NEGATE code
        	--    exp   = $table  - EXPRESSION node
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
       2	function AbstractSyntaxTree.NewNegateNode (line, expression)
      57	  if (_DEBUG) then print("AST :: NewNegateNode") end
     967	  local node = {
     972	    id    = nodes_codes["NEGATE"],
    1411	    exp   = expression,
    1413	    line  = line,
    1575	  }
    1623	  return node
        	end
        	
        	--NewNewVarNode:
        	--  {
        	--    id        = $number - NEWVAR code
        	--    dimension = $number - var dimension
        	--    exp       = $table  - EXPRESSION node
        	--    line      = $number - line number
        	--    type      = $string - [bool, char, int]
        	--  }
        	--  parameters:
        	--  return:
       2	function AbstractSyntaxTree.NewNewVarNode (line, expression, type, dimension)
      36	  if (_DEBUG) then print("AST :: NewNewVarNode") end
      36	  local node = {
      50	    id        = nodes_codes["NEWVAR"],
     392	    dimension = dimension,
     392	    exp       = expression,
     392	    line      = line,
     394	    type      = type,
     416	  }
     452	  if (node.type == "string") then
     330	    node.type = "char"
     146	    node.dimension = node.dimension + 1
        	  end
     105	  return node
        	end
        	
        	--NewOperatorNode:
        	--  {
        	--    id    = $number - OPERATOR code
        	--    line  = $number - line number
        	--    op    = $string - [and or + - * / > < >= <= = <>], one of possible operations
        	--    [1]   = $table  - EXPRESSION node, left side of operator
        	--    [2]   = $table  - EXPRESSION node, right side of operator
        	--  }
        	--  parameters:
        	--  return:
     226	function AbstractSyntaxTree.NewOperatorNode (line, left, operator, right)
     660	  if (_DEBUG) then print("AST :: NewOperatorNode") end
     658	  local node = {
     658	    id    = nodes_codes["OPERATOR"],
     658	    line  = line,
     667	    op    = operator,
     434	    left,
     224	    right,
     439	  }
     436	  return node
        	end
        	
        	--NewParameterNode:
        	--  {
        	--    id        = $number - PARAMETER code
        	--    dimension = $number - var dimension
        	--    line      = $number - line number
        	--    name      = $string - var name
        	--    type      = $string - [bool, char, int]
        	--  }
        	--  parameters:
        	--  return:
     124	function AbstractSyntaxTree.NewParameterNode (line, name, typebase, size)
     494	  if (_DEBUG) then print("AST :: NewProgramNode") end
     496	  local node = {
     408	    id        = nodes_codes["PARAMETER"],
     372	    line      = line,
     408	    name      = name,
     377	    dimension = size,
     372	    type      = typebase,
       9	  }
     543	  if (node.type == "string") then
     211	    node.type = "char"
     211	    node.dimension = node.dimension + 1
        	  end
     581	  return node
        	end
        	
        	--NewProgramNode:
        	--  {
        	--    id       = $number - PROGRAM code
        	--    [1 to N] = DECLARE or FUNCTION node
        	--  }
        	--  parameters:
        	--  return:
     286	function AbstractSyntaxTree.NewProgramNode (ast_tree)
     988	  if (_DEBUG) then print("AST :: NewProgramNode") end
     988	  tree = {}
     997	  tree = util.TableCopy(ast_tree)
    1055	  tree.id = nodes_codes["PROGRAM"]
    1055	  if (printTree) then AbstractSyntaxTree.Print() end
        	end
        	
        	--NewReturnNode:
        	--  {
        	--    id    = $number - RETURN code
        	--    line  = $number - line number
        	--    exp   = $table  - EXPRESSION node
        	--  }
        	--  parameters:
        	--  return:
       2	function AbstractSyntaxTree.NewReturnNode (line, expression)
     496	  if (_DEBUG) then print("AST :: NewReturnNode") end
     496	  local node = {
     496	    id    = nodes_codes["RETURN"],
     496	    exp   = expression,
     496	    line  = line,
       5	  }
     578	  return node
        	end
        	
        	--NewUnaryNode:
        	--  {
        	--    id    = $number - UNARY code
        	--    exp   = $table  - EXPRESSION node
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
     294	function AbstractSyntaxTree.NewUnaryNode (line, expression)
      28	  if (_DEBUG) then print("AST :: NewUnaryNode") end
     320	  local node = {
      30	    id    = nodes_codes["UNARY"],
      28	    exp   = expression,
      28	    line  = line,
        	  }
      28	  return node
        	end
        	
        	--NewVarNode:
        	--  {
        	--    id    = $number - VAR code
        	--    array = $table  - list of EXPRESSIONS, one for each dimension
        	--    line  = $number - line number
        	--    name  = $string - var name
        	--  }
        	--  parameters:
        	--  return:
     545	function AbstractSyntaxTree.NewVarNode (line, name, array)
    2324	  if (_DEBUG) then print("AST :: NewVarNode") end
    1790	  local node = {
    2324	    id    = nodes_codes["VAR"],
    1792	    line  = line,
    1790	    name  = name,
    1790	    array = array,
        	  }
    1790	  return node
        	end
        	
        	--NewWhileNode:
        	--  {
        	--    id    = $number - WHILE code
        	--    block = $table  - list of COMMANDS that will be executed if [cond] is true
        	--    cond  = $table  - EXPRESSION node, represents condition
        	--    line  = $number - line number
        	--  }
        	--  parameters:
        	--  return:
      26	function AbstractSyntaxTree.NewWhileNode (line, condition, block)
      30	  if (_DEBUG) then print("AST :: NewWhileNode") end
      20	  local node = {
      30	    id    = nodes_codes["WHILE"],
      22	    block = block,
      29	    cond  = condition,
      20	    line  = line,
        	  }
      29	  return node
        	end
        	
        	--Print: Print Abstract Syntax Tree with comprehensible format
        	--  parameters:
        	--  return:
     481	function AbstractSyntaxTree.Print ()
     488	  if (_DEBUG) then print("AST :: Print") end
     479	  PrintClass.Print(tree)
        	end
        	
        	
        	--==============================================================================
        	-- Return
        	--==============================================================================
        	
       2	return AbstractSyntaxTree

==============================================================================
src/auto_test.lua
==============================================================================
        	--==============================================================================
        	-- Global Defines
        	--==============================================================================
        	
      18	_DEBUG = false
      17	local printFailMessage = false
        	
        	
        	--==============================================================================
        	-- Dependency
        	--==============================================================================
        	
      18	require "lib/util"
      18	local Lexical       = require "src/lexical"
      18	local Syntactic     = require "src/syntactic"
      17	local Semantic      = require "src/semantic"
       2	local InterCodeGen  = require "src/intermediate_code"
        	
        	
        	--==============================================================================
        	-- Data Structure
        	--==============================================================================
        	
       3	local files = {
      16	  {
      18	    name      = "nil_file",
      17	    open      = false,
       3	  },
      16	  {
      18	    name      = "lex_fail",
      18	    open      = true,
      18	    lexical   = false,
       2	  },
      16	  {
      18	    name      = "lex_overload_01",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = false,
       2	  },
      16	  {
      18	    name      = "lex_overload_02",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = false,
       2	  },
      16	  {
      18	    name      = "lex_overload_03",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = false,
       2	  },
      16	  {
      18	    name      = "lex_overload_04",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = false,
       3	  },
      15	  {
      18	    name      = "sem_complete_program",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = true,
       3	  },
      15	  {
      18	    name      = "sem_elseif_block",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = true,
       3	  },
      15	  {
      18	    name      = "sem_fail_attrib_string_char",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  },
      15	  {
      18	    name      = "sem_fail_attrib_char_string",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  },
      15	  {
      18	    name      = "sem_fail_attrib_int_bool",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  },
      15	  {
      18	    name      = "sem_fail_call_not_function",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  },
      15	  {
      18	    name      = "sem_fail_call_wrong_param_number",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  },
      15	  {
      18	    name      = "sem_fail_declare_same_name_01",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  },
      15	  {
      18	    name      = "sem_fail_declare_same_name_02",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  }, 
      15	  {
      18	    name      = "sem_fail_elseif_condition",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  },
      15	  {
      17	    name      = "sem_fail_exp_negate_char",
      17	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  },
      16	  {
      17	    name      = "sem_fail_exp_sum_bool",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  },
      16	  {
      17	    name      = "sem_fail_exp_unary_bool",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  },
      16	  {
      17	    name      = "sem_fail_func_ret_dimension_different",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  },
      16	  {
      17	    name      = "sem_fail_func_ret_nil",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  },
      16	  {
      17	    name      = "sem_fail_func_ret_type_different",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  },
      16	  {
      17	    name      = "sem_fail_func_same_par_name",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  },
      16	  {
      17	    name      = "sem_fail_func_void_return",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = true,
       3	  },
      15	  {
      16	    name      = "sem_fail_if_condition_int",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       4	  },
      14	  {
      18	    name      = "sem_fail_var_array_bool",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = false,
       3	  },
      15	  {
      18	    name      = "sem_fail_var_array_dimension_zero",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      17	    semantic  = false,
       4	  },
       9	  {
      12	    name      = "sem_fail_var_array_larger",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      17	    semantic  = false,
      10	  },
       9	  {
      18	    name      = "sem_fail_var_existent",
      18	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      17	    semantic  = false,
      10	  },
       8	  {
      17	    name      = "sem_fail_var_undeclared",
      18	    open      = true,
      18	    lexical   = true,
      17	    syntactic = true,
      18	    semantic  = false,
      11	  },
        	
        	  -- ITERATION 3
      16	  {
      18	    name      = "00-fail-empty",
      17	    open      = true,
      18	    lexical   = true,
      18	    syntactic = false,
       3	  },
      16	  {
      18	    name      = "01-global",
      17	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = true,
       3	  },
      16	  {
      18	    name      = "02-fun",
      17	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      17	    semantic  = true,
       4	  },
      16	  {
      18	    name      = "03-nls",
      17	    open      = true,
      18	    lexical   = true,
      17	    syntactic = true,
      18	    semantic  = false,
       4	  },
      16	  {
      17	    name      = "04-funglobal",
      18	    open      = true,
      17	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = true,
       4	  },
      16	  {
      17	    name      = "05-params",
      18	    open      = true,
      17	    lexical   = true,
      18	    syntactic = true,
      12	    semantic  = false,
      10	  },
      15	  {
      18	    name      = "06-declvar",
      18	    open      = true,
      17	    lexical   = true,
      12	    syntactic = true,
      18	    semantic  = false,
      10	  },
      15	  {
      18	    name      = "07-if",
      17	    open      = true,
      12	    lexical   = true,
      18	    syntactic = true,
      17	    semantic  = false,
      11	  },
      15	  {
      18	    name      = "08-fail-else",
      17	    open      = true,
      12	    lexical   = true,
      17	    syntactic = false,
      11	  },
      16	  {
      17	    name      = "09-fail-elseif",
      17	    open      = true,
      18	    lexical   = true,
      11	    syntactic = false,
      11	  },
      16	  {
      18	    name      = "10-fail-if",
      17	    open      = true,
      17	    lexical   = true,
      12	    syntactic = false,
      10	  },
      16	  {
      18	    name      = "11-ifdecl",
      17	    open      = true,
      18	    lexical   = true,
      17	    syntactic = true,
      12	    semantic  = false,
      10	  },
      16	  {
      17	    name      = "12-while",
      18	    open      = true,
      17	    lexical   = true,
      12	    syntactic = true,
      17	    semantic  = false,
      11	  },
      15	  {
      18	    name      = "13-fail-while",
      18	    open      = true,
      17	    lexical   = true,
      12	    syntactic = false,
      10	  },
      15	  {
      18	    name      = "14-ifwhile",
      18	    open      = true,
      17	    lexical   = true,
      18	    syntactic = true,
      11	    semantic  = true,
      10	  },
      16	  {
      18	    name      = "15-fail-ifwhile",
      18	    open      = true,
      17	    lexical   = true,
      12	    syntactic = false,
       9	  },
      16	  {
      18	    name      = "16-atrib",
      18	    open      = true,
      18	    lexical   = true,
      17	    syntactic = true,
      11	    semantic  = false,
      10	  },
      16	  {
      18	    name      = "17-call",
      18	    open      = true,
      18	    lexical   = true,
      10	    syntactic = true,
      17	    semantic  = true,
      11	  },
      16	  {
      18	    name      = "18-fail-call",
      18	    open      = true,
      17	    lexical   = true,
      11	    syntactic = false,
      10	  },
      16	  {
      18	    name      = "19-callargs",
      18	    open      = true,
      17	    lexical   = true,
      17	    syntactic = true,
      11	    semantic  = false,
      11	  },
      16	  {
      18	    name      = "19-fail-callargs",
      17	    open      = true,
      17	    lexical   = true,
      18	    syntactic = false,
       4	  },
      16	  {
      18	    name      = "20-return",
      17	    open      = true,
      17	    lexical   = true,
      18	    syntactic = true,
      18	    semantic  = true,
       4	  },
      16	  {
      17	    name      = "21-arrays",
      17	    open      = true,
      18	    lexical   = true,
      18	    syntactic = true,
      12	    semantic  = true,
      10	  },
      16	  {
      16	    name      = "21-return-noargs",
      18	    open      = true,
      18	    lexical   = true,
      12	    syntactic = true,
      18	    semantic  = true,
      10	  },
      14	  {
      18	    name      = "22-exp",
      18	    open      = true,
      12	    lexical   = true,
      18	    syntactic = true,
      17	    semantic  = false,
       9	  },
      16	  {
      17	    name      = "22-fail-exp",
      11	    open      = true,
      17	    lexical   = true,
      16	    syntactic = false,
       9	  },
      15	  {
      17	    name      = "23-fail-fun",
      12	    open      = true,
      18	    lexical   = true,
      74	    syntactic = false,
      66	  },
      15	  {
      75	    name      = "24-fail-fun2",
      68	    open      = true,
      74	    lexical   = true,
      73	    syntactic = false,
       9	  },
      15	  {
      17	    name      = "25-fail-fun3",
      68	    open      = true,
      74	    lexical   = true,
      73	    syntactic = false,
       9	  },
      15	  {
      74	    name      = "26-fail-fun4",
      11	    open      = true,
      17	    lexical   = true,
      73	    syntactic = false,
      10	  },
      15	  {
      73	    name      = "27-fail-global",
      67	    open      = true,
      17	    lexical   = true,
      16	    syntactic = false,
       9	  },
      15	  {
      17	    name      = "28-fail-block",
      68	    open      = true,
      73	    lexical   = true,
      72	    syntactic = false,
      10	  },
      14	  {
      73	    name      = "29-fail-params",
      11	    open      = true,
      17	    lexical   = true,
      72	    syntactic = false,
      10	  },
      14	  {
      17	    name      = "30-fail-param",
      11	    open      = true,
      17	    lexical   = true,
      16	    syntactic = false,
      67	  },
      70	  {
      73	    name      = "31-fail-type",
      10	    open      = true,
      16	    lexical   = true,
      71	    syntactic = false,
       9	  },
      14	  {
      72	    name      = "32-fail-declvar",
      42	    open      = true,
      11	    lexical   = true,
      16	    syntactic = false,
      75	  },
      79	  {
      16	    name      = "33-fail-missingexp",
     139	    open      = true,
     105	    lexical   = true,
     110	    syntactic = false,
      74	  },
      79	  {
      46	    name      = "34-fail-invalidexp",
      16	    open      = true,
      10	    lexical   = true,
     111	    syntactic = false,
      90	  },
      73	  {
      10	    name      = "35-expprio",
      10	    open      = true,
      75	    lexical   = true,
      10	    syntactic = true,
      66	    semantic  = false,
     131	  },
      15	  {
     482	    name      = "36-fail-roottoken",
     418	    open      = true,
      76	    lexical   = true,
     487	    syntactic = false,
     411	  },
     415	  {
     417	    name      = "37-invprio",
     417	    open      = true,
       9	    lexical   = true,
      76	    syntactic = true,
      67	    semantic  = false,
     481	  },
        	
        	  -- ITERATION 4
     135	  {
      72	    name      = "01-fail-fun",
     410	    open      = true,
     137	    lexical   = true,
      73	    syntactic = true,
     487	    semantic  = false,
      85	  },
     580	  {
     499	    name      = "02-fail-argtype",
     404	    open      = true,
     973	    lexical   = true,
     632	    syntactic = true,
     632	    semantic  = false,
     569	  },
     497	  {
      65	    name      = "03-fail-argcount",
     480	    open      = true,
     404	    lexical   = true,
     964	    syntactic = true,
     595	    semantic  = false,
     500	  },
     403	  {
       2	    name      = "04-fail-void",
     568	    open      = true,
     473	    lexical   = true,
      73	    syntactic = true,
     536	    semantic  = false,
      46	  },
       7	  {
       2	    name      = "05-void2",
     599	    open      = true,
     969	    lexical   = true,
     467	    syntactic = true,
     435	    semantic  = true,
      31	  },
      69	  {
     398	    name      = "06-fail-global",
     499	    open      = true,
     561	    lexical   = true,
     889	    syntactic = true,
     223	    semantic  = false,
      67	  },
     555	  {
      59	    name      = "07-globalok",
       2	    open      = true,
     562	    lexical   = true,
     550	    syntactic = true,
     310	    semantic  = true,
     244	  },
        	  {
      70	    name      = "08-global-as-arg",
     242	    open      = true,
     499	    lexical   = true,
     553	    syntactic = true,
     751	    semantic  = true,
     184	  },
       1	  {
     485	    name      = "09-fail-undecl",
       3	    open      = true,
       2	    lexical   = true,
     555	    syntactic = true,
     634	    semantic  = false,
     452	  },
     408	  {
       2	    name      = "10-fail-undecl-fn",
      44	    open      = true,
       2	    lexical   = true,
     907	    syntactic = true,
     345	    semantic  = false,
     347	  },
       1	  {
       3	    name      = "11-fail-redecl-arg",
     302	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
     372	    semantic  = false,
     315	  },
      76	  {
       2	    name      = "12-fail-redecl-arg2",
       8	    open      = true,
       2	    lexical   = true,
      72	    syntactic = true,
     499	    semantic  = false,
     500	  },
     496	  {
     185	    name      = "13-fail-redecl-arg3",
       2	    open      = true,
       2	    lexical   = true,
     499	    syntactic = true,
       2	    semantic  = false,
      18	  },
       1	  {
       2	    name      = "14-fail-redecl-arg4",
       3	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
      16	  },
       7	  {
       2	    name      = "15-assign",
       9	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "16-return-var",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "17-if",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "18-fail-if",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "19-fail-elseif",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "20-fail-while",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "21-while",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "22-exp-int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "23-exp-char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "24-call",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "25-eqvect",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "26-exp-boolidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "27-exp-bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "28-expcall",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "29-exp-intchar2",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "30-exp-intcharidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "31-exp-intchar",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "32-fail-litbool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "33-fail-litnum",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "34-fail-litstring",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "35-fail-new",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "36-fail-rel2",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "37-fail-rel",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "38-new",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "39-rel",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "40-return",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "41-scope-argvsglobal",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "42-scope-localvsglobal",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "43-scope-localvslocal",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "44-fail-global-redec",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "45-fail-fun-redec",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "100-int-int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "101-int-int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "102-int-int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "103-int-int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "104-int-char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "105-int-char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "106-int-char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "107-int-char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "108-fail-int-bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "109-fail-int-bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "110-fail-int-bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "111-fail-int-bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "112-fail-int-string",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "113-fail-int-string-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "114-fail-int-string-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "115-fail-int-string-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "116-fail-int-v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "117-fail-int-v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "118-fail-int-v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "119-fail-int-v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "120-fail-int-v_char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "121-fail-int-v_char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "122-fail-int-v_char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "123-fail-int-v_char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "124-fail-int-v_bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "125-fail-int-v_bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "126-fail-int-v_bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "127-fail-int-v_bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "128-fail-int-v_v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "129-fail-int-v_v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "130-fail-int-v_v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "131-fail-int-v_v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "132-char-int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "133-char-int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "134-char-int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "135-char-int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "136-char-char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "137-char-char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "138-char-char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "139-char-char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "140-fail-char-bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "141-fail-char-bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "142-fail-char-bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "143-fail-char-bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "144-fail-char-string",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "145-fail-char-string-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "146-fail-char-string-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "147-fail-char-string-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "148-fail-char-v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "149-fail-char-v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "150-fail-char-v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "151-fail-char-v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "152-fail-char-v_char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "153-fail-char-v_char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "154-fail-char-v_char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "155-fail-char-v_char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "156-fail-char-v_bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "157-fail-char-v_bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "158-fail-char-v_bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "159-fail-char-v_bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "160-fail-char-v_v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "161-fail-char-v_v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "162-fail-char-v_v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "163-fail-char-v_v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "164-fail-bool-int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "165-fail-bool-int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "166-fail-bool-int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "167-fail-bool-int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "168-fail-bool-char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "169-fail-bool-char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "170-fail-bool-char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "171-fail-bool-char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "172-bool-bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "173-bool-bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "174-bool-bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "175-bool-bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "176-fail-bool-string",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "177-fail-bool-string-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "178-fail-bool-string-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "179-fail-bool-string-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "180-fail-bool-v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "181-fail-bool-v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "182-fail-bool-v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "183-fail-bool-v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "184-fail-bool-v_char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "185-fail-bool-v_char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "186-fail-bool-v_char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "187-fail-bool-v_char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "188-fail-bool-v_bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "189-fail-bool-v_bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "190-fail-bool-v_bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "191-fail-bool-v_bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "192-fail-bool-v_v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "193-fail-bool-v_v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "194-fail-bool-v_v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "195-fail-bool-v_v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "196-fail-string-int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "197-fail-string-int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "198-fail-string-int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "199-fail-string-int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "200-fail-string-char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "201-fail-string-char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "202-fail-string-char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "203-fail-string-char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "204-fail-string-bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "205-fail-string-bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "206-fail-string-bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "207-fail-string-bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "208-string-string",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "209-string-string-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "210-string-string-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "211-string-string-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "212-fail-string-v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "213-fail-string-v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "214-fail-string-v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "215-fail-string-v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "216-string-v_char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "217-string-v_char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "218-string-v_char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "219-string-v_char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "220-fail-string-v_bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "221-fail-string-v_bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "222-fail-string-v_bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "223-fail-string-v_bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "224-fail-string-v_v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "225-fail-string-v_v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "226-fail-string-v_v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "227-fail-string-v_v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "228-fail-v_int-int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "229-fail-v_int-int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "230-fail-v_int-int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "231-fail-v_int-int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "232-fail-v_int-char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "233-fail-v_int-char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "234-fail-v_int-char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "235-fail-v_int-char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "236-fail-v_int-bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "237-fail-v_int-bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "238-fail-v_int-bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "239-fail-v_int-bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "240-fail-v_int-string",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "241-fail-v_int-string-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "242-fail-v_int-string-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "243-fail-v_int-string-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "244-v_int-v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "245-v_int-v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "246-v_int-v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "247-v_int-v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "248-fail-v_int-v_char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "249-fail-v_int-v_char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "250-fail-v_int-v_char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "251-fail-v_int-v_char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "252-fail-v_int-v_bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "253-fail-v_int-v_bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "254-fail-v_int-v_bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "255-fail-v_int-v_bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "256-fail-v_int-v_v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "257-fail-v_int-v_v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "258-fail-v_int-v_v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "259-fail-v_int-v_v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "260-fail-v_char-int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "261-fail-v_char-int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "262-fail-v_char-int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "263-fail-v_char-int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "264-fail-v_char-char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "265-fail-v_char-char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "266-fail-v_char-char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "267-fail-v_char-char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "268-fail-v_char-bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "269-fail-v_char-bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "270-fail-v_char-bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "271-fail-v_char-bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "272-v_char-string",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "273-v_char-string-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "274-v_char-string-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "275-v_char-string-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "276-fail-v_char-v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "277-fail-v_char-v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "278-fail-v_char-v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "279-fail-v_char-v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "280-v_char-v_char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "281-v_char-v_char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "282-v_char-v_char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "283-v_char-v_char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "284-fail-v_char-v_bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "285-fail-v_char-v_bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "286-fail-v_char-v_bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "287-fail-v_char-v_bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "288-fail-v_char-v_v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "289-fail-v_char-v_v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "290-fail-v_char-v_v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "291-fail-v_char-v_v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "292-fail-v_bool-int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "293-fail-v_bool-int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "294-fail-v_bool-int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "295-fail-v_bool-int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "296-fail-v_bool-char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "297-fail-v_bool-char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "298-fail-v_bool-char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "299-fail-v_bool-char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "300-fail-v_bool-bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "301-fail-v_bool-bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "302-fail-v_bool-bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "303-fail-v_bool-bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "304-fail-v_bool-string",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "305-fail-v_bool-string-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "306-fail-v_bool-string-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "307-fail-v_bool-string-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "308-fail-v_bool-v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "309-fail-v_bool-v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "310-fail-v_bool-v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "311-fail-v_bool-v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "312-fail-v_bool-v_char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "313-fail-v_bool-v_char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "314-fail-v_bool-v_char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "315-fail-v_bool-v_char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "316-v_bool-v_bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "317-v_bool-v_bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "318-v_bool-v_bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "319-v_bool-v_bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "320-fail-v_bool-v_v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "321-fail-v_bool-v_v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "322-fail-v_bool-v_v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "323-fail-v_bool-v_v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "324-fail-v_v_int-int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "325-fail-v_v_int-int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "326-fail-v_v_int-int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "327-fail-v_v_int-int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "328-fail-v_v_int-char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "329-fail-v_v_int-char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "330-fail-v_v_int-char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "331-fail-v_v_int-char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "332-fail-v_v_int-bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "333-fail-v_v_int-bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "334-fail-v_v_int-bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "335-fail-v_v_int-bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "336-fail-v_v_int-string",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "337-fail-v_v_int-string-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "338-fail-v_v_int-string-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "339-fail-v_v_int-string-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "340-fail-v_v_int-v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "341-fail-v_v_int-v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "342-fail-v_v_int-v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "343-fail-v_v_int-v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "344-fail-v_v_int-v_char",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "345-fail-v_v_int-v_char-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "346-fail-v_v_int-v_char-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "347-fail-v_v_int-v_char-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "348-fail-v_v_int-v_bool",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "349-fail-v_v_int-v_bool-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "350-fail-v_v_int-v_bool-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "351-fail-v_v_int-v_bool-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = false,
       2	  },
        	  {
       2	    name      = "352-v_v_int-v_v_int",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "353-v_v_int-v_v_int-ret",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "354-v_v_int-v_v_int-retglob",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "355-v_v_int-v_v_int-retidx",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	
        	
        	  -- ITERATION 5
        	  {
       2	    name      = "icg_expression_negate",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "icg_expression_unary",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "icg_if",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "icg_if_else",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "icg_if_elseif",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "icg_if_elseif_else",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "icg_return",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
       2	  },
        	  {
       2	    name      = "icg_return_nil",
       2	    open      = true,
       2	    lexical   = true,
       2	    syntactic = true,
       2	    semantic  = true,
*******0	  },
       2	}
        	
        	
        	--==============================================================================
        	-- Private Methods
        	--==============================================================================
        	
        	local function Run ()
       2	  local num_files = 0
       2	  local num_files_read = 1
     762	  for _, _ in pairs (files) do
     760	    num_files = num_files + 1
        	  end
     762	  for _, valid in ipairs (files) do
        	    local file_str                  --  keeps the convertion of file to string
     760	    local unexpected_error = false  --  inform that an unexpected error occurs (if true stop further tests)
     760	    local expected_error = false    --  inform that an expected error occurs (if true stop further tests)
        	    local ok, msg
        	
        	    -- TEST OPENING
        	    ------------------------------------------------
     760	    if (not unexpected_error and not expected_error) then
     760	      local f = io.open("data/" .. valid.name .. ".txt", "r")
     760	      if (not f and valid.open) then
*******0	        unexpected_error = true
*******0	        print(string.format('(%3s de %3s) FAILURE - File "%s" expected to open.', num_files_read, num_files, valid.name))
     760	      elseif (f and not valid.open) then
*******0	        unexpected_error = true
*******0	        print(string.format('(%3s de %3s) FAILURE - File "%s" not expected to open.', num_files_read, num_files, valid.name))
     760	      elseif (not f and not valid.open) then
       2	        expected_error = true
       2	        msg = "@0 file error: could not be opened."
        	      else
     758	        file_str = f:read("*a")
     758	        f:close()
        	      end
        	    end
        	    
        	    -- TEST LEXICAL
        	    ------------------------------------------------
     760	    if (not unexpected_error and not expected_error) then
     758	      ok, msg = Lexical.Open(file_str)
     758	      if (not ok and valid.lexical) then
*******0	        unexpected_error = true
*******0	        print(string.format('(%3s de %3s) FAILURE - File "%s" expected to PASS on lexical. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     758	      elseif (ok and not valid.lexical) then
*******0	        unexpected_error = true
*******0	        print(string.format('(%3s de %3s) FAILURE - File "%s" expected to FAIL on lexical. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     758	      elseif (not ok and not valid.lexical) then
       2	        expected_error = true
        	      end
        	    end
        	    
        	    -- TEST SYNTAX
        	    ------------------------------------------------
     760	    if (not unexpected_error and not expected_error) then
     756	      ok, msg = Syntactic.Open(Lexical.GetTags())
     756	      if (not ok and valid.syntactic) then
*******0	        unexpected_error = true
*******0	        print(string.format('(%3s de %3s) FAILURE - File "%s" expected to PASS on syntactic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     756	      elseif (ok and not valid.syntactic) then
*******0	        unexpected_error = true
*******0	        print(string.format('(%3s de %3s) FAILURE - File "%s" expected to FAIL on syntactic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     756	      elseif (not ok and not valid.syntactic) then
      52	        expected_error = true
        	      end
        	    end
        	    
        	    -- TEST SEMANTIC
        	    ------------------------------------------------
     760	    if (not unexpected_error and not expected_error) then
     704	      ok, msg = Semantic.Open(Syntactic.GetTree())
     704	      if (not ok and valid.semantic) then
*******0	        unexpected_error = true
*******0	        print(string.format('(%3s de %3s) FAILURE - File "%s" expected to PASS on semantic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     704	      elseif (ok and not valid.semantic) then
*******0	        unexpected_error = true
*******0	        print(string.format('(%3s de %3s) FAILURE - File "%s" expected to FAIL on semantic. \n\t %s', num_files_read, num_files, valid.name, msg or ""))
     704	      elseif (not ok and not valid.semantic) then
     530	        expected_error = true
        	      end
        	    end
        	
        	    -- TEST INTERMEDIATE CODE GENERATOR
        	    ------------------------------------------------
     760	    if (not unexpected_error and not expected_error) then
     174	      ok, msg = InterCodeGen.Open("out/" .. valid.name, Semantic.GetTree())
     174	      if (not ok) then
      62	        print(string.format('(%3s de %3s) FAILURE - Unexpected error while writing intermediate code. \n\t', num_files_read, num_files))
        	      end
        	    end
        	
        	    -- PASSED ALL TESTS
        	    ------------------------------------------------
     760	    if (not unexpected_error or expected_error) then
     760	      print(string.format('(%3s de %3s) SUCCESS - File "%s".', num_files_read, num_files, valid.name))
     760	      if (expected_error and printFailMessage) then
*******0	        print("        ", msg)
        	      end
        	    end
     760	    num_files_read = num_files_read + 1
        	  end
        	end
        	
        	
        	--==============================================================================
        	-- Running
        	--==============================================================================
        	
       4	local ok, msg = pcall(function () Run() end)
       2	if (not ok) then
*******0	  print("Erro inesperado no teste automático. " .. msg)
        	end

==============================================================================
Summary
==============================================================================

34	6	85.00%	./lib/lulex.lua
24	4	85.71%	./lib/node_codes.lua
51	1	98.08%	./lib/token_codes.lua
62	64	49.21%	./lib/util.lua
123	10	92.48%	./lib/util_tree.lua
346	10	97.19%	./src/grammar.lua
244	5	97.99%	./src/intermediate_code.lua
176	1	99.44%	./src/lexical.lua
18	0	100.00%	./src/parser.lua
270	1	99.63%	./src/semantic.lua
54	4	93.10%	./src/symbol_table.lua
18	1	94.74%	./src/syntactic.lua
175	0	100.00%	./src/syntax_tree.lua
2386	19	99.21%	src/auto_test.lua
------------------------
3981	126	96.93%	
